From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Fri, 25 Oct 2019 02:11:30 -0700
Subject: [PATCH] Delay chunk unloads

Chunk unloads are now delayed by 30s. Specifically, ticket level
reduction is delayed by 30s. This is done to allow players to
teleport and have their pets follow them, as the chunks will no longer
unload or have entity ticking status removed.

It's also targetted to reduce performance regressions when
plugins or edge cases in code do not spam sync loads since chunks
without tickets get unloaded immediately.

diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 50444a2f49f07e66ff9ea55dacc1819023ea6624..b0c0e906f3bd8534a6ef0b274ffa163717b7672f 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -70,6 +70,7 @@ public abstract class ChunkMap extends LightEngineGraph {
 
     protected abstract int b(long i);
 
+    public final void update(long coordinate, int level, boolean increaseInLevel) { this.b(coordinate, level, increaseInLevel); } /* Concrete - OBFHELPER */
     public void b(long i, int j, boolean flag) {
         this.a(ChunkCoordIntPair.a, i, j, flag);
     }
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 78141c62eab8b714cfdd7a6a2c58a8b5d03ad22d..99fbaa015d2875ee24933774cbd43771f9900066 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -34,7 +34,7 @@ public abstract class ChunkMapDistance {
     private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2;
     private final Long2ObjectMap<ObjectSet<EntityPlayer>> c = new Long2ObjectOpenHashMap();
     public final Long2ObjectOpenHashMap<ObjectSortedSet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap(); // CraftBukkit - private -> public
-    private final ChunkMapDistance.a e = new ChunkMapDistance.a();
+    private final ChunkMapDistance.a e = new ChunkMapDistance.a(); final ChunkMapDistance.a getTicketTracker() { return this.e; } /* Concrete - OBFHELPER */
     public static final int MOB_SPAWN_RANGE = 8; //private final ChunkMapDistance.b f = new ChunkMapDistance.b(8); /* Concrete - no longer used */
     //private final ChunkMapDistance.c g = new ChunkMapDistance.c(33); /* Concrete - no longer used */
     private final java.util.Queue<PlayerChunk> pendingChunkUpdates = new java.util.ArrayDeque<>(); // PAIL pendingChunkUpdates // Paper - use a queue /* Concrete - use a better queue */
@@ -48,6 +48,45 @@ public abstract class ChunkMapDistance {
     /* Concrete start */
     protected PlayerChunkMap chunkMap;
     protected final ChunkMapDistance.TicketTracker playerTicketHandler = new TicketTracker();
+
+    private long nextUnloadId; // delay chunk unloads
+    private final Long2ObjectOpenHashMap<Ticket<Long>> delayedChunks = new Long2ObjectOpenHashMap<>();
+    public final void removeTickets(long chunk, TicketType<?> type) {
+        ObjectSortedSet<Ticket<?>> tickets = this.tickets.get(chunk);
+        if (tickets == null) {
+            return;
+        }
+        if (type == TicketType.DELAYED_UNLOAD) {
+            this.delayedChunks.remove(chunk);
+        }
+        boolean changed = tickets.removeIf((Ticket<?> ticket) -> {
+            return ticket.getTicketType() == type;
+        });
+        if (changed) {
+            this.getTicketTracker().update(chunk, getLowestTicketLevel(tickets), false);
+        }
+    }
+
+    private final java.util.function.LongFunction<Ticket<Long>> computeFuntion = (long key) -> {
+        Ticket<Long> ret = new Ticket<>(TicketType.DELAYED_UNLOAD, -1, ++ChunkMapDistance.this.nextUnloadId, 0);
+        ret.isCached = true;
+        return ret;
+    };
+
+    private void computeDelayedTicketFor(long chunk, int removedLevel, ObjectSortedSet<Ticket<?>> tickets) {
+        int lowestLevel = getLowestTicketLevel(tickets);
+        if (removedLevel > lowestLevel) {
+            return;
+        }
+        final Ticket<Long> ticket = this.delayedChunks.computeIfAbsent(chunk, this.computeFuntion);
+        if (ticket.getTicketLevel() != -1) {
+            // since we modify data used in sorting, we need to remove before
+            tickets.remove(ticket);
+        }
+        ticket.setCreationTick(this.currentTick);
+        ticket.setTicketLevel(removedLevel);
+        tickets.add(ticket); // re-add with new expire time and ticket level
+    }
     /* Concrete end */
 
     protected ChunkMapDistance(Executor executor, Executor executor1) {
@@ -66,12 +105,27 @@ public abstract class ChunkMapDistance {
         ++this.currentTick;
         ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
 
+        int[] tempLevel = new int[] { PlayerChunkMap.GOLDEN_TICKET + 1 }; /* Concrete - delay chunk unloads */
         while (objectiterator.hasNext()) {
             Entry<ObjectSortedSet<Ticket<?>>> entry = (Entry) objectiterator.next();
 
             if ((entry.getValue()).removeIf((ticket) -> { // Craftbukkit - decompile error
-                return ticket.a(this.currentTick);
+                /* Concrete start - delay chunk unloads */
+                boolean ret = ticket.a(this.currentTick);
+                if (ret && ticket.getTicketType() != TicketType.DELAYED_UNLOAD && ticket.getTicketLevel() < tempLevel[0]) {
+                    tempLevel[0] = ticket.getTicketLevel();
+                }
+                if (ticket.getTicketType() == TicketType.DELAYED_UNLOAD && ticket.isCached) {
+                    this.delayedChunks.remove(entry.getLongKey(), ticket); // clean up ticket...
+                }
+                return ret;
+                /* Concrete end - delay chunk unloads */
             })) {
+                /* Concrete start - delay chunk unloads */
+                if (tempLevel[0] < (PlayerChunkMap.GOLDEN_TICKET + 1)) {
+                    this.computeDelayedTicketFor(entry.getLongKey(), tempLevel[0], entry.getValue());
+                }
+                /* Concrete end - delay chunk unloads */
                 this.e.b(entry.getLongKey(), this.a((ObjectSortedSet) entry.getValue()), false);
             }
 
@@ -177,6 +231,11 @@ public abstract class ChunkMapDistance {
         boolean removed = false; // CraftBukkit
         if (objectsortedset.remove(ticket)) {
             removed = true; // CraftBukkit
+            /* Concrete start - delay chunk unloads */
+            if (ticket.getTicketType() != TicketType.DELAYED_UNLOAD) {
+                this.computeDelayedTicketFor(i, ticket.getTicketLevel(), objectsortedset);
+            }
+            /* Concrete end - delay chunk unloads */
         }
 
         if (objectsortedset.isEmpty()) {
diff --git a/src/main/java/net/minecraft/server/Ticket.java b/src/main/java/net/minecraft/server/Ticket.java
index badbe6c19d1699659ff6d35f813c069272cda929..9a32eee3e7532e46b692d000a6cbf48d9e84105a 100644
--- a/src/main/java/net/minecraft/server/Ticket.java
+++ b/src/main/java/net/minecraft/server/Ticket.java
@@ -5,9 +5,11 @@ import java.util.Objects;
 public final class Ticket<T> implements Comparable<Ticket<?>> {
 
     private final TicketType<T> a;
-    private final int b;
+    private int b; public final void setTicketLevel(final int value) { this.b = value; } /* Concrete - remove final, add set OBFHELPER  */
     public final T identifier; public final T getObjectReason() { return this.identifier; } // Paper - OBFHELPER
-    private final long d; public final long getCreationTick() { return this.d; } // Paper - OBFHELPER
+    private long d; public final long getCreationTick() { return this.d; } public final void setCreationTick(final long value) { this.d = value; }  // Paper - OBFHELPER /* Concrete - remove final, add set OBFHELPER */
+
+    boolean isCached; /* Concrete - delay chunk unloads, this defends against really stupid plugins */
 
     protected Ticket(TicketType<T> tickettype, int i, T t0, long j) {
         this.a = tickettype;
diff --git a/src/main/java/net/minecraft/server/TicketType.java b/src/main/java/net/minecraft/server/TicketType.java
index e3150f85a5b738c560969cc0a3c9c62f17dc2414..90d945cf1aeedb7fd778ffeab66238eba015b449 100644
--- a/src/main/java/net/minecraft/server/TicketType.java
+++ b/src/main/java/net/minecraft/server/TicketType.java
@@ -23,6 +23,7 @@ public class TicketType<T> {
     public static final TicketType<org.bukkit.plugin.Plugin> PLUGIN_TICKET = a("plugin_ticket", (plugin1, plugin2) -> plugin1.getClass().getName().compareTo(plugin2.getClass().getName())); // Craftbukkit
     public static final TicketType<Integer> ANTIXRAY = a("antixray", Integer::compareTo); // Paper - Anti-Xray
     public static final TicketType<Long> ASYNC_LOAD = a("async_load", Long::compareTo); // Paper
+    public static final TicketType<Long> DELAYED_UNLOAD = a("delayed_unload", Long::compareTo, 30 * 20); /* Concrete - delay chunk unloads by 30 seconds */
 
     public static <T> TicketType<T> a(String s, Comparator<T> comparator) {
         return new TicketType<>(s, comparator, 0L);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 78ea65707432be1d78d2090be6997d486d2b9223..c4769046cbcd9c01e1801a12759c3147c14cecd0 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -462,6 +462,7 @@ public class CraftWorld implements World {
         net.minecraft.server.IChunkAccess chunk = world.getChunkProvider().getChunkAt(x, z, ChunkStatus.FULL, false);
         if (chunk != null) {
             world.getChunkProvider().removeTicket(TicketType.PLUGIN, chunk.getPos(), 1, Unit.INSTANCE);
+            ((ChunkMapDistance)world.getChunkProvider().playerChunkMap.getChunkMapDistanceManager()).removeTickets(ChunkCoordIntPair.pair(x, z), TicketType.DELAYED_UNLOAD); /* Concrete - delay chunk unloads - let plugins override */
         }
 
         return true;
-- 
2.22.1

