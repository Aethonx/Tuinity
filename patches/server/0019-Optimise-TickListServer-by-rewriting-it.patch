From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Wed, 27 Nov 2019 03:13:53 -0800
Subject: [PATCH] Optimise TickListServer by rewriting it

In my profiling TickListServer showed up as
~10% for saving chunks and ~5% for the scheduling
of items on a server with ~90 players at
view distance = 5. Most of the performance
loss is unneccessary.

TickListServer has numerous performance issues:
 1. Handling scheduled items is O(nlogn)
 2. Getting scheduled items for a chunk is O(n),
    with n being the the number of scheduled items
    for all chunks (hits saving very hard)
 3. Checking if an item is scheduled for the current tick is O(n),
    with n being the number of items scheduled for current tick
 4. Items not in ticking chunks are churned in the scheduler

The biggest issues are 4 & 2.

We solve 1 by splitting up scheduled items into short and long scheduled,
where we expect the vast majority of our entries to be in the short scheduled
set. Handling short scheduled items is O(n) due to how the comparison
process is reduced to mapping. See TickListServerInterval. However,
this isn't memory-efficient - which is why long scheduled exists.
Long scheduled is handled the same as TickListServer.

2 is solved by mapping what entries are in what chunks.

3 is solved by mapping what blocks have what scheduled for them.

4 is solved by moving the items that are not in ticking chunks
into a map of entries for that chunk. Once the chunk is moved
to ticking, the items are re-scheduled.

diff --git a/src/main/java/com/tuinity/tuinity/server/TickListServerInterval.java b/src/main/java/com/tuinity/tuinity/server/TickListServerInterval.java
new file mode 100644
index 0000000000000000000000000000000000000000..bef788ccfad2b74c3adca54fc62180060f157116
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/server/TickListServerInterval.java
@@ -0,0 +1,42 @@
+package com.tuinity.tuinity.server;
+
+import com.tuinity.tuinity.util.set.LinkedSortedSet;
+import net.minecraft.server.NextTickListEntry;
+import net.minecraft.server.TickListPriority;
+
+import java.util.Comparator;
+
+// represents a set of entries to tick at a specified time
+public final class TickListServerInterval<T> {
+
+    public static final int TOTAL_PRIORITIES = TickListPriority.values().length;
+    public static final Comparator<NextTickListEntry<?>> ENTRY_COMPARATOR_BY_ID = (entry1, entry2) -> {
+        return Long.compare(entry1.getId(), entry2.getId());
+    };
+    public static final Comparator<NextTickListEntry<?>> ENTRY_COMPARATOR = (Comparator)NextTickListEntry.comparator();
+
+    // we do not record the interval, this class is meant to be used on a ring buffer
+
+    // inlined enum map for TickListPriority
+    public final LinkedSortedSet<NextTickListEntry<T>>[] byPriority = new LinkedSortedSet[TOTAL_PRIORITIES];
+
+    {
+        for (int i = 0, len = this.byPriority.length; i < len; ++i) {
+            this.byPriority[i] = new LinkedSortedSet<>(ENTRY_COMPARATOR_BY_ID);
+        }
+    }
+
+    public void addEntryLast(final NextTickListEntry<T> entry) {
+        this.byPriority[entry.getPriority().ordinal()].addLast(entry);
+    }
+
+    public void addEntryFirst(final NextTickListEntry<T> entry) {
+        this.byPriority[entry.getPriority().ordinal()].addFirst(entry);
+    }
+
+    public void clear() {
+        for (int i = 0, len = this.byPriority.length; i < len; ++i) {
+            this.byPriority[i].clear(); // O(1) clear
+        }
+    }
+}
diff --git a/src/main/java/com/tuinity/tuinity/server/TuinityTickList.java b/src/main/java/com/tuinity/tuinity/server/TuinityTickList.java
new file mode 100644
index 0000000000000000000000000000000000000000..11f1d0c1b2c809bc5f12d1a7a9d4804daa65b600
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/server/TuinityTickList.java
@@ -0,0 +1,563 @@
+package com.tuinity.tuinity.server;
+
+import com.tuinity.tuinity.util.TickThread;
+import com.tuinity.tuinity.util.Util;
+import ca.spottedleaf.concurrentutil.util.Validate;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet;
+import net.minecraft.server.BaseBlockPosition;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkProviderServer;
+import net.minecraft.server.CrashReport;
+import net.minecraft.server.CrashReportSystemDetails;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.MinecraftKey;
+import net.minecraft.server.NBTTagList;
+import net.minecraft.server.NextTickListEntry;
+import net.minecraft.server.ReportedException;
+import net.minecraft.server.StructureBoundingBox;
+import net.minecraft.server.TickListPriority;
+import net.minecraft.server.TickListServer;
+import net.minecraft.server.WorldServer;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+public final class TuinityTickList<T> extends TickListServer<T> { // extend to avoid breaking ABI
+
+    // in the order the state is expected to change (mostly)
+    public static final int STATE_UNSCHEDULED    = 1 << 0;
+    public static final int STATE_SCHEDULED      = 1 << 1; // scheduled for some tick
+    public static final int STATE_PENDING_TICK   = 1 << 2; // for this tick
+    public static final int STATE_TICKING        = 1 << 3;
+    public static final int STATE_TICKED         = 1 << 4; // after this, it gets thrown back to unscheduled
+    public static final int STATE_CANCELLED_TICK = 1 << 5; // still gets moved to unscheduled after tick
+
+    private static final int SHORT_SCHEDULE_TICK_THRESHOLD = 20 * 5 + 1; // 5 seconds
+
+    private final WorldServer world;
+    private final Predicate<T> excludeFromScheduling;
+    private final Function<T, MinecraftKey> getMinecraftKeyFrom;
+    private final Function<MinecraftKey, T> getObjectFronMinecraftKey;
+    private final Consumer<NextTickListEntry<T>> tickFunction;
+
+    private final co.aikar.timings.Timing timingCleanup; // Paper
+    private final co.aikar.timings.Timing timingTicking; // Paper
+    private final co.aikar.timings.Timing timingFinished;
+
+    // note: remove ops / add ops suck on fastutil, a chained hashtable implementation would work better, but Long...
+    // try to alleviate with a very small load factor
+    private final Long2ObjectOpenHashMap<ArrayList<NextTickListEntry<T>>> entriesByBlock = new Long2ObjectOpenHashMap<>(1024, 0.25f);
+    private final Long2ObjectOpenHashMap<ObjectRBTreeSet<NextTickListEntry<T>>> entriesByChunk = new Long2ObjectOpenHashMap<>(1024, 0.25f);
+    private final Long2ObjectOpenHashMap<ArrayList<NextTickListEntry<T>>> pendingChunkTickLoad = new Long2ObjectOpenHashMap<>(1024, 0.5f);
+
+    // fastutil has O(1) first/last while TreeMap/TreeSet are log(n)
+    private final ObjectRBTreeSet<NextTickListEntry<T>> longScheduled = new ObjectRBTreeSet<>(TickListServerInterval.ENTRY_COMPARATOR);
+
+    private final ArrayDeque<NextTickListEntry<T>> toTickThisTick = new ArrayDeque<>();
+
+    private final TickListServerInterval<T>[] shortScheduled = new TickListServerInterval[SHORT_SCHEDULE_TICK_THRESHOLD];
+    {
+        for (int i = 0, len = this.shortScheduled.length; i < len; ++i) {
+            this.shortScheduled[i] = new TickListServerInterval<>();
+        }
+    }
+    private int shortScheduledIndex;
+
+    private long nextTick;
+
+    // assume index < length
+    private static int getWrappedIndex(final int start, final int length, final int index) {
+        final int next = start + index;
+        return next < length ? next : next - length;
+    }
+
+    private static int getNextIndex(final int curr, final int length) {
+        final int next = curr + 1;
+        return next < length ? next : 0;
+    }
+
+    public TuinityTickList(final WorldServer world, final Predicate<T> excludeFromScheduling, final Function<T, MinecraftKey> getMinecraftKeyFrom,
+                            final Function<MinecraftKey, T> getObjectFronMinecraftKey, final Consumer<NextTickListEntry<T>> tickFunction, final String timingsType) {
+        super(world, excludeFromScheduling, getMinecraftKeyFrom, getObjectFronMinecraftKey, tickFunction, timingsType);
+        this.world = world;
+        this.excludeFromScheduling = excludeFromScheduling;
+        this.getMinecraftKeyFrom = getMinecraftKeyFrom;
+        this.getObjectFronMinecraftKey = getObjectFronMinecraftKey;
+        this.tickFunction = tickFunction;
+        this.timingCleanup = co.aikar.timings.WorldTimingsHandler.getTickList(world, timingsType + " - Cleanup"); // Paper
+        this.timingTicking = co.aikar.timings.WorldTimingsHandler.getTickList(world, timingsType + " - Ticking"); // Paper
+        this.timingFinished = co.aikar.timings.WorldTimingsHandler.getTickList(world, timingsType + " - Finish");
+        this.nextTick = this.world.getTime();
+    }
+
+    private void queueEntryForTick(final NextTickListEntry<T> entry, final ChunkProviderServer chunkProvider) {
+        if (entry.tickState == STATE_SCHEDULED) {
+            if (chunkProvider.isTickingReadyMainThread(entry.getPosition())) {
+                this.toTickThisTick.add(entry);
+                entry.tickState = STATE_PENDING_TICK;
+            } else {
+                // we dump them to a map to avoid constantly re-scheduling them
+                this.addToNotTickingReady(entry);
+            }
+        } else {
+            this.onTickEnd(entry);
+        }
+    }
+
+    private void addToNotTickingReady(final NextTickListEntry<T> entry) {
+        this.pendingChunkTickLoad.computeIfAbsent(Util.getCoordinateKey(entry.getPosition()), (long keyInMap) -> {
+            return new ArrayList<>();
+        }).add(entry);
+    }
+
+    private void addToSchedule(final NextTickListEntry<T> entry) {
+        long delay = entry.getTargetTick() - this.nextTick;
+        if (delay < SHORT_SCHEDULE_TICK_THRESHOLD) {
+            if (delay < 0) {
+                // longScheduled orders by tick time, short scheduled does not
+                this.longScheduled.add(entry);
+            } else {
+                this.shortScheduled[getWrappedIndex(this.shortScheduledIndex, SHORT_SCHEDULE_TICK_THRESHOLD, (int)delay)].addEntryLast(entry);
+            }
+        } else {
+            this.longScheduled.add(entry);
+        }
+    }
+
+    public void onChunkSetTicking(final int chunkX, final int chunkZ) {
+        TickThread.softEnsureTickThread("async tick list chunk ticking update");
+        final ArrayList<NextTickListEntry<T>> pending = this.pendingChunkTickLoad.remove(Util.getCoordinateKey(chunkX, chunkZ));
+        if (pending == null) {
+            return;
+        }
+
+        for (int i = 0, size = pending.size(); i < size; ++i) {
+            final NextTickListEntry<T> entry = pending.get(i);
+            // already in all the relevant reference maps, just need to add to longScheduled or shortScheduled
+            this.addToSchedule(entry);
+        }
+    }
+
+    private void prepare() {
+        final long currentTick = this.world.getTime();
+
+        final ChunkProviderServer chunkProvider = this.world.getChunkProvider();
+
+        // here we setup what's going to tick
+
+        // we don't remove items from shortScheduled (but do from longScheduled) because they're cleared at the end of
+        // this tick
+        if (this.longScheduled.isEmpty() || this.longScheduled.first().getTargetTick() > currentTick) {
+            // nothing in longScheduled to worry about
+            final TickListServerInterval<T> interval = this.shortScheduled[this.shortScheduledIndex];
+            for (int i = 0, len = interval.byPriority.length; i < len; ++i) {
+                for (final Iterator<NextTickListEntry<T>> iterator = interval.byPriority[i].iterator(); iterator.hasNext();) {
+                    this.queueEntryForTick(iterator.next(), chunkProvider);
+                }
+            }
+        } else {
+            final TickListServerInterval<T> interval = this.shortScheduled[this.shortScheduledIndex];
+
+            // combine interval and longScheduled, keeping order
+            final Comparator<NextTickListEntry<T>> comparator = (Comparator)TickListServerInterval.ENTRY_COMPARATOR;
+            final Iterator<NextTickListEntry<T>> longScheduledIterator = this.longScheduled.iterator();
+            NextTickListEntry<T> longCurrent = longScheduledIterator.next();
+
+            for (int i = 0, len = interval.byPriority.length; i < len; ++i) {
+                for (final Iterator<NextTickListEntry<T>> iterator = interval.byPriority[i].iterator(); iterator.hasNext();) {
+                    final NextTickListEntry<T> shortCurrent = iterator.next();
+                    if (longCurrent != null) {
+                        // drain longCurrent until we can add shortCurrent
+                        while (comparator.compare(longCurrent, shortCurrent) <= 0) {
+                            this.queueEntryForTick(longCurrent, chunkProvider);
+                            longScheduledIterator.remove();
+                            if (longScheduledIterator.hasNext()) {
+                                longCurrent = longScheduledIterator.next();
+                                if (longCurrent.getTargetTick() > currentTick) {
+                                    longCurrent = null;
+                                    break;
+                                }
+                            } else {
+                                longCurrent = null;
+                                break;
+                            }
+                        }
+                    }
+                    this.queueEntryForTick(shortCurrent, chunkProvider);
+                }
+            }
+
+            // add remaining from long scheduled
+            for (;;) {
+                if (longCurrent == null || longCurrent.getTargetTick() > currentTick) {
+                    break;
+                }
+                longScheduledIterator.remove();
+                this.queueEntryForTick(longCurrent, chunkProvider);
+
+                if (longScheduledIterator.hasNext()) {
+                    longCurrent = longScheduledIterator.next();
+                } else {
+                    break;
+                }
+            }
+        }
+    }
+
+    @Override
+    public void tick() {
+        TickThread.softEnsureTickThread("async tick list tick");
+        final ChunkProviderServer chunkProvider = this.world.getChunkProvider();
+
+        this.world.getMethodProfiler().enter("cleaning");
+        this.timingCleanup.startTiming();
+
+        this.prepare();
+
+        // this must be done here in case something schedules in the tick code
+        this.shortScheduled[this.shortScheduledIndex].clear();
+        this.shortScheduledIndex = getNextIndex(this.shortScheduledIndex, SHORT_SCHEDULE_TICK_THRESHOLD);
+        this.nextTick = this.world.getTime() + 1;
+
+        this.timingCleanup.stopTiming();
+        this.world.getMethodProfiler().exitEnter("ticking");
+        this.timingTicking.startTiming();
+
+        for (final NextTickListEntry<T> toTick : this.toTickThisTick) {
+            if (toTick.tickState != STATE_PENDING_TICK) {
+                // onTickEnd gets called at end of tick
+                continue;
+            }
+            try {
+                if (chunkProvider.isTickingReadyMainThread(toTick.getPosition())) {
+                    toTick.tickState = STATE_TICKING;
+                    this.tickFunction.accept(toTick);
+                    toTick.tickState = STATE_TICKED;
+                } else {
+                    // re-schedule eventually
+                    toTick.tickState = STATE_SCHEDULED;
+                    this.addToNotTickingReady(toTick);
+                }
+            } catch (final Throwable thr) {
+                // start copy from TickListServer // TODO check on update
+                CrashReport crashreport = CrashReport.a(thr, "Exception while ticking");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
+
+                CrashReportSystemDetails.a(crashreportsystemdetails, toTick.getPosition(), (IBlockData) null);
+                throw new ReportedException(crashreport);
+                // end copy from TickListServer
+            }
+        }
+
+        this.timingTicking.stopTiming();
+        this.world.getMethodProfiler().exit();
+        this.timingFinished.startTiming();
+
+        // finished ticking, actual cleanup time
+        for (int i = 0, len = this.toTickThisTick.size(); i < len; ++i) {
+            final NextTickListEntry<T> entry = this.toTickThisTick.poll();
+            if (entry.tickState != STATE_SCHEDULED) {
+                // some entries get re-scheduled due to their chunk not being loaded/at correct status, so do not
+                // call onTickEnd for them
+                this.onTickEnd(entry);
+            }
+        }
+
+        this.timingFinished.stopTiming();
+    }
+
+    private void onTickEnd(final NextTickListEntry<T> entry) {
+        entry.tickState = STATE_UNSCHEDULED;
+
+        final BlockPosition pos = entry.getPosition();
+        final long blockKey = Util.getBlockKey(pos);
+
+        final ArrayList<NextTickListEntry<T>> currentEntries = this.entriesByBlock.get(blockKey);
+
+        if (currentEntries.size() == 1) {
+            // it should contain our entry
+            this.entriesByBlock.remove(blockKey);
+        } else {
+            // it's more likely that this entry is at the start of the list than the end
+            for (int i = 0, len = currentEntries.size(); i < len; ++i) {
+                final NextTickListEntry<T> currentEntry = currentEntries.get(i);
+                if (currentEntry == entry) {
+                    currentEntries.remove(i);
+                    break;
+                }
+            }
+        }
+
+        final long chunkKey = Util.getCoordinateKey(entry.getPosition());
+
+        ObjectRBTreeSet<NextTickListEntry<T>> set = this.entriesByChunk.get(chunkKey);
+
+        set.remove(entry);
+
+        if (set.isEmpty()) {
+            this.entriesByChunk.remove(chunkKey);
+        }
+
+        // already removed from longScheduled or shortScheduled
+    }
+
+    @Override
+    public boolean isPendingTickThisTick(final BlockPosition blockposition, final T data) {
+        final ArrayList<NextTickListEntry<T>> entries = this.entriesByBlock.get(Util.getBlockKey(blockposition));
+
+        if (entries == null) {
+            return false;
+        }
+
+        for (int i = 0, size = entries.size(); i < size; ++i) {
+            final NextTickListEntry<T> entry = entries.get(i);
+            if (entry.getData() == data && entry.tickState == STATE_PENDING_TICK) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean isScheduledForTick(final BlockPosition blockposition, final T data) {
+        final ArrayList<NextTickListEntry<T>> entries = this.entriesByBlock.get(Util.getBlockKey(blockposition));
+
+        if (entries == null) {
+            return false;
+        }
+
+        for (int i = 0, size = entries.size(); i < size; ++i) {
+            final NextTickListEntry<T> entry = entries.get(i);
+            if (entry.getData() == data && entry.tickState == STATE_SCHEDULED) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public void schedule(BlockPosition blockPosition, T t, int i, TickListPriority tickListPriority) {
+        this.schedule(blockPosition, t, i + this.world.getTime(), tickListPriority);
+    }
+
+    public void schedule(final NextTickListEntry<T> entry) {
+        this.schedule(entry.getPosition(), entry.getData(), entry.getTargetTick(), entry.getPriority());
+    }
+
+    public void schedule(final BlockPosition pos, final T data, final long targetTick, final TickListPriority priority) {
+        TickThread.softEnsureTickThread("async tick list schedule");
+
+        final NextTickListEntry<T> entry = new NextTickListEntry<>(pos, data, targetTick, priority);
+        Validate.notNull(entry, "null entry");
+        if (this.excludeFromScheduling.test(entry.getData())) {
+            return;
+        }
+
+        final long blockKey = Util.getBlockKey(pos);
+
+        final ArrayList<NextTickListEntry<T>> currentEntries = this.entriesByBlock.computeIfAbsent(blockKey, (long keyInMap) -> new ArrayList<>(3));
+
+        if (currentEntries.isEmpty()) {
+            currentEntries.add(entry);
+        } else {
+            for (int i = 0, size = currentEntries.size(); i < size; ++i) {
+                final NextTickListEntry<T> currentEntry = currentEntries.get(i);
+
+                // entries are only blocked from scheduling if currentEntry.equals(toSchedule) && currentEntry is scheduled to tick (NOT including pending)
+                if (currentEntry.getData() == entry.getData() && currentEntry.tickState == STATE_SCHEDULED) {
+                    // can't add
+                    return;
+                }
+            }
+            currentEntries.add(entry);
+        }
+
+        entry.tickState = STATE_SCHEDULED;
+
+        this.entriesByChunk.computeIfAbsent(Util.getCoordinateKey(entry.getPosition()), (final long keyInMap) -> {
+            return new ObjectRBTreeSet<>(TickListServerInterval.ENTRY_COMPARATOR);
+        }).add(entry);
+
+        this.addToSchedule(entry);
+    }
+
+    @Override
+    public void scheduleAll(final Stream<NextTickListEntry<T>> stream) {
+        this.scheduleAll(stream.iterator());
+    }
+    public void scheduleAll(final Iterator<NextTickListEntry<T>> iterator) {
+        while (iterator.hasNext()) {
+            this.schedule(iterator.next());
+        }
+    }
+
+    // this is not the standard interception calculation, but it's the one vanilla uses
+    // i.e the y value is ignored? the x, z calc isn't correct?
+    // however for the copy op they use the correct intersection, after using this one of course...
+    private static boolean isBlockInSortof(final StructureBoundingBox boundingBox, final BlockPosition pos) {
+        return pos.getX() >= boundingBox.getMinX() && pos.getX() < boundingBox.getMaxX() && pos.getZ() >= boundingBox.getMinZ() && pos.getZ() < boundingBox.getMaxZ();
+    }
+
+    @Override
+    public List<NextTickListEntry<T>> getEntriesInBoundingBox(final StructureBoundingBox structureboundingbox, final boolean removeReturned, final boolean excludeTicked) {
+        TickThread.softEnsureTickThread("async tick list get");
+        if (structureboundingbox.getMinX() == structureboundingbox.getMaxX() || structureboundingbox.getMinZ() == structureboundingbox.getMaxZ()) {
+            return Collections.emptyList(); // vanilla behaviour, check isBlockInSortof above
+        }
+
+        final int lowerChunkX = structureboundingbox.getMinX() >> 4;
+        final int upperChunkX = (structureboundingbox.getMaxX() - 1) >> 4; // subtract 1 since maxX is exclusive
+        final int lowerChunkZ = structureboundingbox.getMinZ() >> 4;
+        final int upperChunkZ = (structureboundingbox.getMaxZ() - 1) >> 4; // subtract 1 since maxZ is exclusive
+
+        final int xChunksLength = (upperChunkX - lowerChunkX + 1);
+        final int zChunksLength = (upperChunkZ - lowerChunkZ + 1);
+
+        final ObjectRBTreeSet<NextTickListEntry<T>>[] containingChunks = new ObjectRBTreeSet[xChunksLength * zChunksLength];
+
+        final int offset = (xChunksLength * -lowerChunkZ - lowerChunkX);
+        int totalEntries = 0;
+        for (int currChunkX = lowerChunkX; currChunkX <= upperChunkX; ++currChunkX) {
+            for (int currChunkZ = lowerChunkZ; currChunkZ <= upperChunkZ; ++currChunkZ) {
+                // todo optimize
+                //final int index = (currChunkX - lowerChunkX) + xChunksLength * (currChunkZ - lowerChunkZ);
+                final int index = offset + currChunkX + xChunksLength * currChunkZ;
+                final ObjectRBTreeSet<NextTickListEntry<T>> set = containingChunks[index] = this.entriesByChunk.get(Util.getCoordinateKey(currChunkX, currChunkZ));
+                if (set != null) {
+                    totalEntries += set.size();
+                }
+            }
+        }
+
+        final List<NextTickListEntry<T>> ret = new ArrayList<>(totalEntries);
+
+        final int matchOne = (STATE_SCHEDULED | STATE_PENDING_TICK) | (excludeTicked ? 0 : (STATE_TICKING | STATE_TICKED));
+
+        Util.mergeSortedSets((NextTickListEntry<T> entry) -> {
+            if (!isBlockInSortof(structureboundingbox, entry.getPosition())) {
+                return;
+            }
+            final int tickState = entry.tickState;
+            if ((tickState & matchOne) == 0) {
+                return;
+            }
+
+            ret.add(entry);
+            if (removeReturned) {
+                // TODO for long scheduled stuff we might want to kill the entry earlier.
+                entry.tickState = STATE_CANCELLED_TICK;
+            }
+            return;
+        }, TickListServerInterval.ENTRY_COMPARATOR, containingChunks);
+
+        return ret;
+    }
+
+    @Override
+    public void copy(StructureBoundingBox structureboundingbox, BlockPosition blockposition) {
+        TickThread.softEnsureTickThread("async tick list copy");
+        // start copy from TickListServer // TODO check on update
+        List<NextTickListEntry<T>> list = this.getEntriesInBoundingBox(structureboundingbox, false, false);
+        Iterator<NextTickListEntry<T>> iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            NextTickListEntry<T> nextticklistentry = iterator.next();
+
+            if (structureboundingbox.hasPoint( nextticklistentry.getPosition())) {
+                BlockPosition blockposition1 = nextticklistentry.getPosition().add(blockposition);
+                T t0 = nextticklistentry.getData();
+
+                this.schedule(new NextTickListEntry<>(blockposition1, t0, nextticklistentry.getTargetTick(), nextticklistentry.getPriority()));
+            }
+        }
+        // end copy from TickListServer
+    }
+
+    @Override
+    public List<NextTickListEntry<T>> getEntriesInChunk(ChunkCoordIntPair chunkPos, boolean removeReturned, boolean excludeTicked) {
+        TickThread.softEnsureTickThread("async tick list get");
+        // Vanilla DOES get the entries 2 blocks out of the chunk too, but that doesn't matter since we ignore chunks
+        // not at ticking status, and ticking status requires neighbours loaded
+        // so with this method we will reduce scheduler churning
+        final int matchOne = (STATE_SCHEDULED | STATE_PENDING_TICK) | (excludeTicked ? 0 : (STATE_TICKING | STATE_TICKED));
+
+        final ObjectRBTreeSet<NextTickListEntry<T>> entries = this.entriesByChunk.get(Util.getCoordinateKey(chunkPos));
+
+        if (entries == null) {
+            return Collections.emptyList();
+        }
+
+        final List<NextTickListEntry<T>> ret = new ArrayList<>(entries.size());
+
+        for (NextTickListEntry<T> entry : entries) {
+            if ((entry.tickState & matchOne) == 0) {
+                continue;
+            }
+            ret.add(entry);
+            if (removeReturned) {
+                // TODO for long scheduled stuff we might want to kill the entry earlier.
+                entry.tickState = STATE_CANCELLED_TICK;
+            }
+        }
+
+        return ret;
+    }
+
+    @Override
+    public NBTTagList serialize(ChunkCoordIntPair chunkcoordintpair) {
+        TickThread.softEnsureTickThread("async tick list serialize");
+        // start copy from TickListServer  // TODO check on update
+        List<NextTickListEntry<T>> list = this.getEntriesInChunk(chunkcoordintpair, false, true);
+
+        return TickListServer.serialize(this.getMinecraftKeyFrom, list, this.world.getTime());
+        // end copy from TickListServer
+    }
+
+    @Override
+    public int getTotalScheduledEntries() {
+        TickThread.softEnsureTickThread("async tick list get size");
+        // good thing this is only used in debug reports // TODO check on update
+        int ret = 0;
+
+        for (NextTickListEntry<T> entry : this.longScheduled) {
+            if (entry.tickState == STATE_SCHEDULED) {
+                ++ret;
+            }
+        }
+
+        for (Iterator<Long2ObjectMap.Entry<ArrayList<NextTickListEntry<T>>>> iterator = this.pendingChunkTickLoad.long2ObjectEntrySet().iterator(); iterator.hasNext();) {
+            ArrayList<NextTickListEntry<T>> list = iterator.next().getValue();
+
+            for (NextTickListEntry<T> entry : list) {
+                if (entry.tickState == STATE_SCHEDULED) {
+                    ++ret;
+                }
+            }
+        }
+
+        for (TickListServerInterval<T> interval : this.shortScheduled) {
+            for (Iterable<NextTickListEntry<T>> set : interval.byPriority) {
+                for (NextTickListEntry<T> entry : set) {
+                    if (entry.tickState == STATE_SCHEDULED) {
+                        ++ret;
+                    }
+                }
+            }
+        }
+
+        return ret;
+    }
+}
diff --git a/src/main/java/com/tuinity/tuinity/util/set/LinkedSortedSet.java b/src/main/java/com/tuinity/tuinity/util/set/LinkedSortedSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..c726ef3c2b00c4bb2214ba6daea08e340042000d
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/set/LinkedSortedSet.java
@@ -0,0 +1,142 @@
+package com.tuinity.tuinity.util.set;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+public final class LinkedSortedSet<E> implements Iterable<E> {
+
+    public final Comparator<? super E> comparator;
+
+    protected Link<E> head;
+    protected Link<E> tail;
+
+    public LinkedSortedSet() {
+        this((Comparator)Comparator.naturalOrder());
+    }
+
+    public LinkedSortedSet(final Comparator<? super E> comparator) {
+        this.comparator = comparator;
+    }
+
+    public void clear() {
+        this.head = this.tail = null;
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return new Iterator<E>() {
+
+            Link<E> next = LinkedSortedSet.this.head;
+
+            @Override
+            public boolean hasNext() {
+                return this.next != null;
+            }
+
+            @Override
+            public E next() {
+                final Link<E> next = this.next;
+                if (next == null) {
+                    throw new NoSuchElementException();
+                }
+                this.next = next.next;
+                return next.element;
+            }
+        };
+    }
+
+    public boolean addLast(final E element) {
+        final Comparator<? super E> comparator = this.comparator;
+
+        Link<E> curr = this.tail;
+        if (curr != null) {
+            int compare;
+
+            while ((compare = comparator.compare(element, curr.element)) < 0) {
+                Link<E> prev = curr;
+                curr = curr.prev;
+                if (curr != null) {
+                    continue;
+                }
+                this.head = prev.prev = new Link<>(element, null, prev);
+                return true;
+            }
+
+            if (compare != 0) {
+                // insert after curr
+                final Link<E> next = curr.next;
+                final Link<E> insert = new Link<>(element, curr, next);
+                curr.next = insert;
+
+                if (next == null) {
+                    this.tail = insert;
+                } else {
+                    next.prev = insert;
+                }
+                return true;
+            }
+
+            return false;
+        } else {
+            this.head = this.tail = new Link<>(element);
+            return true;
+        }
+    }
+
+    public boolean addFirst(final E element) {
+        final Comparator<? super E> comparator = this.comparator;
+
+        Link<E> curr = this.head;
+        if (curr != null) {
+            int compare;
+
+            while ((compare = comparator.compare(element, curr.element)) > 0) {
+                Link<E> prev = curr;
+                curr = curr.next;
+                if (curr != null) {
+                    continue;
+                }
+                this.tail = prev.next = new Link<>(element, prev, null);
+                return true;
+            }
+
+            if (compare != 0) {
+                // insert before curr
+                final Link<E> prev = curr.prev;
+                final Link<E> insert = new Link<>(element, prev, curr);
+                curr.prev = insert;
+
+                if (prev == null) {
+                    this.head = insert;
+                } else {
+                    prev.next = insert;
+                }
+                return true;
+            }
+
+            return false;
+        } else {
+            this.head = this.tail = new Link<>(element);
+            return true;
+        }
+    }
+
+    protected static final class Link<E> {
+        public E element;
+        public Link<E> prev;
+        public Link<E> next;
+
+        public Link() {}
+
+        public Link(final E element) {
+            this.element = element;
+        }
+
+        public Link(final E element, final Link<E> prev, final Link<E> next) {
+            this.element = element;
+            this.prev = prev;
+            this.next = next;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index e650a2e48d714609accf1de5e6ca17c7a136d68e..83c5c83292546d76e249b40d24f706c6323ddb3e 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -125,6 +125,7 @@ public class BlockPosition extends BaseBlockPosition implements MinecraftSeriali
         return i == 0 && j == 0 && k == 0 ? this : new BlockPosition(this.getX() + i, this.getY() + j, this.getZ() + k);
     }
 
+    public final BlockPosition add(BaseBlockPosition baseblockposition) { return this.a(baseblockposition); } // Tuinity - OBFHELPER
     public BlockPosition a(BaseBlockPosition baseblockposition) {
         return this.b(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
     }
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 745339808e6581f442cb8d0a65875463eb76d4e8..509f61cae0959b0b766fe26573498b24ca2070b7 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -119,6 +119,12 @@ public class ChunkProviderServer extends IChunkProvider {
     }
     // Paper
 
+    // Tuinity start - rewrite ticklistserver
+    public final boolean isTickingReadyMainThread(BlockPosition pos) {
+        PlayerChunk chunk = this.playerChunkMap.chunkMap.getUpdating(com.tuinity.tuinity.util.Util.getCoordinateKey(pos));
+        return chunk != null && chunk.isTickingReady();
+    }
+    // Tuinity end - rewrite ticklistserver
 
     public ChunkProviderServer(WorldServer worldserver, File file, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, ChunkGenerator<?> chunkgenerator, int i, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier) {
         this.world = worldserver;
@@ -529,8 +535,8 @@ public class ChunkProviderServer extends IChunkProvider {
         // Tuinity end - optimize is ticking ready type functions
     }
 
-    @Override
-    public boolean a(BlockPosition blockposition) {
+    public final boolean isTickingReady(final BlockPosition pos) { return this.a(pos); } // Tuinity - OBFHELPER
+    @Override public boolean a(BlockPosition blockposition) { // Tuinity - OBFHELPER
         // Tuinity start - optimize is ticking ready type functions
         // is ticking ready
         PlayerChunk playerChunk = this.getChunk(com.tuinity.tuinity.util.Util.getCoordinateKey(blockposition));
diff --git a/src/main/java/net/minecraft/server/NextTickListEntry.java b/src/main/java/net/minecraft/server/NextTickListEntry.java
index 33cfeabdee03195a294f303f28044a313cb1c4ed..11a4bb882e73df0ead6d9c5f67ea2f1a1e6d7c35 100644
--- a/src/main/java/net/minecraft/server/NextTickListEntry.java
+++ b/src/main/java/net/minecraft/server/NextTickListEntry.java
@@ -5,11 +5,13 @@ import java.util.Comparator;
 public class NextTickListEntry<T> {
 
     private static final java.util.concurrent.atomic.AtomicLong COUNTER = new java.util.concurrent.atomic.AtomicLong(); // Paper - async chunk loading
-    private final T e;
-    public final BlockPosition a;
-    public final long b;
-    public final TickListPriority c;
-    private final long f;
+    private final T e; public final T getData() { return this.e; } // Tuinity - OBFHELPER
+    public final BlockPosition a; public final BlockPosition getPosition() { return this.a; } // Tuinity - OBFHELPER
+    public final long b; public final long getTargetTick() { return this.b; } // Tuinity - OBFHELPER
+    public final TickListPriority c; public final TickListPriority getPriority() { return this.c; } // Tuinity - OBFHELPER
+    private final long f; public final long getId() { return this.f; } // Tuinity - OBFHELPER
+    private final int hash; // Tuinity
+    public int tickState; // Tuinity
 
     public NextTickListEntry(BlockPosition blockposition, T t0) {
         this(blockposition, t0, 0L, TickListPriority.NORMAL);
@@ -21,6 +23,7 @@ public class NextTickListEntry<T> {
         this.e = t0;
         this.b = i;
         this.c = ticklistpriority;
+        this.hash = this.computeHash(); // Tuinity
     }
 
     public boolean equals(Object object) {
@@ -33,19 +36,31 @@ public class NextTickListEntry<T> {
         }
     }
 
+    // Tuinity start - optimize hashcode
+    @Override
     public int hashCode() {
+        return this.hash;
+    }
+    public final int computeHash() {
+        // Tuinity end - optimize hashcode
         return this.a.hashCode();
     }
 
-    public static <T> Comparator<Object> a() { // Paper - decompile fix
-        return Comparator.comparingLong((nextticklistentry) -> {
-            return ((NextTickListEntry<T>) nextticklistentry).b; // Paper - decompile fix
-        }).thenComparing((nextticklistentry) -> {
-            return ((NextTickListEntry<T>) nextticklistentry).c; // Paper - decompile fix
-        }).thenComparingLong((nextticklistentry) -> {
-            return ((NextTickListEntry<T>) nextticklistentry).f; // Paper - decompile fix
-        });
+    // Tuinity start - let's not use more functional code for no reason.
+    public static <T> Comparator<Object> comparator() { return NextTickListEntry.a(); } // Tuinity - OBFHELPER
+    public static <T> Comparator<Object> a() {
+        return (Comparator)(Comparator<NextTickListEntry>)(NextTickListEntry nextticklistentry, NextTickListEntry nextticklistentry1) -> {
+            int i = Long.compare(nextticklistentry.getTargetTick(), nextticklistentry1.getTargetTick());
+
+            if (i != 0) {
+                return i;
+            } else {
+                i = nextticklistentry.getPriority().compareTo(nextticklistentry1.getPriority());
+                return i != 0 ? i : Long.compare(nextticklistentry.getId(), nextticklistentry1.getId());
+            }
+        };
     }
+    // Tuinity end - let's not use more functional code for no reason.
 
     public String toString() {
         return this.e + ": " + this.a + ", " + this.b + ", " + this.c + ", " + this.f;
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 5cad0e4acc0f94d00bfd2ad62054ab3dd5728de2..f1d03cea07c51c6670c2ae932cfb98542247a51b 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -511,7 +511,7 @@ public class PlayerChunk {
                     Chunk tickingChunk = either.left().get();
                     PlayerChunk.this.isTickingReady = true;
 
-
+                    PlayerChunk.this.chunkMap.world.onChunkSetTicking(PlayerChunk.this.location.x, PlayerChunk.this.location.z); // Tuinity - rewrite ticklistserver
 
 
                 }
diff --git a/src/main/java/net/minecraft/server/StructureBoundingBox.java b/src/main/java/net/minecraft/server/StructureBoundingBox.java
index dbb565e74d211ef35d5d40b3d024e2f07cef9031..118762778c7d172098632e9de13556cf0a65f33c 100644
--- a/src/main/java/net/minecraft/server/StructureBoundingBox.java
+++ b/src/main/java/net/minecraft/server/StructureBoundingBox.java
@@ -4,12 +4,12 @@ import com.google.common.base.MoreObjects;
 
 public class StructureBoundingBox {
 
-    public int a;
-    public int b;
-    public int c;
-    public int d;
-    public int e;
-    public int f;
+    public int a; public final int getMinX() { return this.a; } // Tuinity - OBFHELPER
+    public int b; public final int getMinY() { return this.b; } // Tuinity - OBFHELPER
+    public int c; public final int getMinZ() { return this.c; } // Tuinity - OBFHELPER
+    public int d; public final int getMaxX() { return this.d; } // Tuinity - OBFHELPER
+    public int e; public final int getMaxY() { return this.e; } // Tuinity - OBFHELPER
+    public int f; public final int getMaxZ() { return this.f; } // Tuinity - OBFHELPER
 
     public StructureBoundingBox() {}
 
@@ -84,6 +84,7 @@ public class StructureBoundingBox {
         this.e = 512;
     }
 
+    public final boolean intersects(StructureBoundingBox boundingBox) { return this.b(boundingBox); } // Tuinity - OBFHELPER
     public boolean b(StructureBoundingBox structureboundingbox) {
         return this.d >= structureboundingbox.a && this.a <= structureboundingbox.d && this.f >= structureboundingbox.c && this.c <= structureboundingbox.f && this.e >= structureboundingbox.b && this.b <= structureboundingbox.e;
     }
@@ -114,6 +115,7 @@ public class StructureBoundingBox {
         return new StructureBoundingBox(this.a + i, this.b + j, this.c + k, this.d + i, this.e + j, this.f + k);
     }
 
+    public final boolean hasPoint(BaseBlockPosition baseblockposition) { return this.b(baseblockposition); } // Tuinity - OBFHELPER
     public boolean b(BaseBlockPosition baseblockposition) {
         return baseblockposition.getX() >= this.a && baseblockposition.getX() <= this.d && baseblockposition.getZ() >= this.c && baseblockposition.getZ() <= this.f && baseblockposition.getY() >= this.b && baseblockposition.getY() <= this.e;
     }
diff --git a/src/main/java/net/minecraft/server/TickListServer.java b/src/main/java/net/minecraft/server/TickListServer.java
index f533860bbed19ff2915c90186c259b466f41ce90..a54d36d90be030179cedc13335891cba7e8a6845 100644
--- a/src/main/java/net/minecraft/server/TickListServer.java
+++ b/src/main/java/net/minecraft/server/TickListServer.java
@@ -42,6 +42,11 @@ public class TickListServer<T> implements TickList<T> {
     // Paper end
 
     public void b() {
+        // Tuinity start - allow overriding
+        this.tick();
+    }
+    public void tick() {
+        // Tuinity end
         int i = this.nextTickList.size();
 
         if (false) { // CraftBukkit
@@ -109,15 +114,30 @@ public class TickListServer<T> implements TickList<T> {
 
     @Override
     public boolean b(BlockPosition blockposition, T t0) {
+        // Tuinity start - allow overriding
+        return this.isPendingTickThisTick(blockposition, t0);
+    }
+    public boolean isPendingTickThisTick(BlockPosition blockposition, T t0) {
+        // Tuinity end
         return this.g.contains(new NextTickListEntry<>(blockposition, t0));
     }
 
     @Override
     public void a(Stream<NextTickListEntry<T>> stream) {
+        // Tuinity start - allow overriding
+        this.scheduleAll(stream);
+    }
+    public void scheduleAll(Stream<NextTickListEntry<T>> stream) {
+        // Tuinity end
         stream.forEach(this::a);
     }
 
     public List<NextTickListEntry<T>> a(ChunkCoordIntPair chunkcoordintpair, boolean flag, boolean flag1) {
+        // Tuinity start - allow overriding
+        return this.getEntriesInChunk(chunkcoordintpair, flag, flag1);
+    }
+    public List<NextTickListEntry<T>> getEntriesInChunk(ChunkCoordIntPair chunkcoordintpair, boolean flag, boolean flag1) {
+        // Tuinity end
         int i = (chunkcoordintpair.x << 4) - 2;
         int j = i + 16 + 2;
         int k = (chunkcoordintpair.z << 4) - 2;
@@ -127,6 +147,11 @@ public class TickListServer<T> implements TickList<T> {
     }
 
     public List<NextTickListEntry<T>> a(StructureBoundingBox structureboundingbox, boolean flag, boolean flag1) {
+        // Tuinity start - allow overriding
+        return this.getEntriesInBoundingBox(structureboundingbox, flag, flag1);
+    }
+    public List<NextTickListEntry<T>> getEntriesInBoundingBox(StructureBoundingBox structureboundingbox, boolean flag, boolean flag1) {
+        // Tuinity end
         List<NextTickListEntry<T>> list = this.a((List) null, this.nextTickList, structureboundingbox, flag);
 
         if (flag && list != null) {
@@ -166,6 +191,11 @@ public class TickListServer<T> implements TickList<T> {
     }
 
     public void a(StructureBoundingBox structureboundingbox, BlockPosition blockposition) {
+        // Tuinity start - allow overriding
+        this.copy(structureboundingbox, blockposition);
+    }
+    public void copy(StructureBoundingBox structureboundingbox, BlockPosition blockposition) {
+        // Tuinity end
         List<NextTickListEntry<T>> list = this.a(structureboundingbox, false, false);
         Iterator iterator = list.iterator();
 
@@ -183,11 +213,17 @@ public class TickListServer<T> implements TickList<T> {
     }
 
     public NBTTagList a(ChunkCoordIntPair chunkcoordintpair) {
+        // Tuinity start - allow overriding
+        return this.serialize(chunkcoordintpair);
+    }
+    public NBTTagList serialize(ChunkCoordIntPair chunkcoordintpair) {
+        // Tuinity end
         List<NextTickListEntry<T>> list = this.a(chunkcoordintpair, false, true);
 
         return a(this.b, list, this.f.getTime());
     }
 
+    public static <T> NBTTagList serialize(Function<T, MinecraftKey> function, Iterable<NextTickListEntry<T>> iterable, long i) { return TickListServer.a(function, iterable, i); } // Tuinity - OBFHELPER
     public static <T> NBTTagList a(Function<T, MinecraftKey> function, Iterable<NextTickListEntry<T>> iterable, long i) {
         NBTTagList nbttaglist = new NBTTagList();
         Iterator iterator = iterable.iterator();
@@ -210,11 +246,21 @@ public class TickListServer<T> implements TickList<T> {
 
     @Override
     public boolean a(BlockPosition blockposition, T t0) {
+        // Tuinity start - allow overriding
+        return this.isScheduledForTick(blockposition, t0);
+    }
+    public boolean isScheduledForTick(BlockPosition blockposition, T t0) {
+        // Tuinity end
         return this.nextTickListHash.contains(new NextTickListEntry<>(blockposition, t0));
     }
 
     @Override
     public void a(BlockPosition blockposition, T t0, int i, TickListPriority ticklistpriority) {
+        // Tuinity start - allow overriding
+        this.schedule(blockposition, t0, i, ticklistpriority);
+    }
+    public void schedule(BlockPosition blockposition, T t0, int i, TickListPriority ticklistpriority) {
+        // Tuinity end
         if (!this.a.test(t0)) {
             this.a(new NextTickListEntry<>(blockposition, t0, (long) i + this.f.getTime(), ticklistpriority));
         }
@@ -230,6 +276,11 @@ public class TickListServer<T> implements TickList<T> {
     }
 
     public int a() {
+        // Tuinity start - allow overriding
+        return this.getTotalScheduledEntries();
+    }
+    public int getTotalScheduledEntries() {
+        // Tuinity end
         return this.nextTickListHash.size();
     }
 }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index ca7c2c892d63aa5ae1660a3328898e8e515abc48..5919c6341abb24e9aed8623c10b04695fcff6582 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -190,6 +190,11 @@ public class WorldServer extends World {
             this.loadedEntities.remove(entities[i]);
         }
     }
+
+    void onChunkSetTicking(int chunkX, int chunkZ) {
+        ((com.tuinity.tuinity.server.TuinityTickList)this.nextTickListBlock).onChunkSetTicking(chunkX, chunkZ);
+        ((com.tuinity.tuinity.server.TuinityTickList)this.nextTickListFluid).onChunkSetTicking(chunkX, chunkZ);
+    }
     // Tuinity end
 
     // Add env and gen to constructor
@@ -212,10 +217,10 @@ public class WorldServer extends World {
         this.pvpMode = minecraftserver.getPVP();
         worlddata.world = this;
         // CraftBukkit end
-        this.nextTickListBlock = new TickListServer<>(this, (block) -> {
+        this.nextTickListBlock = new com.tuinity.tuinity.server.TuinityTickList<>(this, (block) -> { // Tuinity - optimise TickListServer
             return block == null || block.getBlockData().isAir();
         }, IRegistry.BLOCK::getKey, IRegistry.BLOCK::get, this::b, "Blocks"); // Paper - Timings
-        this.nextTickListFluid = new TickListServer<>(this, (fluidtype) -> {
+        this.nextTickListFluid = new com.tuinity.tuinity.server.TuinityTickList<>(this, (fluidtype) -> { // Tuinity - optimise TickListServer
             return fluidtype == null || fluidtype == FluidTypes.EMPTY;
         }, IRegistry.FLUID::getKey, IRegistry.FLUID::get, this::a, "Fluids"); // Paper - Timings
         this.navigators = Sets.newHashSet();
