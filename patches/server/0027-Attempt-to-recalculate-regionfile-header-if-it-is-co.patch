From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sun, 2 Feb 2020 02:25:10 -0800
Subject: [PATCH] Attempt to recalculate regionfile header if it is corrupt

Instead of trying to relocate the chunk, which is seems to never
be the correct choice, so we end up duplicating or swapping chunks,
we instead drop the current regionfile header and recalculate -
hoping that at least then we don't swap chunks, and maybe recover
them all.

diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 4349d22cc8390628e3adee9896dd33cc2cca4d99..d529b795c5434328a81c015558708b4994203099 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -23,6 +23,14 @@ public class ChunkRegionLoader {
 
     private static final Logger LOGGER = LogManager.getLogger();
 
+    // Tuinity start
+    // TODO: Check on update
+    public static long getLastWorldSaveTime(NBTTagCompound chunkData) {
+        NBTTagCompound levelData = chunkData.getCompound("Level");
+        return levelData.getLong("LastUpdate");
+    }
+    // Tuinity end
+
     // Paper start - guard against serializing mismatching coordinates
     // TODO Note: This needs to be re-checked each update
     public static ChunkCoordIntPair getChunkCoordinate(NBTTagCompound chunkData) {
@@ -344,10 +352,10 @@ public class ChunkRegionLoader {
         NBTTagCompound nbttagcompound1 = new NBTTagCompound();
 
         nbttagcompound.setInt("DataVersion", SharedConstants.getGameVersion().getWorldVersion());
-        nbttagcompound.set("Level", nbttagcompound1);
+        nbttagcompound.set("Level", nbttagcompound1); // Tuinity - diff on change
         nbttagcompound1.setInt("xPos", chunkcoordintpair.x);
         nbttagcompound1.setInt("zPos", chunkcoordintpair.z);
-        nbttagcompound1.setLong("LastUpdate", asyncsavedata != null ? asyncsavedata.worldTime : worldserver.getTime()); // Paper - async chunk unloading
+        nbttagcompound1.setLong("LastUpdate", asyncsavedata != null ? asyncsavedata.worldTime : worldserver.getTime()); // Paper - async chunk unloading // Tuinity - diff on change
         nbttagcompound1.setLong("InhabitedTime", ichunkaccess.getInhabitedTime());
         nbttagcompound1.setString("Status", ichunkaccess.getChunkStatus().d());
         ChunkConverter chunkconverter = ichunkaccess.p();
diff --git a/src/main/java/net/minecraft/server/RegionFile.java b/src/main/java/net/minecraft/server/RegionFile.java
index df728e2c0a2bf660a91e0bd6342c4b4b1471dcb7..132cbe4b95f4d0aa88a4cddd9a626da4eb964c33 100644
--- a/src/main/java/net/minecraft/server/RegionFile.java
+++ b/src/main/java/net/minecraft/server/RegionFile.java
@@ -28,14 +28,254 @@ public class RegionFile implements AutoCloseable {
     private static final Logger LOGGER = LogManager.getLogger();
     private static final ByteBuffer b = ByteBuffer.allocateDirect(1);
     private final FileChannel dataFile;
-    private final java.nio.file.Path d;
-    private final RegionFileCompression e;
+    private final java.nio.file.Path d; private final java.nio.file.Path getContainingDataFolder() { return this.d; } // Tuinity - OBFHELPER
+    private final RegionFileCompression e; private final RegionFileCompression getRegionFileCompression() { return this.e; } // Tuinity - OBFHELPER
     private final ByteBuffer f;
-    private final IntBuffer g;
-    private final IntBuffer h;
+    private final IntBuffer g; private final IntBuffer getOffsets() { return this.g; } // Tuinity - OBFHELPER
+    private final IntBuffer h; private final IntBuffer getTimestamps() { return this.h; } // Tuinity - OBFHELPER
     private final RegionFileBitSet freeSectors;
     public final File file;
 
+    // Tuinity start - try to recover from RegionFile header corruption
+    private static long roundToSectors(long bytes) {
+        long sectors = bytes >>> 12; // 4096 = 2^12
+        long remainingBytes = bytes & 4095;
+        long sign = -remainingBytes; // sign is 1 if nonzero
+        return sectors + (sign >>> 63);
+    }
+
+    private static final NBTTagCompound OVERSIZED_COMPOUND = new NBTTagCompound();
+
+    private NBTTagCompound attemptRead(long sector, long fileLength) throws IOException {
+        try {
+            int totalLength = this.getLength(sector);
+
+            if (totalLength < 0) {
+                return null;
+            }
+
+            long offset = sector * 4096L + 4L; // offset for chunk data
+
+            if ((offset + totalLength) > fileLength) {
+                return null;
+            }
+
+            ByteBuffer chunkData = ByteBuffer.allocate(totalLength);
+            if (totalLength != this.dataFile.read(chunkData, totalLength)) {
+                return null;
+            }
+
+            byte compressionType = chunkData.get(0);
+            if (compressionType < 0) { // compressionType & 128 != 0
+                // oversized chunk
+                return OVERSIZED_COMPOUND;
+            }
+
+            InputStream input = this.getRegionFileCompression().wrap(new BufferedInputStream(new ByteArrayInputStream(chunkData.array(), 0, totalLength)));
+
+            return NBTCompressedStreamTools.readNBT(new DataInputStream(input));
+        } catch (Exception ex) {
+            return null;
+        }
+    }
+
+    private int getLength(long sector) throws IOException {
+        ByteBuffer length = ByteBuffer.allocate(4);
+        if (4 != this.dataFile.read(length, sector * 4096L)) {
+            return -1;
+        }
+
+        return length.getInt(0);
+    }
+
+    // note: only call for CHUNK regionfiles
+    void recalculateHeader() throws IOException {
+        if (!this.canRecalcHeader) {
+            return;
+        }
+        synchronized (this) {
+            MinecraftServer.LOGGER.warn("Corrupt regionfile header detected! Attempting to re-calculate header offsets for regionfile " + this.file.getAbsolutePath(), new Throwable());
+
+            // try to backup file so maybe it could be sent to us for further investigation
+
+            File backup = new File(this.file.getParent(), this.file.getName() + "." + new java.util.Random().nextLong() + ".backup");
+            try {
+                MinecraftServer.LOGGER.warn("Backing up to" + backup.getAbsolutePath());
+                java.nio.file.Files.copy(this.file.toPath(), backup.toPath());
+                MinecraftServer.LOGGER.warn("Backed up the regionfile");
+            } catch (IOException ex) {
+                MinecraftServer.LOGGER.error("Failed to backup to " + backup.getAbsolutePath(), ex);
+            }
+
+            NBTTagCompound[] compounds = new NBTTagCompound[32 * 32];
+            int[] rawLengths = new int[32 * 32]; // length of chunk data including 4 byte length field, bytes
+            int[] sectorOffsets = new int[32 * 32]; // in sectors
+
+            long fileLength = this.dataFile.size();
+            long totalSectors = roundToSectors(fileLength);
+
+            // search the regionfile from start to finish for the most up-to-date chunk data
+
+            for (long i = 2, maxSector = Math.max((long)(Integer.MAX_VALUE >>> 8), totalSectors); i < maxSector; ++i) { // first two sectors are header, skip
+                NBTTagCompound compound = this.attemptRead(i, fileLength);
+                if (compound == null || compound == OVERSIZED_COMPOUND) {
+                    continue;
+                }
+
+                ChunkCoordIntPair chunkPos = ChunkRegionLoader.getChunkCoordinate(compound);
+                int location = (chunkPos.x & 31) | ((chunkPos.z & 31) << 5);
+
+                NBTTagCompound otherCompound = compounds[location];
+
+                if (otherCompound != null && ChunkRegionLoader.getLastWorldSaveTime(otherCompound) > ChunkRegionLoader.getLastWorldSaveTime(compound)) {
+                    continue; // don't overwrite newer data.
+                }
+
+                compounds[location] = compound;
+                rawLengths[location] = this.getLength(i) + 4;
+                sectorOffsets[location] = (int)i;
+            }
+
+            // find any mojang oversized data, this will override any local data we find in the regionfile
+            // forge style oversized data is already handled by the local search, and aikar data we just hope
+            // we get it right as aikar data has no identifiers we could use to try and find its corresponding
+            // local data compound
+
+            java.nio.file.Path containingFolder = this.getContainingDataFolder();
+            File[] regionFiles = containingFolder.toFile().listFiles();
+            boolean[] oversized = new boolean[32 * 32];
+
+            if (regionFiles != null) {
+                ChunkCoordIntPair ourLowerLeftPosition = RegionFileCache.getRegionFileCoordinates(this.file);
+
+                if (ourLowerLeftPosition == null) {
+                    MinecraftServer.LOGGER.error("Unable to get chunk location of regionfile " + this.file.getAbsolutePath() + ", cannot recover oversized chunks");
+                } else {
+                    int lowerXBound = ourLowerLeftPosition.x; // inclusive
+                    int lowerZBound = ourLowerLeftPosition.z; // inclusive
+                    int upperXBound = lowerXBound + 32 - 1; // inclusive
+                    int upperZBound = lowerZBound + 32 - 1; // inclusive
+
+                    for (File regionFile : regionFiles) {
+                        ChunkCoordIntPair oversizedCoords = getOversizedChunkPair(regionFile);
+                        if (oversizedCoords == null) {
+                            continue;
+                        }
+
+                        if ((oversizedCoords.x < lowerXBound || oversizedCoords.x > upperXBound) || (oversizedCoords.z < lowerZBound || oversizedCoords.z > upperZBound)) {
+                            continue; // not in our regionfile
+                        }
+
+                        oversized[(oversizedCoords.x & 31) | ((oversizedCoords.z & 31) << 5)] = true;
+                    }
+                }
+            }
+
+            // now we need to calculate a new offset header
+
+            int[] calculatedOffsets = new int[32 * 32];
+            RegionFileBitSet newSectorAllocations = new RegionFileBitSet();
+
+            // allocate sectors for normal chunks
+
+            for (int chunkX = 0; chunkX < 32; ++chunkX) {
+                for (int chunkZ = 0; chunkZ < 32; ++chunkZ) {
+                    int location = chunkX | (chunkZ << 5);
+
+                    if (oversized[location]) {
+                        continue;
+                    }
+
+                    int rawLength = rawLengths[location]; // bytes
+                    int sectorOffset = sectorOffsets[location]; // sectors
+                    int sectorLength = (int)roundToSectors(rawLength);
+
+                    if (newSectorAllocations.tryAllocate(sectorOffset, sectorLength)) {
+                        calculatedOffsets[location] = sectorOffset << 8 | (sectorLength > 255 ? 255 : sectorLength); // support forge style oversized
+                    } else {
+                        MinecraftServer.LOGGER.error("Failed to allocate space for local chunk (overlapping data??) at (" + chunkX + "," + chunkZ + ") in regionfile " + this.file.getAbsolutePath() + " will be lost");
+                    }
+                }
+            }
+
+            // allocate sectors for oversized chunks
+
+            for (int chunkX = 0; chunkX < 32; ++chunkX) {
+                for (int chunkZ = 0; chunkZ < 32; ++chunkZ) {
+                    int location = chunkX | (chunkZ << 5);
+
+                    if (!oversized[location]) {
+                        continue;
+                    }
+
+                    int sectorOffset = newSectorAllocations.allocateNewSpace(1);
+                    int sectorLength = 1;
+
+                    try {
+                        this.dataFile.write(this.getOversizedChunkHolderData(), sectorOffset * 4096);
+                        // only allocate in the new offsets if the write succeeds
+                        calculatedOffsets[location] = sectorOffset << 8 | (sectorLength > 255 ? 255 : sectorLength); // support forge style oversized
+                    } catch (IOException ex) {
+                        newSectorAllocations.free(sectorOffset, sectorLength);
+                        MinecraftServer.LOGGER.error("Failed to write new oversized chunk data holder, local chunk at (" + chunkX + "," + chunkZ + ") in regionfile " + this.file.getAbsolutePath() + " will be lost");
+                    }
+                }
+            }
+
+            // replace time
+
+            this.freeSectors.copyFrom(newSectorAllocations);
+
+            // before we overwrite the old sectors, print a summary of the chunks that got changed.
+
+            MinecraftServer.LOGGER.info("Starting summary of changes for regionfile " + this.file.getAbsolutePath());
+
+            for (int chunkX = 0; chunkX < 32; ++chunkX) {
+                for (int chunkZ = 0; chunkZ < 32; ++chunkZ) {
+                    int location = chunkX | (chunkZ << 5);
+
+                    int oldOffset = this.getOffsets().get(location);
+                    int newOffset = calculatedOffsets[location];
+
+                    if (oldOffset == newOffset) {
+                        continue;
+                    }
+
+                    this.getOffsets().put(location, newOffset); // overwrite incorrect offset
+
+                    if (oldOffset == 0) {
+                        // found lost data
+                        MinecraftServer.LOGGER.info("Found missing data for local chunk (" + chunkX + "," + chunkZ + ") in regionfile " + this.file.getAbsolutePath());
+                    } else if (newOffset == 0) {
+                        MinecraftServer.LOGGER.info("Data for local chunk (" + chunkX + "," + chunkZ + ") could not be recovered in regionfile " + this.file.getAbsolutePath() + ", it will be regenerated");
+                        // we're NOT removing aikar/mojang oversized data because we did not back that up.
+                    } else {
+                        MinecraftServer.LOGGER.info("Local chunk (" + chunkX + "," + chunkZ + ") changed to point to newer data or correct chunk in regionfile " + this.file.getAbsolutePath());
+                    }
+                }
+            }
+
+            MinecraftServer.LOGGER.info("End of change summary for regionfile " + this.file.getAbsolutePath());
+
+            // simply destroy the timestamp header, it's not used
+
+            for (int i = 0; i < 32 * 32; ++i) {
+                this.getTimestamps().put(i, calculatedOffsets[i] != 0 ? (int)System.currentTimeMillis() : 0); // write a valid timestamp for valid chunks, I do not want to find out whatever dumb program actually checks this
+            }
+
+            // write new header
+            try {
+                this.flushHeader();
+                this.dataFile.force(true); // try to ensure it goes through...
+            } catch (IOException ex) {
+                MinecraftServer.LOGGER.error("Failed to write new header to disk for regionfile " + this.file.getAbsolutePath(), ex);
+            }
+        }
+    }
+
+    final boolean canRecalcHeader; // final forces compile fail on new constructor
+    // Tuinity end
+
     public final java.util.concurrent.locks.ReentrantLock fileLock = new java.util.concurrent.locks.ReentrantLock(true); // Paper
 
     // Paper start - Cache chunk status
@@ -63,10 +303,21 @@ public class RegionFile implements AutoCloseable {
     // Paper end
 
     public RegionFile(File file, File file1) throws IOException {
-        this(file.toPath(), file1.toPath(), RegionFileCompression.b);
+        // Tuinity start - add header recalculation boolean
+        this(file, file1, false);
+    }
+    public RegionFile(File file, File file1, boolean canRecalcHeader) throws IOException {
+        this(file.toPath(), file1.toPath(), RegionFileCompression.b, canRecalcHeader);
+        // Tuinity end
     }
 
     public RegionFile(java.nio.file.Path java_nio_file_path, java.nio.file.Path java_nio_file_path1, RegionFileCompression regionfilecompression) throws IOException {
+        // Tuinity start - add header recalculation boolean
+        this(java_nio_file_path, java_nio_file_path1, regionfilecompression, false);
+    }
+    public RegionFile(java.nio.file.Path java_nio_file_path, java.nio.file.Path java_nio_file_path1, RegionFileCompression regionfilecompression, boolean canRecalcHeader) throws IOException {
+        this.canRecalcHeader = canRecalcHeader;
+        // Tuinity end
         this.file = java_nio_file_path.toFile(); // Paper
         this.f = ByteBuffer.allocateDirect(8192);
         initOversizedState();
@@ -90,6 +341,8 @@ public class RegionFile implements AutoCloseable {
                     RegionFile.LOGGER.warn("Region file {} has truncated header: {}", java_nio_file_path, i);
                 }
 
+                boolean needsHeaderRecalc = false;  // Tuinity - recalculate header on header corruption
+
                 for (int j = 0; j < 1024; ++j) {
                     int k = this.g.get(j);
 
@@ -105,20 +358,53 @@ public class RegionFile implements AutoCloseable {
                         }
                         // Spigot end
 
-                        this.freeSectors.a(l, i1);
+                        needsHeaderRecalc |= true ^ this.freeSectors.tryAllocate(l, l + i1); // Tuinity - recalculate header on header corruption
                     }
                 }
+
+                // Tuinity start - recalculate header on header corruption
+                // we move the recalc here so comparison to old header is correct when logging to console
+                if (needsHeaderRecalc) { // true if header gave us overlapping allocations
+                    this.recalculateHeader();
+                }
+                // Tuinity end
             }
 
         }
     }
 
+    private final java.nio.file.Path getOversizedChunkPath(ChunkCoordIntPair chunkcoordintpair) { return this.e(chunkcoordintpair); } // Tuinity - OBFHELPER
     private java.nio.file.Path e(ChunkCoordIntPair chunkcoordintpair) {
-        String s = "c." + chunkcoordintpair.x + "." + chunkcoordintpair.z + ".mcc";
+        String s = "c." + chunkcoordintpair.x + "." + chunkcoordintpair.z + ".mcc"; // Tuinity - diff on change
 
         return this.d.resolve(s);
     }
 
+    // Tuinity start
+    private static ChunkCoordIntPair getOversizedChunkPair(File file) {
+        String fileName = file.getName();
+
+        if (!fileName.startsWith("c.") || !fileName.endsWith(".mcc")) {
+            return null;
+        }
+
+        String[] split = fileName.split("\\.");
+
+        if (split.length != 4) {
+            return null;
+        }
+
+        try {
+            int x = Integer.parseInt(split[1]);
+            int z = Integer.parseInt(split[2]);
+
+            return new ChunkCoordIntPair(x, z);
+        } catch (NumberFormatException ex) {
+            return null;
+        }
+    }
+    // Tuinity end
+
     @Nullable public synchronized DataInputStream getReadStream(ChunkCoordIntPair chunkCoordIntPair) throws IOException { return a(chunkCoordIntPair);} // Paper - OBFHELPER
     @Nullable
     public synchronized DataInputStream a(ChunkCoordIntPair chunkcoordintpair) throws IOException {
@@ -142,6 +428,12 @@ public class RegionFile implements AutoCloseable {
             this.dataFile.read(bytebuffer, (long) (j * 4096));
             ((java.nio.Buffer) bytebuffer).flip();
             if (bytebuffer.remaining() < 5) {
+                // Tuinity start - recalculate header on regionfile corruption
+                if (this.canRecalcHeader) {
+                    this.recalculateHeader();
+                    return this.getReadStream(chunkcoordintpair);
+                }
+                // Tuinity end
                 RegionFile.LOGGER.error("Chunk {} header is truncated: expected {} but read {}", chunkcoordintpair, l, bytebuffer.remaining());
                 return null;
             } else {
@@ -150,6 +442,12 @@ public class RegionFile implements AutoCloseable {
 
                 if (i1 == 0) {
                     RegionFile.LOGGER.warn("Chunk {} is allocated, but stream is missing", chunkcoordintpair);
+                    // Tuinity start - recalculate header on regionfile corruption
+                    if (this.canRecalcHeader) {
+                        this.recalculateHeader();
+                        return this.getReadStream(chunkcoordintpair);
+                    }
+                    // Tuinity end
                     return null;
                 } else {
                     int j1 = i1 - 1;
@@ -162,9 +460,21 @@ public class RegionFile implements AutoCloseable {
                         return this.a(chunkcoordintpair, b(b0));
                     } else if (j1 > bytebuffer.remaining()) {
                         RegionFile.LOGGER.error("Chunk {} stream is truncated: expected {} but read {}", chunkcoordintpair, j1, bytebuffer.remaining());
+                        // Tuinity start - recalculate header on regionfile corruption
+                        if (this.canRecalcHeader) {
+                            this.recalculateHeader();
+                            return this.getReadStream(chunkcoordintpair);
+                        }
+                        // Tuinity end
                         return null;
                     } else if (j1 < 0) {
                         RegionFile.LOGGER.error("Declared size {} of chunk {} is negative", i1, chunkcoordintpair);
+                        // Tuinity start - recalculate header on regionfile corruption
+                        if (this.canRecalcHeader) {
+                            this.recalculateHeader();
+                            return this.getReadStream(chunkcoordintpair);
+                        }
+                        // Tuinity end
                         return null;
                     } else {
                         return this.a(chunkcoordintpair, b0, a(bytebuffer, j1));
@@ -322,6 +632,7 @@ public class RegionFile implements AutoCloseable {
 
     }
 
+    private final ByteBuffer getOversizedChunkHolderData() { return this.a(); } // Tuinity - OBFHELPER
     private ByteBuffer a() {
         ByteBuffer bytebuffer = ByteBuffer.allocate(5);
 
@@ -363,6 +674,7 @@ public class RegionFile implements AutoCloseable {
         };
     }
 
+    private final void flushHeader() throws IOException { this.b(); } // Tuinity - OBFHELPER
     private void b() throws IOException {
         ((java.nio.Buffer) this.f).position(0);
         this.dataFile.write(this.f, 0L);
diff --git a/src/main/java/net/minecraft/server/RegionFileBitSet.java b/src/main/java/net/minecraft/server/RegionFileBitSet.java
index 1ebdf73cc927405bc536dc74a5118d2a086db0e5..81908d4ecd6f01bfa31d1e688843a971a849d936 100644
--- a/src/main/java/net/minecraft/server/RegionFileBitSet.java
+++ b/src/main/java/net/minecraft/server/RegionFileBitSet.java
@@ -4,18 +4,42 @@ import java.util.BitSet;
 
 public class RegionFileBitSet {
 
-    private final BitSet a = new BitSet();
+    private final BitSet a = new BitSet(); private final BitSet getBitset() { return this.a; } // Tuinity - OBFHELPER
 
     public RegionFileBitSet() {}
 
+    public final void allocate(int from, int length) { this.a(from, length); } // Tuinity - OBFHELPER
     public void a(int i, int j) {
         this.a.set(i, i + j);
     }
 
+    public final void free(int from, int length) { this.b(from, length); } // Tuinity - OBFHELPER
     public void b(int i, int j) {
         this.a.clear(i, i + j);
     }
 
+    // Tuinity start
+    public final void copyFrom(RegionFileBitSet other) {
+        BitSet thisBitset = this.getBitset();
+        BitSet otherBitset = other.getBitset();
+
+        for (int i = 0; i < Math.max(thisBitset.size(), otherBitset.size()); ++i) {
+            thisBitset.set(i, otherBitset.get(i));
+        }
+    }
+
+    public final boolean tryAllocate(int from, int to) { // from is inclusive, to is exclusive
+        BitSet bitset = this.getBitset();
+        int firstSet = bitset.nextSetBit(from);
+        if (firstSet > 0 && firstSet < to) {
+            return false;
+        }
+        bitset.set(from, to);
+        return true;
+    }
+    // Tuinity end
+
+    public final int allocateNewSpace(final int requiredLength) { return this.a(requiredLength); } // Tuinity - OBFHELPER
     public int a(int i) {
         int j = 0;
 
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
index 0f201000f6638f54d575db2c7ae61a86555a3be2..c88ad8de0ad51d5b7a4969a92486a76ec34f52ed 100644
--- a/src/main/java/net/minecraft/server/RegionFileCache.java
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -18,6 +18,30 @@ public class RegionFileCache implements AutoCloseable { // Paper - no final
         this.b = file;
     }
 
+    // Tuinity start
+    public static ChunkCoordIntPair getRegionFileCoordinates(File file) {
+        String fileName = file.getName();
+        if (!fileName.startsWith("r.") || !fileName.endsWith(".mca")) {
+            return null;
+        }
+
+        String[] split = fileName.split("\\.");
+
+        if (split.length != 4) {
+            return null;
+        }
+
+        try {
+            int x = Integer.parseInt(split[1]);
+            int z = Integer.parseInt(split[2]);
+
+            return new ChunkCoordIntPair(x << 5, z << 5);
+        } catch (NumberFormatException ex) {
+            return null;
+        }
+    }
+    // Tuinity end
+
 
     // Paper start
     public synchronized RegionFile getRegionFileIfLoaded(ChunkCoordIntPair chunkcoordintpair) { // Paper - synchronize for async io
@@ -51,9 +75,9 @@ public class RegionFileCache implements AutoCloseable { // Paper - no final
                 this.b.mkdirs();
             }
 
-            File file = new File(this.b, "r." + chunkcoordintpair.getRegionX() + "." + chunkcoordintpair.getRegionZ() + ".mca");
+            File file = new File(this.b, "r." + chunkcoordintpair.getRegionX() + "." + chunkcoordintpair.getRegionZ() + ".mca"); // Tuinity - diff on change
             if (existingOnly && !file.exists()) return null; // CraftBukkit
-            RegionFile regionfile1 = new RegionFile(file, this.b);
+            RegionFile regionfile1 = new RegionFile(file, this.b, this instanceof IChunkLoader); // Tuinity - allow for chunk regionfiles to regen header
 
             this.cache.putAndMoveToFirst(i, regionfile1);
             // Paper start
@@ -137,6 +161,13 @@ public class RegionFileCache implements AutoCloseable { // Paper - no final
     @Nullable
     public NBTTagCompound read(ChunkCoordIntPair chunkcoordintpair) throws IOException {
         RegionFile regionfile = this.getFile(chunkcoordintpair, false, true); // CraftBukkit // Paper
+        // Tuinity start - Add regionfile parameter
+        return this.readFromRegionFile(regionfile, chunkcoordintpair);
+    }
+    private NBTTagCompound readFromRegionFile(RegionFile regionfile, ChunkCoordIntPair chunkcoordintpair) throws IOException {
+        // We add the regionfile parameter to avoid the potential deadlock (on fileLock) if we went back to obtain a regionfile
+        // if we decide to re-read
+        // Tuinity end
         try { // Paper
         DataInputStream datainputstream = regionfile.a(chunkcoordintpair);
         // Paper start
@@ -152,6 +183,16 @@ public class RegionFileCache implements AutoCloseable { // Paper - no final
         try {
             if (datainputstream != null) {
                 nbttagcompound = NBTCompressedStreamTools.a(datainputstream);
+                // Tuinity start - recover from corrupt regionfile header
+                if (this instanceof IChunkLoader) {
+                    ChunkCoordIntPair chunkPos = ChunkRegionLoader.getChunkCoordinate(nbttagcompound);
+                    if (!chunkPos.equals(chunkcoordintpair)) {
+                        regionfile.recalculateHeader();
+                        regionfile.fileLock.lock(); // otherwise we will unlock twice and only lock once.
+                        return this.readFromRegionFile(regionfile, chunkcoordintpair);
+                    }
+                }
+                // Tuinity end
                 return nbttagcompound;
             }
 
diff --git a/src/main/java/net/minecraft/server/RegionFileCompression.java b/src/main/java/net/minecraft/server/RegionFileCompression.java
index 3382d678e68e559b8d3cb9dced4fce24206cd38f..79c89f5c11b9bd645a2de0993ba0c05b62628ebb 100644
--- a/src/main/java/net/minecraft/server/RegionFileCompression.java
+++ b/src/main/java/net/minecraft/server/RegionFileCompression.java
@@ -53,6 +53,7 @@ public class RegionFileCompression {
         return (OutputStream) this.g.wrap(outputstream);
     }
 
+    public final InputStream wrap(InputStream inputstream) throws IOException { return this.a(inputstream); } // Tuinity - OBFHELPER
     public InputStream a(InputStream inputstream) throws IOException {
         return (InputStream) this.f.wrap(inputstream);
     }
diff --git a/src/main/java/net/minecraft/server/WorldUpgrader.java b/src/main/java/net/minecraft/server/WorldUpgrader.java
index 3030c347ef49da9ef4d9ba4177f09aac4a23596a..76f0f258e1debb587154ca1b49a24e592c0c878b 100644
--- a/src/main/java/net/minecraft/server/WorldUpgrader.java
+++ b/src/main/java/net/minecraft/server/WorldUpgrader.java
@@ -220,7 +220,7 @@ public class WorldUpgrader {
                     int l = Integer.parseInt(matcher.group(2)) << 5;
 
                     try {
-                        RegionFile regionfile = new RegionFile(file2, file1);
+                        RegionFile regionfile = new RegionFile(file2, file1, true); // Tuinity - allow for chunk regionfiles to regen header
                         Throwable throwable = null;
 
                         try {
