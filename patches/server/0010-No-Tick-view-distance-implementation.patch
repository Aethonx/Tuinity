From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <spottedleaf@spottedleaf.dev>
Date: Fri, 1 May 2020 16:14:17 -0700
Subject: [PATCH] No-Tick view distance implementation


diff --git a/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java b/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
index 67e9a32c2b56e0ca70ef138873b1dc9dc215e452..d7ab45a42b68fcd2c51a6497ad16704e83fb651d 100644
--- a/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
+++ b/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
@@ -235,6 +235,14 @@ public final class TuinityConfig {
             final int threads = this.getInt("tick-threads", -1);
             this.threads = threads == -1 ? TuinityConfig.tickThreads : threads;
         }*/
+
+        public int noTickViewDistance;
+        private void noTickViewDistance() {
+            if (TuinityConfig.configVersion < 2) {
+                this.set("max-pending-chunk-loads", null);
+            }
+            this.noTickViewDistance = this.getInt("no-tick-view-distance", -1);
+        }
     }
 
 }
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 0e245dd5ac01c0aff8e986d9f21c98af5abf659c..9ccb5531575980a19105ed6aaad3123bd1620b45 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -246,7 +246,51 @@ public class Chunk implements IChunkAccess {
 
     // Tuinity start
     protected void onNeighbourChange(final long bitsetBefore, final long bitsetAfter) {
+        // Tuinity start - no-tick view distance
+        ChunkProviderServer chunkProviderServer = ((WorldServer)this.world).getChunkProvider();
+        PlayerChunkMap chunkMap = chunkProviderServer.playerChunkMap;
+        // this code handles the addition of ticking tickets - the distance map handles the removal
+        if (!areNeighboursLoaded(bitsetBefore, 2) && areNeighboursLoaded(bitsetAfter, 2)) {
+            if (chunkMap.playerViewDistanceTickMap.getObjectsInRange(this.coordinateKey) != null) {
+                // now we're ready for entity ticking
+                chunkProviderServer.serverThreadQueue.execute(() -> {
+                    // double check that this condition still holds.
+                    if (Chunk.this.areNeighboursLoaded(2) && chunkMap.playerViewDistanceTickMap.getObjectsInRange(Chunk.this.coordinateKey) != null) {
+                        chunkProviderServer.addTicketAtLevel(TicketType.PLAYER, Chunk.this.loc, 31, Chunk.this.loc); // 31 -> entity ticking, TODO check on update
+                    }
+                });
+            }
+        }
+
+        // this code handles the chunk sending
+        if (!areNeighboursLoaded(bitsetBefore, 1) && areNeighboursLoaded(bitsetAfter, 1)) {
+            if (chunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(this.coordinateKey) != null) {
+                // now we're ready to send
+                chunkMap.mailboxMain.a(ChunkTaskQueueSorter.a(chunkMap.getUpdatingChunk(this.coordinateKey), (() -> { // Copied frm PlayerChunkMap
+                    // double check that this condition still holds.
+                    if (!Chunk.this.areNeighboursLoaded(1)) {
+                        return;
+                    }
+                    com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> inRange = chunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(Chunk.this.coordinateKey);
+                    if (inRange == null) {
+                        return;
+                    }
 
+                    // broadcast
+                    Object[] backingSet = inRange.getBackingSet();
+                    Packet[] chunkPackets = new Packet[2];
+                    for (int index = 0, len = backingSet.length; index < len; ++index) {
+                        Object temp = backingSet[index];
+                        if (!(temp instanceof EntityPlayer)) {
+                            continue;
+                        }
+                        EntityPlayer player = (EntityPlayer)temp;
+                        chunkMap.sendChunk(player, chunkPackets, Chunk.this);
+                    }
+                })));
+            }
+        }
+        // Tuinity end - no-tick view distance
     }
     // Tuinity end
 
@@ -1118,7 +1162,13 @@ public class Chunk implements IChunkAccess {
         this.inhabitedTime = i;
     }
 
+    // Tuinity start - no-tick view distance
+    boolean hasRanPostConversionTasks;
+    // Tuinity end - no-tick view distance
+
+    public final void runPostConversionTasks() { this.A(); } // Tuinity - OBFHELPER
     public void A() {
+        this.hasRanPostConversionTasks = true; // Tuinity - no-tick view distance
         ChunkCoordIntPair chunkcoordintpair = this.getPos();
 
         for (int i = 0; i < this.n.length; ++i) {
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 1c0692d86c8d42d83edc9a4bd6bdd11b320f90a7..69685603756434608dd3b1c46601562bfc6e8a34 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -256,7 +256,7 @@ public abstract class ChunkMapDistance {
         return s;
     }
 
-    protected void a(int i) {
+    protected void setNoTickViewDistance(int i) { // Tuinity - force abi breakage on usage change
         this.g.a(i);
     }
 
@@ -372,7 +372,7 @@ public abstract class ChunkMapDistance {
 
         private void a(long i, int j, boolean flag, boolean flag1) {
             if (flag != flag1) {
-                Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, ChunkMapDistance.b, new ChunkCoordIntPair(i));
+                Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, 33, new ChunkCoordIntPair(i)); // Tuinity - no-tick view distance
 
                 if (flag1) {
                     ChunkMapDistance.this.j.a(ChunkTaskQueueSorter.a(() -> { // CraftBukkit - decompile error
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index 2887cb14e4f9f90412cbf6f83c651e5866fb16b3..b440304615ba41aba2ea5a965af31b0adb82facf 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -579,7 +579,7 @@ public class EntityEnderDragon extends EntityInsentient implements IMonster {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                int viewDistance = ((WorldServer)this.world).getChunkProvider().playerChunkMap.getEffectiveViewDistance(); // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API // Tuinity - no-tick view distance
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
                     //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
                     // Paper end
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index eb093558476343838685061e1dbe77583a0ead4c..f656308e857b755a48644203a42fe4a589295d87 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -117,6 +117,10 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public final com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> cachedSingleHashSetTuinity;
     // Tuinity end
 
+    // Tuinity start - no-tick view distance
+    boolean needsChunkCenterUpdate;
+    // Tuinity end - no-tick view distance
+
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
         super((World) worldserver, gameprofile);
         playerinteractmanager.player = this;
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 8977c3516b2ee9b970b6274a5c71982b019ac2a6..0ed78223ccf96957aad123addd2d74ce52d1f2ac 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -208,7 +208,7 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1023, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                int viewDistance = ((WorldServer)this.world).getChunkProvider().playerChunkMap.getEffectiveViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API // Tuinity - no-tick view distance
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
                     //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
                     // Paper end
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 568fbbd5f2f3012c0e7398f59272cbc12e759b68..8f3f7b9ab9111e1590010cb0ace4312334f081c7 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -148,6 +148,18 @@ public class PlayerChunk {
     }
     // Paper end
 
+    // Tuinity start - no-tick view distance
+    public final Chunk getSendingChunk() {
+        // it's important that we use getChunkAtIfLoadedImmediately to mirror the chunk sending logic used
+        // in Chunk's neighbour callback
+        Chunk ret = this.chunkMap.world.getChunkProvider().getChunkAtIfLoadedImmediately(this.location.x, this.location.z);
+        if (ret != null && ret.areNeighboursLoaded(1)) {
+            return ret;
+        }
+        return null;
+    }
+    // Tuinity end - no-tick view distance
+
     public PlayerChunk(ChunkCoordIntPair chunkcoordintpair, int i, LightEngine lightengine, PlayerChunk.c playerchunk_c, PlayerChunk.d playerchunk_d) {
         this.statusFutures = new AtomicReferenceArray(PlayerChunk.CHUNK_STATUSES.size());
         this.fullChunkFuture = PlayerChunk.UNLOADED_CHUNK_FUTURE;
@@ -308,7 +320,7 @@ public class PlayerChunk {
     }
 
     public void a(int i, int j, int k) {
-        Chunk chunk = this.getChunk();
+        Chunk chunk = this.getSendingChunk(); // Tuinity - no-tick view distance
 
         if (chunk != null) {
             this.r |= 1 << (j >> 4);
@@ -328,7 +340,7 @@ public class PlayerChunk {
     }
 
     public void a(EnumSkyBlock enumskyblock, int i) {
-        Chunk chunk = this.getChunk();
+        Chunk chunk = this.getSendingChunk(); // Tuinity - no-tick view distance
 
         if (chunk != null) {
             chunk.setNeedsSaving(true);
@@ -418,9 +430,48 @@ public class PlayerChunk {
     }
 
     private void a(Packet<?> packet, boolean flag) {
-        this.players.a(this.location, flag).forEach((entityplayer) -> {
-            entityplayer.playerConnection.sendPacket(packet);
-        });
+        // Tuinity start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerViewDistanceBroadcastMap;
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> players = viewDistanceMap.getObjectsInRange(this.location);
+        if (players == null) {
+            return;
+        }
+
+        if (flag) { // flag -> border only
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+
+                int viewDistance = viewDistanceMap.getLastViewDistance(player);
+                long lastPosition = viewDistanceMap.getLastCoordinate(player);
+
+                int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - this.location.x);
+                int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - this.location.z);
+
+                if (Math.max(distX, distZ) == viewDistance) {
+                    player.playerConnection.sendPacket(packet);
+                }
+            }
+        } else {
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+                player.playerConnection.sendPacket(packet);
+            }
+        }
+
+        return;
+        // Tuinity end - per player view distance
     }
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> a(ChunkStatus chunkstatus, PlayerChunkMap playerchunkmap) {
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index dcd4a9d972a98e4f5e36837717f587ee56918797..2b5e16e096edce93bb9e1c65dbbc8f27e6552262 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -71,7 +71,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private boolean updatingChunksModified;
     private final ChunkTaskQueueSorter p;
     private final Mailbox<ChunkTaskQueueSorter.a<Runnable>> mailboxWorldGen;
-    private final Mailbox<ChunkTaskQueueSorter.a<Runnable>> mailboxMain;
+    final Mailbox<ChunkTaskQueueSorter.a<Runnable>> mailboxMain; // Tuinity -
     public final WorldLoadListener worldLoadListener;
     public final PlayerChunkMap.a chunkDistanceManager; public final PlayerChunkMap.a getChunkMapDistanceManager() { return this.chunkDistanceManager; } // Paper - OBFHELPER
     private final AtomicInteger u;
@@ -115,6 +115,25 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceMap;
     // Tuinity end - distance maps
 
+    // Tuinity start - no-tick view distance
+    public final int getEffectiveViewDistance() {
+        return this.viewDistance - 1;
+    }
+    int noTickViewDistance;
+    public final int getRawNoTickViewDistance() {
+        return this.noTickViewDistance;
+    }
+    public final int getEffectiveNoTickViewDistance() {
+        return this.noTickViewDistance == -1 ? this.getEffectiveViewDistance() : this.noTickViewDistance;
+    }
+
+    // we use this map to broadcast chunks to clients
+    // they do not render chunks without having at least neighbours in a 1 chunk radius loaded
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceBroadcastMap;
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceTickMap;
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceNoTickMap;
+    // Tuinity end - no-tick view distance
+
     void addPlayerToDistanceMaps(EntityPlayer player) {
         // Tuinity - we need to add players explicitly now
         // Tuinity start - distance maps
@@ -123,6 +142,19 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
         this.playerViewDistanceMap.add(player, chunkX, chunkZ, this.viewDistance);
         // Tuinity end - distance maps
+        // Tuinity start - no-tick view distance
+        int effectiveTickViewDistance = this.getEffectiveViewDistance();
+        int effectiveNoTickViewDistance = Math.max(this.getEffectiveNoTickViewDistance(), effectiveTickViewDistance);
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTickMap.add(player, chunkX, chunkZ, effectiveTickViewDistance);
+            this.playerViewDistanceNoTickMap.add(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk neighbours // add an extra one for antixray
+        }
+
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.add(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); //
+        player.needsChunkCenterUpdate = false;
+        // Tuinity end - no-tick view distance
 
 
 
@@ -132,6 +164,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Tuinity start - distance maps
         this.playerViewDistanceMap.remove(player);
         // Tuinity end - distance maps
+        // Tuinity start - no-tick view distance
+        this.playerViewDistanceBroadcastMap.remove(player);
+        this.playerViewDistanceTickMap.remove(player);
+        this.playerViewDistanceNoTickMap.remove(player);
+        // Tuinity end - no-tick view distance
 
 
 
@@ -143,6 +180,19 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Tuinity start - distance maps
         this.playerViewDistanceMap.update(player, chunkX, chunkZ, this.viewDistance);
         // Tuinity end - distance maps
+        // Tuinity start - no-tick view distance
+        int effectiveTickViewDistance = this.getEffectiveViewDistance();
+        int effectiveNoTickViewDistance = Math.max(this.getEffectiveNoTickViewDistance(), effectiveTickViewDistance);
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTickMap.update(player, chunkX, chunkZ, effectiveTickViewDistance);
+            this.playerViewDistanceNoTickMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk neighbours // add an extra one for antixray
+        }
+
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); //
+        player.needsChunkCenterUpdate = false;
+        // Tuinity end - no-tick view distance
 
 
     }
@@ -220,6 +270,45 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         com.destroystokyo.paper.util.misc.PooledLinkedHashSets<EntityPlayer> sets = this.pooledLinkedPlayerHashSets;
         this.playerViewDistanceMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(sets);
         // Tuinity end - distance maps
+        // Tuinity start - no-tick view distance
+        this.setNoTickViewDistance(this.world.tuinityConfig.noTickViewDistance);
+        this.playerViewDistanceTickMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(sets,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState.size() != 1) {
+                        return;
+                    }
+                    Chunk chunk = PlayerChunkMap.this.world.getChunkProvider().getChunkAtIfLoadedMainThreadNoCache(rangeX, rangeZ);
+                    if (chunk == null || !chunk.areNeighboursLoaded(2)) {
+                        return;
+                    }
+
+                    ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(rangeX, rangeZ);
+                    PlayerChunkMap.this.world.getChunkProvider().addTicketAtLevel(TicketType.PLAYER, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState != null) {
+                        return;
+                    }
+                    ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(rangeX, rangeZ);
+                    PlayerChunkMap.this.world.getChunkProvider().removeTicketAtLevel(TicketType.PLAYER, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
+                });
+        this.playerViewDistanceNoTickMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(sets);
+        this.playerViewDistanceBroadcastMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(sets,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (player.needsChunkCenterUpdate) {
+                        player.needsChunkCenterUpdate = false;
+                        player.playerConnection.sendPacket(new PacketPlayOutViewCentre(currPosX, currPosZ));
+                    }
+                    PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[2], false, true); // unloaded, loaded
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), null, true, false); // unloaded, loaded
+                });
+        // Tuinity end - no-tick view distance
     }
 
     public void updatePlayerMobTypeMap(Entity entity) {
@@ -1040,15 +1129,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         completablefuture1.thenAcceptAsync((either) -> {
             either.mapLeft((chunk) -> {
                 this.u.getAndIncrement();
-                Packet<?>[] apacket = new Packet[2];
-
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    this.a(entityplayer, apacket, chunk);
-                });
+                // Tuinity - no-tick view distance - moved to Chunk neighbour update
                 return Either.left(chunk);
             });
         }, (runnable) -> {
-            this.mailboxMain.a(ChunkTaskQueueSorter.a(playerchunk, runnable)); // CraftBukkit - decompile error
+            this.mailboxMain.a(ChunkTaskQueueSorter.a(playerchunk, runnable)); // CraftBukkit - decompile error // Tuinity - diff on change, this is the scheduling method copied in Chunk used to schedule chunk broadcasts (on change it needs to be copied again)
         });
         return completablefuture1;
     }
@@ -1148,32 +1233,53 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         } // Paper
     }
 
-    protected void setViewDistance(int i) {
-        int j = MathHelper.clamp(i + 1, 3, 33);
+    public final void setViewDistance(int i) { // Tuinity - public
+        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Cannot update view distance off of the main thread"); // Tuinity
+        int j = MathHelper.clamp(i + 1, 3, 33); // Tuinity - diff on change, these make the lower view distance limit 2 and the upper 32
 
         if (j != this.viewDistance) {
             int k = this.viewDistance;
 
             this.viewDistance = j;
-            this.chunkDistanceManager.a(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunks.values().iterator();
+            if (this.world != null && this.world.players != null) { // this can be called from constructor, where these aren't set
+                // Tuinity start - no-tick view distance
+                for (EntityPlayer player : this.world.players) {
+                    PlayerConnection connection = player.playerConnection;
+                    if (connection != null) {
+                        // moved in from PlayerList
+                        connection.sendPacket(new PacketPlayOutViewDistance(this.getEffectiveNoTickViewDistance()));
+                    }
+                    this.updateMaps(player); // distance map handles the chunk sending
+                    // Tuinity end - no-tick view distance
+                }
+            }
+        }
 
-            while (objectiterator.hasNext()) {
-                PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-                Packet<?>[] apacket = new Packet[2];
+    }
 
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = b(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
+    // Tuinity start - no-tick view distance
+    public final void setNoTickViewDistance(int viewDistance) {
+        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Cannot update view distance off of the main thread");
+        viewDistance = viewDistance == -1 ? -1 : MathHelper.clamp(viewDistance, 2, 32);
+        if (viewDistance == this.noTickViewDistance) {
+            return;
+        }
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
+        this.noTickViewDistance = viewDistance;
+        this.chunkDistanceManager.setNoTickViewDistance(this.getEffectiveNoTickViewDistance() + 2 + 2);
+
+        if (this.world != null && this.world.players != null) { // this can be called from constructor, where these aren't set
+            for (EntityPlayer player : this.world.players) {
+                PlayerConnection connection = player.playerConnection;
+                if (connection != null) {
+                    // moved in from PlayerList
+                    connection.sendPacket(new PacketPlayOutViewDistance(this.getEffectiveNoTickViewDistance()));
+                }
+                this.updateMaps(player);
             }
         }
-
     }
+    // Tuinity end - no-tick view distance
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
         if (entityplayer.world == this.world) {
@@ -1181,7 +1287,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 PlayerChunk playerchunk = this.getVisibleChunk(chunkcoordintpair.pair());
 
                 if (playerchunk != null) {
-                    Chunk chunk = playerchunk.getChunk();
+                    Chunk chunk = playerchunk.getSendingChunk(); // Tuinity - no-tick view distance
 
                     if (chunk != null) {
                         this.a(entityplayer, apacket, chunk);
@@ -1427,6 +1533,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         });
     }
 
+    private boolean cannotLoadChunks(EntityPlayer entityplayer) { return this.b(entityplayer); } // Tuinity - OBFHELPER
     private boolean b(EntityPlayer entityplayer) {
         return entityplayer.isSpectator() && !this.world.getGameRules().getBoolean(GameRules.SPECTATORS_GENERATE_CHUNKS);
     }
@@ -1454,13 +1561,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             this.removePlayerFromDistanceMaps(entityplayer); // Tuinity - hook distance map better
         }
 
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
-
-                this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
-            }
-        }
+        // Tuinity - broadcast view distance map handles this (see remove/add calls above)
 
     }
 
@@ -1468,7 +1569,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         SectionPosition sectionposition = SectionPosition.a((Entity) entityplayer);
 
         entityplayer.a(sectionposition);
-        entityplayer.playerConnection.sendPacket(new PacketPlayOutViewCentre(sectionposition.a(), sectionposition.c()));
+        // Tuinity - distance map handles this now
         return sectionposition;
     }
 
@@ -1535,55 +1636,93 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance;
-            l1 = Math.min(j, j1) - this.viewDistance;
-            int i2 = Math.max(i, i1) + this.viewDistance;
-            int j2 = Math.max(j, j1) + this.viewDistance;
+        // Tuinity start - distance map handles this
+        // comment out to make the diff readable...
+//        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
+//            k1 = Math.min(i, i1) - this.viewDistance;
+//            l1 = Math.min(j, j1) - this.viewDistance;
+//            int i2 = Math.max(i, i1) + this.viewDistance;
+//            int j2 = Math.max(j, j1) + this.viewDistance;
+//
+//            for (int k2 = k1; k2 <= i2; ++k2) {
+//                for (int l2 = l1; l2 <= j2; ++l2) {
+//                    ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
+//                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
+//                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
+//
+//                    this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
+//                }
+//            }
+//        } else {
+//            ChunkCoordIntPair chunkcoordintpair1;
+//            boolean flag5;
+//            boolean flag6;
+//
+//            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
+//                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
+//                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
+//                    flag5 = true;
+//                    flag6 = false;
+//                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], true, false);
+//                }
+//            }
+//
+//            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
+//                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
+//                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
+//                    flag5 = false;
+//                    flag6 = true;
+//                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], false, true);
+//                }
+//            }
+//        }
+        // Tuinity end - distance map handles this
 
-            for (int k2 = k1; k2 <= i2; ++k2) {
-                for (int l2 = l1; l2 <= j2; ++l2) {
-                    ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
+        this.updateMaps(entityplayer); // Paper - distance maps
+    }
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
+    @Override
+    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
+        // Tuinity start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> inRange = this.playerViewDistanceBroadcastMap.getObjectsInRange(chunkcoordintpair);
+
+        if (inRange == null) {
+            return Stream.empty();
+        }
+        // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
+        List<EntityPlayer> players = new ArrayList<>();
+        Object[] backingSet = inRange.getBackingSet();
+
+        if (flag) { // flag -> border only
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
                 }
-            }
-        } else {
-            ChunkCoordIntPair chunkcoordintpair1;
-            boolean flag5;
-            boolean flag6;
-
-            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
-                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
-                    flag5 = true;
-                    flag6 = false;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], true, false);
+                EntityPlayer player = (EntityPlayer)temp;
+                int viewDistance = this.playerViewDistanceBroadcastMap.getLastViewDistance(player);
+                long lastPosition = this.playerViewDistanceBroadcastMap.getLastCoordinate(player);
+
+                int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - chunkcoordintpair.x);
+                int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - chunkcoordintpair.z);
+                if (Math.max(distX, distZ) == viewDistance) {
+                    players.add(player);
                 }
             }
-
-            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
-                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
-                    flag5 = false;
-                    flag6 = true;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], false, true);
+        } else {
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
                 }
+                EntityPlayer player = (EntityPlayer)temp;
+                players.add(player);
             }
         }
-
-        this.updateMaps(entityplayer); // Paper - distance maps
-    }
-
-    @Override
-    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
-        return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
-            int i = b(chunkcoordintpair, entityplayer, true);
-
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
-        });
+        return players.stream();
+        // Tuinity end - per player view distance
     }
 
     protected void addEntity(Entity entity) {
@@ -1722,6 +1861,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     }
 
+    final void sendChunk(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) { this.a(entityplayer, apacket, chunk); } // Tuinity - OBFHELPER
     private void a(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) {
         if (apacket[0] == null) {
             apacket[0] = new PacketPlayOutMapChunk(chunk, 65535, true); // Paper - Anti-Xray
@@ -1865,7 +2005,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(this.tracker.chunkX, this.tracker.chunkZ);
                         PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
 
-                        if (playerchunk != null && playerchunk.getChunk() != null) {
+                        if (playerchunk != null && playerchunk.getSendingChunk() != null) { // Tuinity - no-tick view distance
                             flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
                         }
                     }
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index eaba3cbf06a1384b6d8adc02268b29430117c925..a34088985394f70ceeb0103524a24ce4c52c0324 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -150,7 +150,7 @@ public abstract class PlayerList {
 
         // CraftBukkit - getType()
         // Spigot - view distance
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), WorldData.c(worlddata.getSeed()), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.spigotConfig.viewDistance, flag1, !flag));
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), WorldData.c(worlddata.getSeed()), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.getChunkProvider().playerChunkMap.getEffectiveNoTickViewDistance(), flag1, !flag)); // Tuinity - no-tick view distance
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload(PacketPlayOutCustomPayload.a, (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
         playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -766,7 +766,7 @@ public abstract class PlayerList {
         WorldData worlddata = worldserver.getWorldData();
 
         entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(worldserver.worldProvider.getDimensionManager().getType(),  WorldData.c(worldserver.getWorldData().getSeed()), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.getChunkProvider().playerChunkMap.getEffectiveNoTickViewDistance())); // Tuinity - no-tick view distance
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX(), entityplayer1.locY(), entityplayer1.locZ(), entityplayer1.yaw, entityplayer1.pitch));
@@ -1250,7 +1250,7 @@ public abstract class PlayerList {
 
     public void a(int i) {
         this.viewDistance = i;
-        this.sendAll(new PacketPlayOutViewDistance(i));
+        //this.sendAll(new PacketPlayOutViewDistance(i)); // Tuinity - move into setViewDistance
         Iterator iterator = this.server.getWorlds().iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 3850dccd95688d21909b429a306cd16cfc1727b1..beba08635261ffaa86076e5256a8fe2b0ea0e000 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -442,8 +442,13 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
                 this.b(blockposition, iblockdata1, iblockdata2);
             }
 
-            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getState() != null && chunk.getState().isAtLeast(PlayerChunk.State.TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement
+            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getState() != null && chunk.getState().isAtLeast(PlayerChunk.State.TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement // Tuinity - diff on change, see below
                 this.notify(blockposition, iblockdata1, iblockdata, i);
+                // Tuinity start - per player view distance - allow block updates for non-ticking chunks in player view distance
+                // if copied from above
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((WorldServer)this).getChunkProvider().playerChunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) {
+                ((WorldServer)this).getChunkProvider().flagDirty(blockposition);
+                // Tuinity end - per player view distance
             }
 
             if (!this.isClientSide && (i & 1) != 0) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index f56131e3a593f9c1344be07fe478364b344e63dd..a31d71ece1e2b0dd7c1ff4e1dc6cbfea71d958bd 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -2479,10 +2479,39 @@ public class CraftWorld implements World {
     // Spigot start
     @Override
     public int getViewDistance() {
-        return world.spigotConfig.viewDistance;
+        return getHandle().getChunkProvider().playerChunkMap.getEffectiveViewDistance(); // Tuinity - no-tick view distance
     }
     // Spigot end
 
+    // Tuinity start - per player view distance
+    @Override
+    public void setViewDistance(int viewDistance) {
+        if (viewDistance < 2 || viewDistance > 32) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        net.minecraft.server.PlayerChunkMap chunkMap = getHandle().getChunkProvider().playerChunkMap;
+        if (viewDistance != chunkMap.getEffectiveViewDistance()) {
+            chunkMap.setViewDistance(viewDistance);
+        }
+    }
+
+    @Override
+    public int getNoTickViewDistance() {
+        return getHandle().getChunkProvider().playerChunkMap.getEffectiveNoTickViewDistance();
+    }
+
+    @Override
+    public void setNoTickViewDistance(int viewDistance) {
+        if ((viewDistance < 2 || viewDistance > 32) && viewDistance != -1) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        net.minecraft.server.PlayerChunkMap chunkMap = getHandle().getChunkProvider().playerChunkMap;
+        if (viewDistance != chunkMap.getRawNoTickViewDistance()) {
+            chunkMap.setNoTickViewDistance(viewDistance);
+        }
+    }
+    // Tuinity end - per player view distance
+
     // Spigot start
     private final Spigot spigot = new Spigot()
     {
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 795817177aae00a5157ae77b2192841c8d028732..0b10ba1d5c6cbe93d12cbd5473bae7b54edf2f2c 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -140,7 +140,7 @@ public class ActivationRange
         int maxRange = Math.max( monsterActivationRange, animalActivationRange );
         maxRange = Math.max( maxRange, raiderActivationRange );
         maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        maxRange = Math.min( ( ((net.minecraft.server.WorldServer)world).getChunkProvider().playerChunkMap.getEffectiveViewDistance() << 4 ) - 8, maxRange ); // Tuinity - no-tick view distance
 
         for ( EntityHuman player : world.getPlayers() )
         {
