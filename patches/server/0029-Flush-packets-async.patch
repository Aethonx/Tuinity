From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sun, 5 Jan 2020 17:17:41 -0800
Subject: [PATCH] Flush packets async

Apparently sendPacket took 50% of the timings for entity tracker
update, so offload that to the packet flusher thread.

diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 211a6d7206788cbac80f2117d106f39ac3ef6dd5..18fd6ea5daa0a2a62448d5887fb376d6b8eeb32b 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -66,6 +66,43 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
     private static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush");
     // Paper end
 
+    // Tuinity start - flush packets async
+    static final class PacketFlusher extends Thread {
+
+        public final java.util.Set<NetworkManager> needsUpdating = java.util.concurrent.ConcurrentHashMap.newKeySet();
+
+        @Override
+        public void run() {
+            java.util.ArrayDeque<NetworkManager> keep = new java.util.ArrayDeque<>();
+            for (;;) {
+                for (java.util.Iterator<NetworkManager> iterator = this.needsUpdating.iterator(); iterator.hasNext();) {
+                    NetworkManager needsUpdate = iterator.next();
+                    iterator.remove();
+
+                    if (!needsUpdate.sendPacketQueue()) {
+                        keep.add(needsUpdate);
+                    }
+                }
+
+                if (this.needsUpdating.isEmpty()) {
+                    try {
+                        Thread.sleep(1);
+                    } catch (InterruptedException ex) {}
+                }
+
+                for (int i = 0, len = keep.size(); i < len; ++i) {
+                    this.needsUpdating.add(keep.poll());
+                }
+            }
+        }
+    }
+
+    static final PacketFlusher PACKET_FLUSHER = new PacketFlusher();
+    static {
+        PACKET_FLUSHER.start();
+    }
+    // Tuinity end - flush packets async
+
     public NetworkManager(EnumProtocolDirection enumprotocoldirection) {
         this.h = enumprotocoldirection;
     }
@@ -164,11 +201,12 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     public void sendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericfuturelistener) {
-        if (this.isConnected() && this.sendPacketQueue() && !(packet instanceof PacketPlayOutMapChunk && !((PacketPlayOutMapChunk) packet).isReady())) { // Paper - Async-Anti-Xray - Add chunk packets which are not ready or all packets if the packet queue contains chunk packets which are not ready to the packet queue and send the packets later in the right order
+        if (!(this.packetListener instanceof PlayerConnection) && this.isConnected() && this.sendPacketQueue() && !(packet instanceof PacketPlayOutMapChunk && !((PacketPlayOutMapChunk) packet).isReady())) { // Paper - Async-Anti-Xray - Add chunk packets which are not ready or all packets if the packet queue contains chunk packets which are not ready to the packet queue and send the packets later in the right order // Tuinity - this is packet flusher's job now
             //this.o(); // Paper - Async-Anti-Xray - Move to if statement (this.sendPacketQueue())
             this.b(packet, genericfuturelistener);
         } else {
             this.packetQueue.add(new NetworkManager.QueuedPacket(packet, genericfuturelistener));
+            PACKET_FLUSHER.needsUpdating.add(this); // Tuinity - this is packet flusher's job now
         }
 
     }
