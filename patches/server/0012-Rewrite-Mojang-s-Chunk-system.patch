From 935a056bbdd66ac3dfd2a0982bb55e2ea940b1f7 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Thu, 23 May 2019 15:32:45 -0700
Subject: [PATCH] Rewrite Mojang's Chunk system

WIP
---
 .../concrete/chunk/ChunkHolder.java           |  60 ++
 .../concrete/chunk/PrioritizedTaskQueue.java  | 278 +++++++++
 .../concrete/chunk/QueueExecutorThread.java   | 188 ++++++
 .../chunk/io/ConcreteFileIOThread.java        | 577 ++++++++++++++++++
 .../chunk/management/ChunkGenerateTask.java   |  15 +
 .../management/ChunkLoadOrGenerateTask.java   |  85 +++
 .../chunk/management/ChunkTaskHandler.java    |  75 +++
 .../management/ConcreteChunkManager.java      | 129 ++++
 .../ticket/ConcreteChunkTicket.java           | 158 +++++
 .../ticket/ConcreteTicketManager.java         | 262 ++++++++
 .../ca/spottedleaf/concrete/util/Util.java    |  49 ++
 .../minecraft/server/ChunkRegionLoader.java   |  47 +-
 .../net/minecraft/server/MinecraftServer.java |   3 +-
 .../java/net/minecraft/server/RegionFile.java |  64 +-
 .../net/minecraft/server/RegionFileCache.java |   4 +-
 .../minecraft/server/RegionFileSection.java   |  39 +-
 .../net/minecraft/server/WorldServer.java     |  79 +++
 17 files changed, 2101 insertions(+), 11 deletions(-)
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/ChunkHolder.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/PrioritizedTaskQueue.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/QueueExecutorThread.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/io/ConcreteFileIOThread.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkGenerateTask.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkLoadOrGenerateTask.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkTaskHandler.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ConcreteChunkManager.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteChunkTicket.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteTicketManager.java

diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/ChunkHolder.java b/src/main/java/ca/spottedleaf/concrete/chunk/ChunkHolder.java
new file mode 100644
index 000000000..9d269a43c
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/ChunkHolder.java
@@ -0,0 +1,60 @@
+package ca.spottedleaf.concrete.chunk;
+
+import ca.spottedleaf.concrete.chunk.management.ticket.ConcreteChunkTicket;
+import ca.spottedleaf.concrete.util.Util;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
+
+public final class ChunkHolder {
+
+    public final int x;
+    public final int z;
+
+    private final ObjectOpenHashSet<ConcreteChunkTicket<?>> ticketsInRangeOf = new ObjectOpenHashSet<>();
+
+    protected ChunkHolder(final int x, final int z) {
+        this.x = x;
+        this.z = z;
+    }
+
+    public void addTicket(final ConcreteChunkTicket<?> ticket) {
+       this.ticketsInRangeOf.add(ticket);
+    }
+
+    public void removeTicket(final ConcreteChunkTicket<?> ticket) {
+        this.ticketsInRangeOf.remove(ticket);
+    }
+
+    public boolean hasTickets() {
+        return !this.ticketsInRangeOf.isEmpty();
+    }
+
+    public boolean canChunkTick() {
+        for (final ConcreteChunkTicket<?> ticket : this.ticketsInRangeOf) {
+            if (Util.rangeCheck(this.x, this.z, ticket.getChunkX(), ticket.getChunkZ(), ticket.chunkTickRadius)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean canEntityTick() {
+        for (final ConcreteChunkTicket<?> ticket : this.ticketsInRangeOf) {
+            if (Util.rangeCheck(this.x, this.z, ticket.getChunkX(), ticket.getChunkZ(), ticket.entityTickRadius)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean isInactive() {
+        for (final ConcreteChunkTicket<?> ticket : this.ticketsInRangeOf) {
+            final int radius = Util.branchlessAbsMax(this.x - ticket.getChunkX(), this.z - ticket.getChunkZ());
+            final int activeRadius = Util.branchlessMax(ticket.chunkTickRadius, ticket.entityTickRadius);
+            if (radius <= activeRadius) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/PrioritizedTaskQueue.java b/src/main/java/ca/spottedleaf/concrete/chunk/PrioritizedTaskQueue.java
new file mode 100644
index 000000000..34e125186
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/PrioritizedTaskQueue.java
@@ -0,0 +1,278 @@
+package ca.spottedleaf.concrete.chunk;
+
+import ca.spottedleaf.concrete.util.Util;
+import ca.spottedleaf.concurrentutil.ConcurrentUtil;
+import ca.spottedleaf.concurrentutil.queue.ConcurrentLinkedList;
+
+import java.lang.invoke.VarHandle;
+
+public class PrioritizedTaskQueue<T extends PrioritizedTaskQueue.PrioritizedTask> {
+
+    // lower numbers are a higher priority (except < 0)
+    // higher priorities are always executed before lower priorities
+
+    /**
+     * Priority value indicating the task has completed or is being completed.
+     */
+    public static final int COMPLETING_PRIORITY   = -1;
+
+    /**
+     * Highest priority, should only be used for main thread tasks or tasks that are blocking the main thread.
+     */
+    public static final int HIGHEST_PRIORITY      = 0;
+
+    /**
+     * Should be only used in an IO task so that chunk loads do not wait on other IO tasks.
+     * This only exists because IO tasks are scheduled before chunk load tasks to decrease IO waiting times.
+     */
+    public static final int HIGHER_PRIORITY       = 1;
+
+    /**
+     * Should be used for scheduling chunk loads/generation that would increase response times to users.
+     */
+    public static final int HIGH_PRIORITY         = 2;
+
+    /**
+     * Default priority.
+     */
+    public static final int NORMAL_PRIORITY       = 3;
+
+    /**
+     * Use for tasks not at all critical and can potentially be delayed.
+     */
+    public static final int LOW_PRIORITY          = 4;
+
+    /**
+     * Use for tasks that should "eventually" execute.
+     */
+    public static final int LOWEST_PRIORITY       = 5;
+
+    private static final int TOTAL_PRIORITIES     = 6;
+
+    final ConcurrentLinkedList<T>[] queues = (ConcurrentLinkedList<T>[])new ConcurrentLinkedList[TOTAL_PRIORITIES];
+
+    {
+        for (int i = 0; i < TOTAL_PRIORITIES; ++i) {
+            this.queues[i] = new ConcurrentLinkedList<>();
+        }
+    }
+
+    /**
+     * Returns whether the specified priority is valid
+     */
+    public static boolean validPriority(final int priority) {
+        return priority >= 0 && priority < TOTAL_PRIORITIES;
+    }
+
+    /**
+     * Queues a task.
+     * @throws IllegalStateException If the task has already been queued. Use {@link PrioritizedTask#raisePriority(int)} to
+     *                               raise a task's priority.
+     *                               This can also be thrown if the queue has shutdown.
+     */
+    public void add(final T task) throws IllegalStateException {
+        task.onQueue(this);
+        if (!this.queues[task.getPriority()].add(task)) {
+            throw new IllegalStateException("Queue has shutdown, refusing to execute task " + Util.genericToString(task));
+        }
+    }
+
+    /**
+     * Polls the highest priority task currently available. {@code null} if none.
+     */
+    public T poll() {
+        T task;
+        for (int i = 0; i < TOTAL_PRIORITIES; ++i) {
+            final ConcurrentLinkedList<T> queue = this.queues[i];
+
+            while ((task = queue.poll()) != null) {
+                final int prevPriority = task.tryComplete(i);
+                if (prevPriority != COMPLETING_PRIORITY && prevPriority <= i) {
+                    // if the prev priority was greater-than or equal to our current priority
+                    return task;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Prevent further additions to this queue. Attempts to add after this call has completed (potentially during) will
+     * result in {@link IllegalStateException} being thrown.
+     * <p>
+     *     This operation is atomic with respect to other shutdown calls
+     * </p>
+     * <p>
+     *     After this call has completed, regardless of return value, this queue will be shutdown.
+     * </p>
+     * @return {@code true} if the queue was shutdown, {@code false} if it has shut down already
+     */
+    public boolean shutdown() {
+        boolean ret = this.queues[0].preventAdds();
+        for (int i = 1; i < TOTAL_PRIORITIES; ++i) {
+            this.queues[i].preventAdds();
+        }
+        return ret;
+    }
+
+    public abstract static class PrioritizedTask {
+
+        protected PrioritizedTaskQueue queue;
+
+        protected volatile int priority;
+
+        protected static final VarHandle PRIORITY_HANDLE = ConcurrentUtil.getVarHandle(PrioritizedTask.class, "priority", int.class);
+
+        protected PrioritizedTask() {
+            this(PrioritizedTaskQueue.NORMAL_PRIORITY);
+        }
+
+        protected PrioritizedTask(final int priority) {
+            if (!PrioritizedTaskQueue.validPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority " + priority);
+            }
+            this.setPriorityPlain(priority);
+        }
+
+        /**
+         * Returns the current priority. Note that {@link PrioritizedTaskQueue#COMPLETING_PRIORITY} will be returned
+         * if this task is completing or has completed.
+         */
+        public final int getPriority() {
+            return this.getPriorityVolatile();
+        }
+
+        final int tryComplete(final int minPriority) {
+            for (int curr = this.getPriorityVolatile(), failures = 0;;) {
+                if (curr == COMPLETING_PRIORITY) {
+                    return COMPLETING_PRIORITY;
+                }
+                if (curr > minPriority) {
+                    // curr is lower priority
+                    return curr;
+                }
+
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.pause();
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, COMPLETING_PRIORITY))) {
+                    return curr;
+                }
+                ++failures;
+                continue;
+            }
+        }
+
+        /**
+         * Forces this task to be completed.
+         * @return {@code true} if the task was cancelled, {@code false} if the task has already completed or is being completed.
+         */
+        public boolean cancel() {
+            return this.exchangePriorityVolatile(PrioritizedTaskQueue.COMPLETING_PRIORITY) != PrioritizedTaskQueue.COMPLETING_PRIORITY;
+        }
+
+        /**
+         * Attempts to raise the priority to the priority level specified.
+         * @param priority Priority specified
+         * @return {@code true} if successful, {@code false} otherwise.
+         */
+        public boolean raisePriority(final int priority) {
+            if (!PrioritizedTaskQueue.validPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority");
+            }
+
+            final PrioritizedTaskQueue queue = this.queue;
+
+            if (queue == null) {
+                throw new IllegalStateException("Not queued");
+            }
+
+            for (int curr = this.getPriorityVolatile(), failures = 0;;) {
+                if (curr == COMPLETING_PRIORITY) {
+                    return false;
+                }
+                if (priority >= curr) {
+                    return true;
+                }
+
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.pause();
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority))) {
+                    //noinspection unchecked
+                    queue.queues[priority].add(this); // silently fail on shutdown
+                    return true;
+                }
+                ++failures;
+                continue;
+            }
+        }
+
+        /**
+         * Attempts to set this task's priority level to the level specified.
+         * @param priority Specified priority level.
+         * @return {@code true} if successful, {@code false} if this task is completing or has completed.
+         */
+        public boolean updatePriority(final int priority) {
+            if (!PrioritizedTaskQueue.validPriority(priority)) {
+                throw new IllegalArgumentException("Invalid priority");
+            }
+
+            final PrioritizedTaskQueue queue = this.queue;
+
+            if (queue == null) {
+                throw new IllegalStateException("Not queued");
+            }
+
+            for (int curr = this.getPriorityVolatile(), failures = 0;;) {
+                if (curr == COMPLETING_PRIORITY) {
+                    return false;
+                }
+                if (curr == priority) {
+                    return true;
+                }
+
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.pause();
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority))) {
+                    //noinspection unchecked
+                    queue.queues[priority].add(this); // silently fail on shutdown
+                    return true;
+                }
+                ++failures;
+                continue;
+            }
+        }
+
+        void onQueue(final PrioritizedTaskQueue queue) {
+            if (this.queue != null) {
+                throw new IllegalStateException("Already queued!");
+            }
+            this.queue = queue;
+        }
+
+
+        /* priority */
+
+        protected final int getPriorityVolatile() {
+            return (int)PRIORITY_HANDLE.getVolatile(this);
+        }
+
+        protected final void setPriorityPlain(final int value) {
+            PRIORITY_HANDLE.set(this, value);
+        }
+
+        protected final int compareAndExchangePriorityVolatile(final int expect, final int update) {
+            return (int)PRIORITY_HANDLE.compareAndExchange(this, expect, update);
+        }
+
+        protected final int exchangePriorityVolatile(final int value) {
+            return (int)PRIORITY_HANDLE.getAndSet(this, value);
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/QueueExecutorThread.java b/src/main/java/ca/spottedleaf/concrete/chunk/QueueExecutorThread.java
new file mode 100644
index 000000000..eedb8e643
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/QueueExecutorThread.java
@@ -0,0 +1,188 @@
+package ca.spottedleaf.concrete.chunk;
+
+import ca.spottedleaf.concrete.util.Util;
+import ca.spottedleaf.concurrentutil.queue.ConcurrentLinkedList;
+import net.minecraft.server.MinecraftServer;
+import org.apache.logging.log4j.Logger;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.LockSupport;
+
+public class QueueExecutorThread<T extends PrioritizedTaskQueue.PrioritizedTask> extends Thread {
+
+    private static final Logger LOGGER = MinecraftServer.LOGGER;
+
+    protected final PrioritizedTaskQueue<T> queue;
+    protected final long spinWaitTime;
+
+    protected volatile boolean closed;
+    protected final AtomicBoolean parked = new AtomicBoolean();
+
+    protected final ConcurrentLinkedList<Thread> flushQueue = new ConcurrentLinkedList<>();
+    protected volatile int flushCounter;
+
+    public QueueExecutorThread(final PrioritizedTaskQueue<T> queue) {
+        this(queue, (int)(1.e6)); // 1.0ms
+    }
+
+    public QueueExecutorThread(final PrioritizedTaskQueue<T> queue, final long spinWaitTime) { // in ms
+        this.queue = queue;
+        this.spinWaitTime = spinWaitTime;
+    }
+
+    @Override
+    public void run() {
+        final long spinWaitTime = this.spinWaitTime;
+        main_loop:
+        for (;;) {
+            this.pollTasks();
+
+            // spinwait
+
+            final long start = System.nanoTime();
+
+            for (;;) {
+                // If we are interrpted for any reason, park() will always return immediately. Clear so that we don't needlessly use cpu in such an event.
+                Thread.interrupted();
+                LockSupport.parkNanos("Spinwaiting on tasks", 1000L); // 1us
+
+                if (this.pollTasks()) {
+                    continue main_loop;
+                }
+
+                if (this.handleClose()) {
+                    return; // we're done
+                }
+
+                if ((System.nanoTime() - start) >= spinWaitTime) {
+                    break;
+                }
+            }
+
+            if (this.handleClose()) {
+                return;
+            }
+
+            this.parked.set(true);
+            // We need to parse here to avoid a race condition where a thread queues a task before we set parked to true
+            if (this.pollTasks()) {
+                this.parked.set(false);
+                continue;
+            }
+
+            do {
+                Thread.interrupted();
+                LockSupport.park("Waiting on tasks");
+            } while (this.parked.get());
+        }
+    }
+
+    protected boolean handleClose() {
+        if (this.closed) {
+            // at this stage no task may be queued
+            this.pollTasks(); // this ensures we've emptied the queue
+            this.handleFlushThreads(true);
+            return true;
+        }
+        return false;
+    }
+
+    protected boolean pollTasks() {
+        Runnable task;
+        boolean ret = false;
+
+        while ((task = (Runnable)this.queue.poll()) != null) {
+            ret = true;
+            try {
+                task.run();
+            } catch (final Throwable throwable) {
+                if (throwable instanceof ThreadDeath) {
+                    throw (ThreadDeath)throwable;
+                }
+                LOGGER.fatal("Exception thrown from prioritized runnable task in thread " + this.getName() + ": " + Util.genericToString(task), throwable);
+            }
+        }
+
+        this.handleFlushThreads(false);
+
+        return ret;
+    }
+
+    protected void handleFlushThreads(final boolean shutdown) {
+        //noinspection NonAtomicOperationOnVolatileField
+        ++this.flushCounter;
+        this.flushQueue.drain(LockSupport::unpark, shutdown);
+    }
+
+    protected void queueTask(final T task) {
+        this.queue.add(task);
+        if (this.parked.get() && this.parked.getAndSet(false)) {
+            LockSupport.unpark(this);
+        }
+    }
+
+    /**
+     * Waits until this thread's queue is empty.
+     *
+     * @throws IllegalStateException If the current thread is {@code this} thread.
+     */
+    public void flush() {
+        final Thread currentThread = Thread.currentThread();
+
+        if (currentThread == this) {
+            throw new IllegalStateException("Cannot flush the queue executor thread while on the queue executor thread");
+        }
+
+        // order is important
+
+        if (this.parked.get()) {
+            return; // no tasks queued
+        }
+
+        int flushCounter = this.flushCounter;
+
+        if (!this.flushQueue.add(currentThread)) {
+            return;
+        }
+
+        // re-check parked status
+        if (this.parked.get()) {
+            return;
+        }
+
+        // force a response from the IO thread, we're not sure of its state currently
+        this.parked.set(false);
+        LockSupport.unpark(this);
+
+        boolean interrupted = false; // preserve interrupted status
+
+        while (this.flushCounter == flushCounter) {
+            interrupted |= Thread.interrupted();
+            LockSupport.park();
+        }
+
+        if (interrupted) {
+            Thread.currentThread().interrupt();
+        }
+    }
+
+    /**
+     * Closes this queue executor's queue and optionally waits for it to empty.
+     * <p>
+     *     If wait is {@code true}, then the queue will be empty by the time this call completes.
+     * </p>
+     * <p>
+     *     This function is MT-Safe.
+     * </p>
+     * @param wait If this call is to wait until the queue is empty
+     * @return whether this thread shut down the queue
+     */
+    public boolean close(final boolean wait) {
+        boolean ret = this.queue.shutdown();
+        this.closed = true;
+        if (wait) {
+            this.flush();
+        }
+        return ret;
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/io/ConcreteFileIOThread.java b/src/main/java/ca/spottedleaf/concrete/chunk/io/ConcreteFileIOThread.java
new file mode 100644
index 000000000..99fd9bbbc
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/io/ConcreteFileIOThread.java
@@ -0,0 +1,577 @@
+package ca.spottedleaf.concrete.chunk.io;
+
+import ca.spottedleaf.concrete.chunk.PrioritizedTaskQueue;
+import ca.spottedleaf.concrete.chunk.QueueExecutorThread;
+import ca.spottedleaf.concrete.util.Util;
+import ca.spottedleaf.concurrentutil.util.ArrayUtil;
+import ca.spottedleaf.concurrentutil.util.Validate;
+import net.minecraft.server.*;
+import org.apache.logging.log4j.Logger;
+
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+/**
+ * Prioritized singleton thread responsible for all chunk IO that occurs in a minecraft server.
+ *
+ * <p>
+ *    Singleton access: {@link Holder#INSTANCE}
+ * </p>
+ *
+ * <p>
+ *     All functions provided are MT-Safe, however certain ordering constraints are (but not enforced):
+ *     <li>
+ *         Chunk saves may not occur for unloaded chunks.
+ *     </li>
+ *     <li>
+ *         Tasks must be scheduled on the main thread.
+ *     </li>
+ * </p>
+ *
+ * @see Holder#INSTANCE
+ * @see #scheduleSave(WorldServer, int, int, NBTTagCompound, NBTTagCompound, int)
+ * @see #loadChunkDataAsync(WorldServer, int, int, int, Consumer, boolean, boolean, boolean)
+ */
+public final class ConcreteFileIOThread extends QueueExecutorThread<PrioritizedTaskQueue.PrioritizedTask> {
+
+    public static final NBTTagCompound WRITE_FAILURE = new NBTTagCompound();
+
+    private static final Logger LOGGER = MinecraftServer.LOGGER;
+
+    public static final class Holder {
+
+        public static final ConcreteFileIOThread INSTANCE = new ConcreteFileIOThread();
+
+        static {
+            INSTANCE.start();
+        }
+    }
+
+    private final AtomicLong writeCounter = new AtomicLong();
+
+    private ConcreteFileIOThread() {
+        super(new PrioritizedTaskQueue<>(), (int)(1.0e6)); // 1.0ms spinwait time
+        this.setName("Concrete RegionFile IO Thread");
+        this.setPriority(Thread.NORM_PRIORITY - 1); // we keep priority close to normal because threads can wait on us
+        this.setUncaughtExceptionHandler((final Thread unused, final Throwable thr) -> {
+            LOGGER.fatal("Uncaught exception thrown from IO thread, report this!", thr);
+        });
+    }
+
+    /* run() is implemented by superclass */
+
+    /*
+     *
+     * IO thread will perform reads before writes
+     *
+     * How reads/writes are scheduled:
+     *
+     * If read in progress while scheduling write, ignore read and schedule write
+     * If read in progress while scheduling read (no write in progress), chain the read task
+     *
+     *
+     * If write in progress while scheduling read, use the pending write data and ret immediately
+     * If write in progress while scheduling write (ignore read in progress), overwrite the write in progress data
+     *
+     * This allows the reads and writes to act as if they occur synchronously to the thread scheduling them, however
+     * it fails to properly propagate write failures
+     *
+     */
+
+    /**
+     * Attempts to bump the priority of all IO tasks for the given chunk coordinates. This has no effect if no tasks are queued.
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param priority Priority level to try to bump to
+     */
+    public void bumpPriority(final WorldServer world, final int chunkX, final int chunkZ, final int priority) {
+        if (!PrioritizedTaskQueue.validPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority: " + priority);
+        }
+
+        final Long key = Long.valueOf(Util.getCoordinateKey(chunkX, chunkZ));
+
+        final ChunkDataTask poiTask = world.poiDataController.tasks.get(key);
+        final ChunkDataTask chunkTask = world.chunkDataController.tasks.get(key);
+
+        if (poiTask != null) {
+            poiTask.raisePriority(priority);
+        }
+        if (chunkTask != null) {
+            chunkTask.raisePriority(priority);
+        }
+    }
+
+    /**
+     * Sets the priority of all IO tasks for the given chunk coordinates. This has no effect if no tasks are queued.
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param priority Priority level to set to
+     */
+    public void setPriority(final WorldServer world, final int chunkX, final int chunkZ, final int priority) {
+        if (!PrioritizedTaskQueue.validPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority: " + priority);
+        }
+
+        final Long key = Long.valueOf(Util.getCoordinateKey(chunkX, chunkZ));
+
+        final ChunkDataTask poiTask = world.poiDataController.tasks.get(key);
+        final ChunkDataTask chunkTask = world.chunkDataController.tasks.get(key);
+
+        if (poiTask != null) {
+            poiTask.updatePriority(priority);
+        }
+        if (chunkTask != null) {
+            chunkTask.updatePriority(priority);
+        }
+    }
+
+    /**
+     * Schedules the chunk data to be written asynchronously.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     This function presumes a chunk load for the coordinates is not called during this function (anytime after is OK). This means
+     *     saves must be scheduled before a chunk is unloaded.
+     * </li>
+     * <li>
+     *     Writes may be called concurrently, although only the "later" write will go through.
+     * </li>
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param poiData Chunk point of interest data. If {@code null}, then no poi data is saved.
+     * @param chunkData Chunk data. If {@code null}, then no chunk data is saved.
+     * @param priority Priority level for this task. See {@link PrioritizedTaskQueue}
+     * @throws IllegalArgumentException If both {@code poiData} and {@code chunkData} are {@code null}.
+     * @throws IllegalStateException If the file io thread has shutdown.
+     */
+    public void scheduleSave(final WorldServer world, final int chunkX, final int chunkZ,
+                             final NBTTagCompound poiData, final NBTTagCompound chunkData,
+                             final int priority) throws IllegalArgumentException {
+        if (!PrioritizedTaskQueue.validPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority: " + priority);
+        }
+
+        final long writeCounter = this.writeCounter.getAndIncrement();
+
+        if (poiData != null) {
+            this.scheduleWrite(world.poiDataController, world, chunkX, chunkZ, poiData, priority, writeCounter);
+        }
+        if (chunkData != null) {
+            this.scheduleWrite(world.chunkDataController, world, chunkX, chunkZ, chunkData, priority, writeCounter);
+        }
+    }
+
+    private void scheduleWrite(final ChunkDataController dataController, final WorldServer world,
+                               final int chunkX, final int chunkZ, final NBTTagCompound data, final int priority, final long writeCounter) {
+        dataController.tasks.compute(Long.valueOf(Util.getCoordinateKey(chunkX, chunkZ)), (final Long keyInMap, final ChunkDataTask taskRunning) -> {
+            if (taskRunning == null) {
+                // no task is scheduled
+
+                // create task
+                final ChunkDataTask newTask = new ChunkDataTask(priority, world, chunkX, chunkZ, dataController);
+                newTask.inProgressWrite = new ChunkDataController.InProgressWrite();
+                newTask.inProgressWrite.writeCounter = writeCounter;
+                newTask.inProgressWrite.data = data;
+
+                ConcreteFileIOThread.this.queueTask(newTask); // schedule
+                return newTask;
+            }
+
+            taskRunning.raisePriority(priority);
+
+            if (taskRunning.inProgressWrite == null) {
+                taskRunning.inProgressWrite = new ChunkDataController.InProgressWrite();
+            }
+
+            boolean reschedule = taskRunning.inProgressWrite.writeCounter == -1L;
+
+            // synchronize for readers
+            //noinspection SynchronizationOnLocalVariableOrMethodParameter
+            synchronized (taskRunning) {
+                taskRunning.inProgressWrite.data = data;
+                taskRunning.inProgressWrite.writeCounter = writeCounter;
+            }
+
+            if (reschedule) {
+                // We need to reschedule this task since the previous one is not currently scheduled since it failed
+                taskRunning.reschedule(priority);
+            }
+
+            return taskRunning;
+        });
+    }
+
+    /**
+     * Same as {@link #loadChunkDataAsync(WorldServer, int, int, int, Consumer, boolean, boolean, boolean)}, except this function returns
+     * a {@link CompletableFuture} which is potentially completed <b>ASYNCHRONOUSLY ON THE FILE IO THREAD</b> when the load task
+     * has completed.
+     * <p>
+     *     Note that if the chunk fails to load the returned future is completed with {@code null}.
+     * </p>
+     */
+    public CompletableFuture<ChunkData> loadChunkDataAsyncFuture(final WorldServer world, final int chunkX, final int chunkZ,
+                                                                 final int priority, final boolean readPoiData, final boolean readChunkData,
+                                                                 final boolean intendingToBlock) {
+        final CompletableFuture<ChunkData> future = new CompletableFuture<>();
+        this.loadChunkDataAsync(world, chunkX, chunkZ, priority, future::complete, readPoiData, readChunkData, intendingToBlock);
+        return future;
+    }
+
+    /**
+     * Schedules a load to be executed asynchronously.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     If a chunk fails to load, the {@code onComplete} parameter is completed with {@code null}.
+     * </li>
+     * <li>
+     *     It is possible for the {@code onComplete} parameter to be given {@link ChunkData} containing data
+     *     this call did not request.
+     * </li>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread. Interacting with the file IO thread in the completion of
+     *     data is undefined behaviour, and can cause deadlock.
+     * </li>
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param priority Priority level for this task. See {@link PrioritizedTaskQueue}
+     * @param onComplete Consumer to execute once this task has completed
+     * @param readPoiData Whether to read point of interest data. If {@code false}, the {@code NBTTagCompound} will be {@code null}.
+     * @param readChunkData Whether to read chunk data. If {@code false}, the {@code NBTTagCompound} will be {@code null}.
+     * @return The {@link PrioritizedTaskQueue.PrioritizedTask} associated with this task. Note that this task does not support
+     *                                                          cancellation.
+     */
+    public void loadChunkDataAsync(final WorldServer world, final int chunkX, final int chunkZ,
+                                   final int priority, final Consumer<ChunkData> onComplete,
+                                   final boolean readPoiData, final boolean readChunkData,
+                                   final boolean intendingToBlock) {
+        if (!PrioritizedTaskQueue.validPriority(priority)) {
+            throw new IllegalArgumentException("Invalid priority: " + priority);
+        }
+
+        if (!(readPoiData | readChunkData)) {
+            throw new IllegalArgumentException("Must read chunk data or poi data");
+        }
+
+        final ChunkData complete = new ChunkData();
+        final boolean[] requireCompletion = new boolean[] { readPoiData, readChunkData };
+
+        if (readPoiData) {
+            this.scheduleRead(world.poiDataController, world, chunkX, chunkZ, (final NBTTagCompound poiData) -> {
+                complete.poiData = poiData;
+
+                final boolean finished;
+
+                // avoid a race condition where the file io thread completes and we complete synchronously
+                ArrayUtil.setVolatile(requireCompletion, 0,false); // 0 -> poi data
+                finished = !ArrayUtil.getVolatile(requireCompletion, 1); // 1 -> chunk data
+
+                if (finished) {
+                    onComplete.accept(complete);
+                }
+            }, priority, intendingToBlock);
+        }
+
+        if (readChunkData) {
+            this.scheduleRead(world.chunkDataController, world, chunkX, chunkZ, (final NBTTagCompound chunkData) -> {
+                complete.chunkData = chunkData;
+
+                final boolean finished;
+
+                // avoid a race condition where the file io thread completes and we complete synchronously
+                ArrayUtil.setVolatile(requireCompletion, 1,false); // 1 -> chunk data
+                finished = !ArrayUtil.getVolatile(requireCompletion, 0); // 0 -> poi data
+
+                if (finished) {
+                    onComplete.accept(complete);
+                }
+            }, priority, intendingToBlock);
+        }
+
+    }
+
+    // Note: the onComplete may be called asynchronously or synchronously here.
+    private void scheduleRead(final ChunkDataController dataController, final WorldServer world,
+                              final int chunkX, final int chunkZ, final Consumer<NBTTagCompound> onComplete, final int priority,
+                              final boolean intendingToBlock) {
+
+        Function<RegionFile, Boolean> tryLoadFunction = (final RegionFile file) -> {
+            if (file == null) {
+                return Boolean.TRUE;
+            }
+            return Boolean.valueOf(file.chunkExists(new ChunkCoordIntPair(chunkX, chunkZ)));
+        };
+
+        dataController.tasks.compute(Long.valueOf(Util.getCoordinateKey(chunkX, chunkZ)), (final Long keyInMap, final ChunkDataTask running) -> {
+            if (running == null) {
+                // not scheduled
+
+                final Boolean shouldSchedule = intendingToBlock ? dataController.computeForRegionFile(chunkX, chunkZ, tryLoadFunction) :
+                        dataController.computeForRegionFileIfLoaded(chunkX, chunkZ, tryLoadFunction);
+
+                if (shouldSchedule == Boolean.FALSE) {
+                    // not on disk
+                    onComplete.accept(null);
+                    return null;
+                }
+
+                // set up task
+                final ChunkDataTask newTask = new ChunkDataTask(priority, world, chunkX, chunkZ, dataController);
+                newTask.inProgressRead = new ChunkDataController.InProgressRead();
+                newTask.inProgressRead.readFuture.thenAccept(onComplete);
+
+                ConcreteFileIOThread.this.queueTask(newTask); // schedule task
+                return newTask;
+            }
+
+            running.raisePriority(priority);
+
+            if (running.inProgressWrite == null) {
+                // chain to the read future
+                running.inProgressRead.readFuture.thenAccept(onComplete);
+                return running;
+            }
+
+            // at this stage we have to use the in progress write's data to avoid an order issue
+            // we don't synchronize since all writes to data occur in the compute() call
+            onComplete.accept(running.inProgressWrite.data);
+            return running;
+        });
+    }
+
+    /**
+     * Same as {@link #loadChunkDataAsync(WorldServer, int, int, int, Consumer, boolean, boolean, boolean)}, except this function returns
+     * the {@link ChunkData} associated with the specified chunk when the task is complete.
+     * @return The chunk data, or {@code null} if the chunk failed to load.
+     */
+    public ChunkData loadChunkData(final WorldServer world, final int chunkX, final int chunkZ, final int priority,
+                                   final boolean readPoiData, final boolean readChunkData) {
+        return this.loadChunkDataAsyncFuture(world, chunkX, chunkZ, priority, readPoiData, readChunkData, true).join();
+    }
+
+    /**
+     * Schedules the given task at the specified priority to be executed on the IO thread.
+     * <p>
+     *     Internal api. Do not use.
+     * </p>
+     */
+    public void runTask(final int priority, final Runnable runnable) {
+        this.queueTask(new GeneralTask(priority, runnable));
+    }
+
+    static final class GeneralTask extends PrioritizedTaskQueue.PrioritizedTask implements Runnable {
+
+        private final Runnable run;
+
+        public GeneralTask(final int priority, final Runnable run) {
+            super(priority);
+            this.run = Validate.notNull(run, "Task may not be null");
+        }
+
+        @Override
+        public void run() {
+            try {
+                this.run.run();
+            } catch (final Throwable throwable) {
+                if (throwable instanceof ThreadDeath) {
+                    throw (ThreadDeath)throwable;
+                }
+                LOGGER.fatal("Failed to execute general task on IO thread " + Util.genericToString(this.run), throwable);
+            }
+        }
+    }
+
+    public static final class ChunkData {
+
+        public NBTTagCompound poiData;
+        public NBTTagCompound chunkData;
+
+        public ChunkData() {}
+
+        public ChunkData(final NBTTagCompound poiData, final NBTTagCompound chunkData) {
+            this.poiData = poiData;
+            this.chunkData = chunkData;
+        }
+    }
+
+    public static abstract class ChunkDataController {
+
+        // ConcurrentHashMap synchronizes per chain, so reduce the chance of task's hashes colliding.
+        public final ConcurrentHashMap<Long, ChunkDataTask> tasks = new ConcurrentHashMap<>(64, 0.5f);
+
+        public abstract void writeData(final int chunkX, final int chunkZ, final NBTTagCompound compound) throws IOException;
+        public abstract NBTTagCompound readData(final int chunkX, final int chunkZ) throws IOException;
+
+        public abstract <T> T computeForRegionFile(final int chunkX, final int chunkZ, final Function<RegionFile, T> function);
+        public abstract <T> T computeForRegionFileIfLoaded(final int chunkX, final int chunkZ, final Function<RegionFile, T> function);
+
+        public static final class InProgressWrite {
+            public long writeCounter;
+            public NBTTagCompound data;
+        }
+
+        public static final class InProgressRead {
+            public final CompletableFuture<NBTTagCompound> readFuture = new CompletableFuture<>();
+        }
+    }
+
+    public static final class ChunkDataTask extends PrioritizedTaskQueue.PrioritizedTask implements Runnable {
+
+        public ChunkDataController.InProgressWrite inProgressWrite;
+        public ChunkDataController.InProgressRead inProgressRead;
+
+        private final WorldServer world;
+        private final int x;
+        private final int z;
+        private final ChunkDataController taskController;
+
+        public ChunkDataTask(final int priority, final WorldServer world, final int x, final int z, final ChunkDataController taskController) {
+            super(priority);
+            this.world = world;
+            this.x = x;
+            this.z = z;
+            this.taskController = taskController;
+        }
+
+        /*
+         *
+         * IO thread will perform reads before writes
+         *
+         * How reads/writes are scheduled:
+         *
+         * If read in progress while scheduling write, ignore read and schedule write
+         * If read in progress while scheduling read (no write in progress), chain the read task
+         *
+         *
+         * If write in progress while scheduling read, use the pending write data and ret immediately
+         * If write in progress while scheduling write (ignore read in progress), overwrite the write in progress data
+         *
+         * This allows the reads and writes to act as if they occur synchronously to the thread scheduling them, however
+         * it fails to properly propagate write failures
+         *
+         */
+
+        void reschedule(final int priority) {
+            // priority is checked before this stage
+            this.queue = null;
+            this.setPriorityPlain(priority);
+            ConcreteFileIOThread.Holder.INSTANCE.queueTask(this);
+        }
+
+        @Override
+        public void run() {
+            ChunkDataController.InProgressRead read = this.inProgressRead;
+            if (read != null) {
+                NBTTagCompound compound = null;
+                try {
+                    compound = this.taskController.readData(this.x, this.z);
+                } catch (final Throwable thr) {
+                    if (thr instanceof ThreadDeath) {
+                        throw (ThreadDeath)thr;
+                    }
+                    LOGGER.fatal("Failed to read chunk data for (" + this.x + "," + this.z + ")", thr);
+                    // fall through to complete with null data
+                }
+                read.readFuture.complete(compound);
+            }
+
+            final Long chunkKey = Long.valueOf(Util.getCoordinateKey(this.x, this.z));
+
+            ChunkDataController.InProgressWrite write = this.inProgressWrite;
+
+            if (write == null) {
+                // IntelliJ warns this is invalid, however it does not consider that writes to the task map & the inProgress field can occur concurrently.
+                ChunkDataTask inMap = this.taskController.tasks.compute(chunkKey, (final Long keyInMap, final ChunkDataTask valueInMap) -> {
+                    if (valueInMap == null) {
+                        throw new IllegalStateException("Write completed concurrently, report this");
+                    }
+                    if (valueInMap != ChunkDataTask.this) {
+                        throw new IllegalStateException("Chunk task mismatch, report this");
+                    }
+                    return valueInMap.inProgressWrite == null ? null : valueInMap;
+                });
+
+                if (inMap == null) {
+                    return; // set the task value to null, indicating we're done
+                }
+
+                // not null, which means there was a concurrent write
+                write = this.inProgressWrite;
+            }
+
+            // check if another process is writing
+            try {
+                this.world.checkSession();
+            } catch (final ExceptionWorldConflict ex) {
+                LOGGER.fatal("Couldn't save chunk; already in use by another instance of Minecraft?", ex);
+                // we don't need to set the write counter to -1 as we know at this stage there's no point in re-scheduling
+                // writes since they'll fail anyways.
+                return;
+            }
+
+            for (;;) {
+                final long writeCounter;
+                final NBTTagCompound data;
+
+                //noinspection SynchronizationOnLocalVariableOrMethodParameter
+                synchronized (write) {
+                    writeCounter = write.writeCounter;
+                    data = write.data;
+                }
+
+                boolean failedWrite = false;
+
+                try {
+                    this.taskController.writeData(this.x, this.z, data);
+                } catch (final Throwable thr) {
+                    if (thr instanceof ThreadDeath) {
+                        throw (ThreadDeath)thr;
+                    }
+                    LOGGER.fatal("Failed to write chunk data for (" + this.x + "," + this.z + ")", thr);
+                    failedWrite = true;
+                }
+
+                boolean finalFailWrite = failedWrite;
+                boolean[] returnFailWrite = new boolean[] { false };
+
+                ChunkDataTask inMap = this.taskController.tasks.compute(chunkKey, (final Long keyInMap, final ChunkDataTask valueInMap) -> {
+                    if (valueInMap == null) {
+                        throw new IllegalStateException("Write completed concurrently, report this");
+                    }
+                    if (valueInMap != ChunkDataTask.this) {
+                        throw new IllegalStateException("Chunk task mismatch, report this");
+                    }
+                    if (finalFailWrite) {
+                        if (valueInMap.inProgressWrite.writeCounter == writeCounter) {
+                            valueInMap.inProgressWrite.writeCounter = -1L;
+                            returnFailWrite[0] = true;
+                        }
+                        return valueInMap;
+                    }
+                    return valueInMap.inProgressWrite.writeCounter == writeCounter ? null : valueInMap;
+                });
+
+                if (inMap == null || returnFailWrite[0]) {
+                    // write counter matched, so we wrote the most up-to-date pending data, we're done here
+                    // or we failed to write and successfully set the write counter to -1
+                    return; // we're done here
+                }
+
+                // fetch & write new data
+                continue;
+            }
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkGenerateTask.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkGenerateTask.java
new file mode 100644
index 000000000..db0bb1bd1
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkGenerateTask.java
@@ -0,0 +1,15 @@
+package ca.spottedleaf.concrete.chunk.management;
+
+import net.minecraft.server.WorldServer;
+
+final class ChunkGenerateTask extends ChunkTaskHandler.ChunkTask {
+
+    public ChunkGenerateTask(final int priority, final ChunkTaskHandler handler, final WorldServer world, final int chunkX, final int chunkZ) {
+        super(priority, handler, world, chunkX, chunkZ);
+    }
+
+    @Override
+    public void run() {
+
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkLoadOrGenerateTask.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkLoadOrGenerateTask.java
new file mode 100644
index 000000000..09db688be
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkLoadOrGenerateTask.java
@@ -0,0 +1,85 @@
+package ca.spottedleaf.concrete.chunk.management;
+
+import ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread;
+import net.minecraft.server.*;
+
+import java.util.ArrayDeque;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Consumer;
+
+final class ChunkLoadOrGenerateTask extends ChunkTaskHandler.ChunkTask {
+
+    final CompletableFuture<ConcreteFileIOThread.ChunkData> ioLoadFuture;
+    final Consumer<Chunk> onComplete;
+    final boolean generate;
+
+    Chunk chunk;
+    ArrayDeque<Runnable> chunkTasks;
+
+    ChunkLoadOrGenerateTask(final int priority, final ChunkTaskHandler handler, final WorldServer world, final int chunkX, final int chunkZ,
+                                   final Consumer<Chunk> onComplete, final boolean generate) {
+        super(priority, handler, world, chunkX, chunkZ);
+        this.ioLoadFuture = ConcreteFileIOThread.Holder.INSTANCE.loadChunkDataAsyncFuture(world, chunkX, chunkZ, priority, true, true, false);
+        this.onComplete = onComplete;
+        this.generate = generate;
+    }
+
+    /* Note: This task is not actually queued until the IO for it has completed */
+    public static ChunkLoadOrGenerateTask queueChunkLoad(final int priority, final ChunkTaskHandler handler, final WorldServer world, final int chunkX, final int chunkZ,
+                                                         final Consumer<Chunk> onComplete, final boolean generate) {
+        final ChunkLoadOrGenerateTask ret = new ChunkLoadOrGenerateTask(priority, handler, world, chunkX, chunkZ, onComplete, generate);
+
+        ret.ioLoadFuture.thenAccept((final ConcreteFileIOThread.ChunkData chunkData) -> {
+            // TODO schedule load here
+        });
+
+        return ret;
+    }
+
+    private NBTTagCompound applyFixes(final NBTTagCompound compound) {
+
+    }
+
+    @Override
+    public void run() {
+        final ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(this.chunkX, this.chunkZ);
+
+        final ConcreteFileIOThread.ChunkData chunkDataHolder = this.ioLoadFuture.join();
+        final NBTTagCompound chunkData = this.applyFixes(chunkDataHolder.chunkData);
+
+        boolean isChunk = chunkData.hasKeyOfType("Level", 10) && chunkData.getCompound("Level").hasKeyOfType("Status", 8);
+        if (!isChunk) {
+            // TODO
+        }
+
+        final ChunkRegionLoader.InProgressChunkHolder protoChunkHolder = ChunkRegionLoader.loadChunk(this.world, this.handler.definedStructureManager,
+                this.handler.villagePlace, chunkPos, chunkData);
+        final ProtoChunk protoChunk = protoChunkHolder.protoChunk;
+
+        if (protoChunk instanceof ProtoChunkExtension) {
+            this.chunk = ((ProtoChunkExtension)protoChunk).u(); // TODO obfhelper
+            this.chunkTasks = protoChunkHolder.tasks;
+            // at this stage we've got a loaded chunk and now we just need to post to main
+        } else {
+            // TODO schedule chunk generate
+        }
+    }
+
+    // called once we're on main
+    public void loadMainCallback() {
+        this.chunkTasks.forEach(Runnable::run);
+
+    }
+
+    @Override
+    public boolean raisePriority(final int priority) {
+        ConcreteFileIOThread.Holder.INSTANCE.bumpPriority(this.world, this.chunkX, this.chunkZ, priority);
+        return super.raisePriority(priority);
+    }
+
+    @Override
+    public boolean updatePriority(final int priority) {
+        ConcreteFileIOThread.Holder.INSTANCE.setPriority(this.world, this.chunkX, this.chunkZ, priority);
+        return super.updatePriority(priority);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkTaskHandler.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkTaskHandler.java
new file mode 100644
index 000000000..314954935
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkTaskHandler.java
@@ -0,0 +1,75 @@
+package ca.spottedleaf.concrete.chunk.management;
+
+import ca.spottedleaf.concrete.chunk.PrioritizedTaskQueue;
+import com.mojang.datafixers.DataFixer;
+import net.minecraft.server.*;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class ChunkTaskHandler {
+
+    public final ConcreteChunkManager chunkManager;
+    private final PrioritizedTaskQueue<ChunkLoadOrGenerateTask> loadQueue = new PrioritizedTaskQueue<>();
+    private final PrioritizedTaskQueue<ChunkGenerateTask> generateQueue = new PrioritizedTaskQueue<>();
+
+    private final ConcurrentHashMap<Long, ChunkTask> tasksByChunk = new ConcurrentHashMap<>();
+
+    private final ExecutorService loadThreads;
+    private final ExecutorService generateThreads;
+
+    final DataFixer chunkDataFixer;
+
+    public final DefinedStructureManager definedStructureManager;
+    public final VillagePlace villagePlace;
+
+    public ChunkTaskHandler(final ConcreteChunkManager chunkManager, final DataFixer chunkDataFixer, final int loaderThreads, final int generatorThreads) {
+        this.chunkManager = chunkManager;
+        this.chunkDataFixer = chunkDataFixer;
+
+        this.loadThreads = Executors.newFixedThreadPool(loaderThreads, new ThreadFactory() {
+
+            private final AtomicInteger threadCount = new AtomicInteger();
+
+            @Override
+            public Thread newThread(final Runnable runnable) {
+                final Thread ret = new Thread(runnable, "Concrete chunk loader thread #" + this.threadCount.getAndIncrement());
+
+                ret.setPriority(Math.max(ret.getPriority() - 2, Thread.MIN_PRIORITY)); // do not choke the main thread
+
+                return ret;
+            }
+        });
+
+        this.generateThreads = Executors.newFixedThreadPool(generatorThreads, new ThreadFactory() {
+
+            private final AtomicInteger threadCount = new AtomicInteger();
+
+            @Override
+            public Thread newThread(final Runnable runnable) {
+                final Thread ret = new Thread(runnable, "Concrete chunk generator thread #" + this.threadCount.getAndIncrement());
+
+                ret.setPriority(Math.max(ret.getPriority() - 2, Thread.MIN_PRIORITY)); // do not choke the main thread
+
+                return ret;
+            }
+        });
+    }
+
+    abstract static class ChunkTask extends PrioritizedTaskQueue.PrioritizedTask implements Runnable {
+
+        public final ChunkTaskHandler handler;
+
+        public final WorldServer world;
+        public final int chunkX;
+        public final int chunkZ;
+
+        public ChunkTask(final int priority, final ChunkTaskHandler handler, final WorldServer world, final int chunkX, final int chunkZ) {
+            super(priority);
+            this.handler = handler;
+            this.world = world;
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ConcreteChunkManager.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ConcreteChunkManager.java
new file mode 100644
index 000000000..ec00f69cd
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ConcreteChunkManager.java
@@ -0,0 +1,129 @@
+package ca.spottedleaf.concrete.chunk.management;
+
+import ca.spottedleaf.concrete.chunk.ChunkHolder;
+import ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread;
+import ca.spottedleaf.concrete.chunk.management.ticket.ConcreteTicketManager;
+import ca.spottedleaf.concrete.util.Util;
+import com.mojang.datafixers.DataFixer;
+import it.unimi.dsi.fastutil.longs.*;
+import net.minecraft.server.*;
+import org.bukkit.util.Consumer;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import java.io.File;
+
+public class ConcreteChunkManager {
+
+    public final WorldServer world;
+    public final File rootFolder;
+    public final ConcreteTicketManager ticketManager;
+
+    private final ChunkTaskHandler chunkLoader;
+    private final Long2ObjectOpenHashMap<Chunk> loadedChunks = new Long2ObjectOpenHashMap<>(8192 * 2, 0.5f);
+    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> chunkHolders = new Long2ObjectLinkedOpenHashMap<>(8192 * 2, 0.5f);
+    private final Long2LongOpenHashMap unloadQueue = new Long2LongOpenHashMap(8192, 0.5f);
+
+    private long currentTick;
+
+    public ConcreteChunkManager(final WorldServer world, final File rootFolder, final DataFixer chunkDataFixer,
+                                final int chunkLoaderThreads, final int chunkGeneratorThreads) {
+        this.world = world;
+        this.rootFolder = rootFolder;
+        this.chunkLoader = new ChunkTaskHandler(this, chunkDataFixer, chunkLoaderThreads, chunkGeneratorThreads);
+        this.ticketManager = new ConcreteTicketManager(this);
+    }
+
+    public void queueChunkSave(final IChunkAccess chunk, final int ioPriority) {
+        // TODO add obfhelpers
+        // TODO refuse to overwrite stuff on disk if we're a protochunk & disk stuff is levelchunk
+
+        final ChunkCoordIntPair chunkPos = chunk.getPos();
+        final int chunkX = chunkPos.x;
+        final int chunkZ = chunkPos.z;
+
+        final NBTTagCompound poiData = this.world.villagePlaceData.getData(chunkPos);
+
+        final NBTTagCompound chunkData;
+
+        if (!chunk.isNeedsSaving()) {
+            chunkData = null;
+        } else {
+            chunk.setLastSaved(this.world.getTime());
+            chunk.setNeedsSaving(false);
+
+            ChunkStatus chunkstatus = chunk.getChunkStatus();
+
+            if (chunkstatus != ChunkStatus.EMPTY || !chunk.h().values().stream().noneMatch(StructureStart::e)) {
+                chunkData = ChunkRegionLoader.saveChunk(this.world, chunk);
+            } else {
+                chunkData = null; // no point in saving
+            }
+        }
+
+        if (poiData == null && chunkData == null) {
+            return; // nothing to save
+        }
+
+        ConcreteFileIOThread.Holder.INSTANCE.scheduleSave(this.world, chunkX, chunkZ, poiData, chunkData, ioPriority);
+    }
+
+    public void tick() {
+        ++this.currentTick;
+        this.ticketManager.tick();
+        this.parseUnloadQueue();
+
+
+
+    }
+
+    public Iterable<ChunkHolder> getChunkHolders() {
+
+    }
+
+    public ChunkHolder getChunkHolder(final int x, final int z) {
+
+    }
+
+
+    public ChunkHolder getOrCreateChunkHolder(final int x, final int z) {
+
+    }
+
+    public boolean isChunkLoaded(final int x, final int z) {
+        return this.getChunkIfLoaded(x, z) != null;
+    }
+
+    public boolean isChunkGenerated(final int x, final int z) throws RuntimeException {
+
+    }
+
+    @Nullable
+    public Chunk getChunkIfLoaded(final int x, final int z) {
+        return this.loadedChunks.get(Util.getCoordinateKey(x, z));
+    }
+
+    @Nullable
+    public Chunk getChunkIfGenerated(final int x, final int z) {
+
+    }
+
+    @Nonnull
+    public Chunk loadOrGenerate(final int x, final int z) {
+
+    }
+
+    // should ONLY be called through the ticket manager
+    public void queueUnload(final int x, final int z, final short time) {
+        this.unloadQueue.put(Util.getCoordinateKey(x, z), this.currentTick + time);
+    }
+
+    public void removeFromUnloadQueue(final int x, final int z) {
+        this.unloadQueue.remove(Util.getCoordinateKey(x, z));
+    }
+
+    private void parseUnloadQueue() {
+
+    }
+
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteChunkTicket.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteChunkTicket.java
new file mode 100644
index 000000000..1705ef2f9
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteChunkTicket.java
@@ -0,0 +1,158 @@
+package ca.spottedleaf.concrete.chunk.management.ticket;
+
+import net.minecraft.server.Entity;
+import org.bukkit.plugin.Plugin;
+
+import java.util.function.Consumer;
+
+public final class ConcreteChunkTicket<T> {
+
+    public static final long NEVER_EXPIRE = Long.MAX_VALUE;
+
+    public final ConcreteTicketType ticketType;
+    public final int mainRadius; // square radius
+    public final int chunkTickRadius; // square radius
+    public final int entityTickRadius; // square radius
+    public final int cachedRadius; // square radius
+    public final long creationTick;
+    public final long expireTick; // inclusive
+    public final T reason;
+
+    private int chunkX;
+    private int chunkZ;
+    private int nextX;
+    private int nextZ;
+
+    private boolean pendingRemvoal;
+
+    ConcreteChunkTicket(final ConcreteTicketType ticketType, final int mainRadius, final int chunkTickRadius,
+                        final int entityTickRadius, final int cachedRadius, final long creationTick, final long expireTick,
+                        final T reason) {
+        this.ticketType = ticketType;
+        this.mainRadius = mainRadius;
+        this.chunkTickRadius = chunkTickRadius;
+        this.entityTickRadius = entityTickRadius;
+        this.cachedRadius = cachedRadius;
+        this.creationTick = creationTick;
+        this.expireTick = expireTick;
+        this.reason = reason;
+
+        this.ticketType.validate(this);
+        ConcreteChunkTicket.checkRadius(mainRadius, chunkTickRadius, entityTickRadius, cachedRadius);
+    }
+
+    private static void checkRadius(final int mainRadius, final int chunkTickRadius, final int entityTickRadius, final int cachedRadius) {
+        if (mainRadius < cachedRadius || cachedRadius < entityTickRadius || entityTickRadius < chunkTickRadius) {
+            throw new IllegalArgumentException("Invalid radii! Must be: cachedRadius >= mainRadius >= entityTickRadius >= chunkTickRadius");
+        }
+        if (cachedRadius < 0) {
+            throw new IllegalArgumentException("Cached radius must be >= 0");
+        }
+    }
+
+    public int getChunkX() {
+        return this.chunkX;
+    }
+
+    public int getChunkZ() {
+        return this.chunkZ;
+    }
+
+    void updateNext() {
+        if (this.ticketType != ConcreteTicketType.ENTITY) {
+            if (this.ticketType == ConcreteTicketType.PLUGIN) {
+                if (!((Plugin)this.reason).isEnabled()) {
+                    this.remove();
+                    return;
+                }
+            }
+            return;
+        }
+
+        final Entity target = (Entity)this.reason;
+
+        if (target.dead || !target.valid) {
+            this.remove();
+            return;
+        }
+
+        this.nextX = (int)Math.floor(target.locX) >> 4;
+        this.nextZ = (int)Math.floor(target.locZ) >> 4;
+    }
+
+    void updateCurrent() {
+        this.chunkX = this.nextX;
+        this.chunkZ = this.nextZ;
+    }
+
+    public void remove() {
+        this.pendingRemvoal = true; // TODO check prev val?
+    }
+
+    public boolean isPendingRemvoal() {
+        return this.pendingRemvoal;
+    }
+
+    public void move(final int chunkX, final int chunkZ) {
+        this.nextX = chunkX;
+        this.nextZ = chunkZ;
+    }
+
+    @Override
+    public String toString() {
+        return "Ticket: {type=" + this.ticketType.name() + ", reason=" + this.reason + ", main_radius=" + this.mainRadius
+                + ", chunk_tick_radius=" + this.chunkTickRadius + ", entity_tick_radius=" + this.entityTickRadius
+                + ", cached_radius=" + this.cachedRadius + ", creation_tick=" + this.creationTick
+                + ", expire_tick=" + (this.expireTick == NEVER_EXPIRE ? "never" : Long.toString(this.expireTick)) + "}";
+    }
+
+    // chunks without a ticket are considered transient and will be removed eventually
+    public static enum ConcreteTicketType {
+
+        /**
+         * Ticket type which follows the entity's position until it dies. Once the entity dies the ticket is unregistered.
+         */
+        ENTITY((final ConcreteChunkTicket<?> ticket) -> {
+            if (!(ticket.reason instanceof Entity)) {
+                throw new IllegalArgumentException("Reason is invalid, '" + ticket.reason + "', must be an Entity");
+            }
+        }),
+
+        /**
+         * Ticket type for plugins. Once a plugin is disabled all of its tickets are unregistered.
+         */
+        PLUGIN((final ConcreteChunkTicket<?> ticket) -> {
+            if (!(ticket.reason instanceof Plugin)) {
+                throw new IllegalArgumentException("Reason is invalid, '" + ticket.reason + "', must be a Plugin");
+            }
+        }),
+
+        /**
+         * Ticket type for spawn.
+         */
+        SPAWN((final ConcreteChunkTicket<?> ticket) -> {
+            if (ticket.reason != null) {
+                throw new IllegalArgumentException("Reason is invalid, '" + ticket.reason + "', must be null");
+            }
+        }),
+
+        /**
+         * Ambiguous ticket type.
+         */
+        OTHER((final ConcreteChunkTicket<?> ticket) -> {
+            if (ticket.reason == null) {
+                throw new IllegalArgumentException("Reason is invalid '" + "null" + "' must be non-null");
+            }
+        });
+
+        final Consumer<ConcreteChunkTicket<?>> validate;
+
+        ConcreteTicketType(final Consumer<ConcreteChunkTicket<?>> validate) {
+            this.validate = validate;
+        }
+
+        public void validate(final ConcreteChunkTicket<?> ticket) {
+            this.validate.accept(ticket);
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteTicketManager.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteTicketManager.java
new file mode 100644
index 000000000..da1ec7542
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteTicketManager.java
@@ -0,0 +1,262 @@
+package ca.spottedleaf.concrete.chunk.management.ticket;
+
+import ca.spottedleaf.concrete.chunk.ChunkHolder;
+import ca.spottedleaf.concrete.chunk.management.ConcreteChunkManager;
+import ca.spottedleaf.concrete.util.Util;
+import ca.spottedleaf.concurrentutil.util.IntegerUtil;
+import net.minecraft.server.MinecraftServer;
+
+import java.util.ArrayDeque;
+import java.util.Arrays;
+import java.util.function.Predicate;
+
+/**
+ * Chunk ticket management
+ */
+public final class ConcreteTicketManager {
+
+    private final ArrayDeque<ConcreteChunkTicket<?>> pendingAddition = new ArrayDeque<>();
+    private final ConcreteTicketManager.TicketList currentTickets = new ConcreteTicketManager.TicketList();
+
+    public final ConcreteChunkManager chunkManager;
+    public int gcRate = MinecraftServer.TPS * 60;
+    public short unloadDelay = MinecraftServer.TPS * 15;
+
+    private long currentTick;
+
+    public ConcreteTicketManager(final ConcreteChunkManager chunkManager) {
+        this.chunkManager = chunkManager;
+    }
+
+    // should NOT be called more than once in a tick
+    public void tick() {
+        ++this.currentTick;
+
+        this.update();
+
+        if (this.currentTick % this.gcRate == 0) {
+            this.performCleanup();
+        }
+    }
+
+    public void update() {
+        this.handlePending();
+        this.currentTickets.removeIf(this::forceUpdate);
+    }
+
+    // UB if the ticket has not been added yet
+    // returns true if the ticket is pending removal
+    public boolean forceUpdate(final ConcreteChunkTicket<?> ticket) {
+        ticket.updateNext();
+
+        if (ticket.isPendingRemvoal() || ticket.expireTick >= ConcreteTicketManager.this.currentTick) {
+            this.removeTickets(ticket);
+            return true;
+        }
+
+        final int currX = ticket.getChunkX(), currZ = ticket.getChunkZ();
+        ticket.updateCurrent(); // this is a sad excuse to not have getNextX() etc
+        final int nextX = ticket.getChunkX(), nextZ = ticket.getChunkZ();
+
+        if (((currX ^ nextX) | (currZ ^ nextZ)) == 0) {
+            return false; // no change
+        }
+
+        this.handleMove(ticket, currX, currZ, nextX, nextZ);
+
+        return false;
+    }
+
+    public void addTicket(final ConcreteChunkTicket<?> ticket) {
+        this.pendingAddition.add(ticket);
+    }
+
+    public boolean addTicketNow(final ConcreteChunkTicket<?> ticket) {
+        ticket.updateNext();
+        ticket.updateCurrent();
+
+        if (ticket.isPendingRemvoal() || ticket.expireTick <= this.currentTick) {
+            return false;
+        }
+
+        this.assignTickets(ticket);
+
+        return true;
+    }
+
+    private void performCleanup() {
+        for (final ChunkHolder holder : this.chunkManager.getChunkHolders()) {
+            if (!holder.hasTickets()) {
+                this.chunkManager.queueUnload(holder.x, holder.z, (short)0);
+            }
+        }
+    }
+
+    private void assignTickets(final ConcreteChunkTicket<?> ticket) {
+        // add affected chunk holders
+        final int radius = ticket.cachedRadius;
+        final int originX = ticket.getChunkX(), originZ = ticket.getChunkZ();
+
+        // note: cached radius >= main radius
+        for (int dx = -radius; dx <= radius; ++dx) {
+            for (int dz = -radius; dz <= radius; ++dz) {
+                final int chunkX = originX + dx;
+                final int chunkZ = originZ + dz;
+
+                final ChunkHolder holder = this.chunkManager.getOrCreateChunkHolder(chunkX, chunkZ);
+
+                holder.addTicket(ticket);
+                this.chunkManager.removeFromUnloadQueue(chunkX, chunkZ);
+            }
+        }
+    }
+
+    private void handlePending() {
+        ConcreteChunkTicket<?> currTicket;
+        while ((currTicket = this.pendingAddition.poll()) != null) {
+            if (currTicket.isPendingRemvoal() || this.currentTick >= currTicket.expireTick) {
+                continue;
+            }
+
+            currTicket.updateNext();
+            currTicket.updateCurrent();
+
+            this.currentTickets.add(currTicket);
+
+            this.assignTickets(currTicket);
+        }
+    }
+
+    private void removeTickets(final ConcreteChunkTicket<?> ticket) {
+        // remove affected chunk holders
+        final int radius = ticket.cachedRadius;
+        final int originX = ticket.getChunkX(), originZ = ticket.getChunkZ();
+
+        // note: cached radius >= main radius
+        for (int dx = -radius; dx <= radius; ++dx) {
+            for (int dz = -radius; dz <= radius; ++dz) {
+                final ChunkHolder holder = this.chunkManager.getChunkHolder(originX + dz, originZ + dz);
+
+                holder.removeTicket(ticket);
+
+                if (!holder.hasTickets()) {
+                    // Note: Later ticket additions will reverse our unload queue action if necessary.
+                    // We queue unload here to better spread out chunk unloads across ticks, it is not necessary however.
+                    this.chunkManager.queueUnload(holder.x, holder.z, this.unloadDelay);
+                }
+            }
+        }
+    }
+
+    private void handleMove(final ConcreteChunkTicket<?> ticket, final int fromX, final int fromZ, final int toX, final int toZ) {
+        final int dx = toX - fromX;
+        final int dz = toZ - fromZ;
+        final int totalX = IntegerUtil.branchlessAbs(dx);
+        final int totalZ = IntegerUtil.branchlessAbs(dz);
+        final int radius = ticket.cachedRadius;
+
+        if (Util.branchlessMax(totalX, totalZ) > (2 * radius)) {
+            // moved entirely out of the radius (teleport?)
+            this.removeTickets(ticket);
+            this.assignTickets(ticket);
+
+            return;
+        }
+
+        // x axis is width
+        // z axis is height
+        // right refers to the x axis of where we moved
+        // top refers to the z axis of where we moved
+
+        final int up = 1 | (dz >> (Integer.SIZE - 1)); // 1 if dz >= 0, -1 otherwise
+        final int right = 1 | (dx >> (Integer.SIZE - 1)); // 1 if dx >= 0, -1 otherwise
+
+        // up is -1 if we've moved in the negative z direction, 1 if we've moved in the positive
+        final int offsetUp = up * totalZ;
+
+        // right is -1 if we've moved in the negative x direction, 1 if we've moved in the positive
+        final int offsetRight = right * totalX;
+
+        // remove tickets for down
+        for (int xoff = -radius; xoff <= radius; ++xoff) {
+            for (int zoff = -offsetUp; zoff != 0; zoff += up) {
+                // use from* since that's where we were
+                final ChunkHolder holder = this.chunkManager.getChunkHolder(xoff + fromX, zoff + fromX);
+
+                holder.removeTicket(ticket);
+            }
+        }
+
+        // remove tickets for left
+        for (int xoff = -offsetRight; xoff != 0; xoff += right) {
+            for (int zoff = -radius; zoff <= radius; ++zoff) {
+                // use from* since that's where we were
+                final ChunkHolder holder = this.chunkManager.getChunkHolder(xoff + fromX, zoff + fromZ);
+
+                holder.removeTicket(ticket);
+            }
+        }
+
+        // add tickets for up
+        for (int xoff = -radius; xoff <= radius; ++xoff) {
+            for (int zoff = offsetUp; zoff != 0; zoff -= up) {
+                // use to* since that's where we're going
+                final ChunkHolder holder = this.chunkManager.getOrCreateChunkHolder(xoff + toX, zoff + toZ);
+
+                holder.addTicket(ticket);
+
+            }
+        }
+
+        // add tickets for right
+        for (int xoff = offsetRight; xoff != 0; xoff -= right) {
+            for (int zoff = -radius; zoff <= radius; ++zoff) {
+                // use to* since that's where we're going
+                final ChunkHolder holder = this.chunkManager.getOrCreateChunkHolder(xoff + toX, zoff + toZ);
+
+                holder.addTicket(ticket);
+            }
+        }
+    }
+
+    public static final class TicketList {
+
+        private ConcreteChunkTicket<?>[] tickets;
+        private int size;
+
+        public TicketList() {
+            this(16);
+        }
+
+        public TicketList(final int capacity) {
+            this.tickets = new ConcreteChunkTicket[capacity];
+        }
+
+        public void add(final ConcreteChunkTicket<?> ticket) {
+            if (this.size == this.tickets.length) {
+                // copyOf does overflow detection for us :)
+                this.tickets = Arrays.copyOf(this.tickets, this.tickets.length * 2);
+            }
+            this.tickets[this.size++] = ticket;
+        }
+
+        // optimized removeIf function
+        public void removeIf(final Predicate<ConcreteChunkTicket<?>> predicate) {
+            int removed = 0;
+            for (int i = 0, len = this.size; i < len; ++i) {
+                final ConcreteChunkTicket<?> ticket = this.tickets[i];
+                if (predicate.test(ticket)) {
+                    ++removed;
+                } else {
+                    if (removed == 0) { // not necessary, just for performance
+                        continue;
+                    }
+                    this.tickets[i - removed] = ticket;
+                }
+            }
+            Arrays.fill(this.tickets, this.size - removed, this.size, null);
+
+            this.size -= removed;
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/util/Util.java b/src/main/java/ca/spottedleaf/concrete/util/Util.java
index 1282e3fb1..9783f7999 100644
--- a/src/main/java/ca/spottedleaf/concrete/util/Util.java
+++ b/src/main/java/ca/spottedleaf/concrete/util/Util.java
@@ -1,5 +1,6 @@
 package ca.spottedleaf.concrete.util;
 
+import ca.spottedleaf.concurrentutil.util.IntegerUtil;
 import org.bukkit.Bukkit;
 
 public final class Util {
@@ -14,4 +15,52 @@ public final class Util {
 
     }
 
+    // Note: not sure about behavior for x and z close to Integer.MIN_VALUE
+    public static int branchlessAbsMax(final int x, final int z) {
+        final int xa = IntegerUtil.branchlessAbs(x);
+        final int za = IntegerUtil.branchlessAbs(z);
+
+        return branchlessMax(xa, za);
+    }
+
+    // Note: not sure about behavior for x and z close to Integer.MIN_VALUE
+    public static int branchlessMax(final int x, final int z) {
+        final int diff = (x - z);
+
+        final int mask = diff >> (Integer.SIZE - 1); // 0 if za > xa, -1 otherwise
+
+        // (diff & mask) -> 0 if za > xa, else (diff & mask) -> (za - xa)
+        // thus: if za > xa, the following is za - 0, else it is za - (za - xa) -> za - za + xa
+        return z - (diff & mask);
+    }
+
+    // Checks if the two points are in the square radius
+    public static boolean rangeCheck(final int originX, final int originZ, final int toX, final int toZ, final int radius) {
+        return branchlessAbsMax(toX - originX, toZ - originZ) <= radius;
+    }
+
+    public static long getCoordinateKey(final int x, final int z) {
+        return ((long)z << 32) | (x & 0xFFFFFFFFL);
+    }
+
+    public static int getCoordinateX(final long key) {
+        return (int)key;
+    }
+
+    public static int getCoordinateZ(final long key) {
+        return (int)(key >>> 32);
+    }
+
+    public static int getRegionCoordinate(final int chunkCoordinate) {
+        return chunkCoordinate >> 5;
+    }
+
+    public static int getChunkInRegion(final int chunkCoordinate) {
+        return chunkCoordinate & 31;
+    }
+
+    public static String genericToString(final Object object) {
+        return object == null ? "null" : object.getClass().getName() + ":" + object.toString();
+    }
+
 }
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 287f11358..bb1d449c5 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -6,6 +6,7 @@ import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortList;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
+import java.util.ArrayDeque; /* Concrete */
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.EnumSet;
@@ -22,7 +23,21 @@ public class ChunkRegionLoader {
 
     private static final Logger LOGGER = LogManager.getLogger();
 
-    public static ProtoChunk loadChunk(WorldServer worldserver, DefinedStructureManager definedstructuremanager, VillagePlace villageplace, ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) {
+    /* Concrete start - Asynchronous chunk loading */
+    public static final class InProgressChunkHolder {
+
+        public final ProtoChunk protoChunk;
+        public final ArrayDeque<Runnable> tasks;
+
+        public InProgressChunkHolder(final ProtoChunk protoChunk, final ArrayDeque<Runnable> tasks) {
+            this.protoChunk = protoChunk;
+            this.tasks = tasks;
+        }
+    }
+
+    public static InProgressChunkHolder loadChunk(WorldServer worldserver, DefinedStructureManager definedstructuremanager, VillagePlace villageplace, ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) { /* Concrete - Change return type to InProgressChunkHolder from ProtoChunk */
+        ArrayDeque<Runnable> tasksToExecuteOnMain = new ArrayDeque<>();
+        /* Concrete end - Asynchronous chunk loading */
         ChunkGenerator<?> chunkgenerator = worldserver.getChunkProvider().getChunkGenerator();
         WorldChunkManager worldchunkmanager = chunkgenerator.getWorldChunkManager();
         NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Level");
@@ -66,7 +81,9 @@ public class ChunkRegionLoader {
         LightEngine lightengine = chunkproviderserver.getLightEngine();
 
         if (flag) {
+            tasksToExecuteOnMain.add(() -> { /* Concrete - delay this task since we're executing off-main */
             lightengine.b(chunkcoordintpair, true);
+            }); /* Concrete - delay this task since we're executing off-main */
         }
 
         for (int k = 0; k < nbttaglist.size(); ++k) {
@@ -81,17 +98,30 @@ public class ChunkRegionLoader {
                 if (!chunksection.c()) {
                     achunksection[b0] = chunksection;
                 }
-
+                tasksToExecuteOnMain.add(() -> { /* Concrete - delay this task since we're executing off-main */
                 villageplace.a(chunkcoordintpair, chunksection);
+                }); /* Concrete - delay this task since we're executing off-main */
             }
 
             if (flag) {
                 if (nbttagcompound2.hasKeyOfType("BlockLight", 7)) {
-                    lightengine.a(EnumSkyBlock.BLOCK, SectionPosition.a(chunkcoordintpair, b0), new NibbleArray(nbttagcompound2.getByteArray("BlockLight")));
+                    /* Concrete start - delay this task since we're executing off-main */
+                    NibbleArray blockLight = new NibbleArray(nbttagcompound2.getByteArray("BlockLight"));
+                    // Note: We move the block light nibble array creation here for perf & in case the compound is modified
+                    tasksToExecuteOnMain.add(() -> { /* Concrete - delay this task since we're executing off-main */
+                        lightengine.a(EnumSkyBlock.BLOCK, SectionPosition.a(chunkcoordintpair, b0), blockLight);
+                    });
+                    /* Concrete end - delay this task since we're executing off-main */
                 }
 
                 if (flag2 && nbttagcompound2.hasKeyOfType("SkyLight", 7)) {
-                    lightengine.a(EnumSkyBlock.SKY, SectionPosition.a(chunkcoordintpair, b0), new NibbleArray(nbttagcompound2.getByteArray("SkyLight")));
+                    /* Concrete start - delay this task since we're executing off-main */
+                    NibbleArray skyLight = new NibbleArray(nbttagcompound2.getByteArray("SkyLight"));
+                    // Note: We move the block light nibble array creation here for perf & in case the compound is modified
+                    tasksToExecuteOnMain.add(() -> { /* Concrete - delay this task since we're executing off-main */
+                        lightengine.a(EnumSkyBlock.SKY, SectionPosition.a(chunkcoordintpair, b0), skyLight);
+                    });
+                    /* Concrete end - delay this task since we're executing off-main */
                 }
             }
         }
@@ -194,7 +224,7 @@ public class ChunkRegionLoader {
         }
 
         if (chunkstatus_type == ChunkStatus.Type.LEVELCHUNK) {
-            return new ProtoChunkExtension((Chunk) object);
+            return new InProgressChunkHolder(new ProtoChunkExtension((Chunk) object), tasksToExecuteOnMain); /* Concrete */
         } else {
             ProtoChunk protochunk1 = (ProtoChunk) object;
 
@@ -233,7 +263,7 @@ public class ChunkRegionLoader {
                 protochunk1.a(worldgenstage_features, BitSet.valueOf(nbttagcompound5.getByteArray(s1)));
             }
 
-            return protochunk1;
+            return new InProgressChunkHolder(protochunk1, tasksToExecuteOnMain); /* Concrete */
         }
     }
 
@@ -264,9 +294,14 @@ public class ChunkRegionLoader {
 
         for (int i = -1; i < 17; ++i) {
             int finalI = i;
+            /* Concrete start - Why in god's green earth are you using A STREAM over array[i] */
+            /*
             ChunkSection chunksection = (ChunkSection) Arrays.stream(achunksection).filter((chunksection1) -> {
                 return chunksection1 != null && chunksection1.getYPosition() >> 4 == finalI;
             }).findFirst().orElse(Chunk.a);
+             */
+            ChunkSection chunksection = (i & 15) == i ? achunksection[i] : Chunk.a;
+            /* Concrete end - Why in god's green earth are you using A STREAM over array[i] */
             NibbleArray nibblearray = lightenginethreaded.a(EnumSkyBlock.BLOCK).a(SectionPosition.a(chunkcoordintpair, i));
             NibbleArray nibblearray1 = lightenginethreaded.a(EnumSkyBlock.SKY).a(SectionPosition.a(chunkcoordintpair, i));
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 0c535f065..e8b167724 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -658,7 +658,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
 
     public abstract boolean k();
 
-    public boolean saveChunks(boolean flag, boolean flag1, boolean flag2) {
+    public boolean saveChunks(boolean flag, boolean flag1, boolean flag2) { // flag is silent, flag1 is
         boolean flag3 = false;
 
         for (Iterator iterator = this.getWorlds().iterator(); iterator.hasNext(); flag3 = true) {
@@ -764,6 +764,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
             this.getUserCache().c(false); // Paper
         }
         // Spigot end
+        ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.Holder.INSTANCE.close(true); /* Concrete - File IO thread */
     }
 
     public String getServerIp() {
diff --git a/src/main/java/net/minecraft/server/RegionFile.java b/src/main/java/net/minecraft/server/RegionFile.java
index d610253b9..031dbb6c0 100644
--- a/src/main/java/net/minecraft/server/RegionFile.java
+++ b/src/main/java/net/minecraft/server/RegionFile.java
@@ -150,6 +150,11 @@ public class RegionFile implements AutoCloseable {
 
     @Nullable
     public synchronized DataInputStream getReadStream(ChunkCoordIntPair chunkcoordintpair) { return this.a(chunkcoordintpair); } public synchronized DataInputStream a(ChunkCoordIntPair chunkcoordintpair) { // Paper - OBFHELPER
+        /* Concrete start - check thread */
+        if (Thread.currentThread() != ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.Holder.INSTANCE) {
+            MinecraftServer.LOGGER.warn("Some thread is performing IO operations off the IO thread (RegionFile read)", new Throwable());
+        }
+        /* Concrete end - check thread */
         try {
             int i = this.getOffset(chunkcoordintpair);
 
@@ -230,6 +235,11 @@ public class RegionFile implements AutoCloseable {
     }
 
     protected synchronized void a(ChunkCoordIntPair chunkcoordintpair, byte[] abyte, int i) {
+        /* Concrete start - check thread */
+        if (Thread.currentThread() != ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.Holder.INSTANCE) {
+            MinecraftServer.LOGGER.warn("Some thread is performing IO operations off the IO thread (RegionFile write)", new Throwable());
+        }
+        /* Concrete end - check thread */
         try {
             int j = this.getOffset(chunkcoordintpair);
             int k = j >> 8; final int oldSectorOffset = k; // Paper - store variable for later
@@ -327,6 +337,7 @@ public class RegionFile implements AutoCloseable {
         return this.c[this.f(chunkcoordintpair)];
     }
 
+    public boolean chunkExists(ChunkCoordIntPair chunkcoordintpair) { return this.d(chunkcoordintpair); } /* Concrete - OBFHELPER */
     public boolean d(ChunkCoordIntPair chunkcoordintpair) {
         return this.getOffset(chunkcoordintpair) != 0;
     }
@@ -455,7 +466,7 @@ public class RegionFile implements AutoCloseable {
     private static int getChunkIndex(int x, int z) {
         return (x & 31) + (z & 31) * 32;
     }
-    synchronized boolean isOversized(int x, int z) {
+    public synchronized boolean isOversized(int x, int z) { /* Concrete - make public */
         return this.oversized[getChunkIndex(x, z)] == 1;
     }
     synchronized void setOversized(int x, int z, boolean oversized) throws IOException {
@@ -582,4 +593,55 @@ public class RegionFile implements AutoCloseable {
     }
     // Paper end
 
+    /* Concrete start - Reference counter for RegionFile  */
+    private final java.util.concurrent.atomic.AtomicInteger refcount = new java.util.concurrent.atomic.AtomicInteger();
+
+    public boolean tryKillRegionFile() {
+        final int curr = this.refcount.get();
+
+        return curr == 0 && curr == this.refcount.compareAndExchange(0, -1);
+    }
+
+    public int getRefcount() {
+        return this.refcount.get();
+    }
+
+    public boolean acquireReference() {
+        for (int curr = this.refcount.get(), failures = 0;;) {
+            if (curr == -1) {
+                // closing or closed
+                return false;
+            }
+            for (int i = 0; i < failures; ++i) {
+                ca.spottedleaf.concurrentutil.ConcurrentUtil.pause();
+            }
+
+            if (curr == (curr = this.refcount.compareAndExchange(curr, curr + 1))) {
+                return true;
+            }
+
+            ++failures;
+            continue;
+        }
+    }
+
+    public void releaseReference() {
+        for (int curr = this.refcount.get(), failures = 0;;) {
+            if (curr <= 0) {
+                // closing or closed, or not acquired
+                throw new IllegalStateException("Cannot release regionfile that is closed or has no holders!");
+            }
+            for (int i = 0; i < failures; ++i) {
+                ca.spottedleaf.concurrentutil.ConcurrentUtil.pause();
+            }
+
+            if (curr == (curr = this.refcount.compareAndExchange(curr, curr - 1))) {
+                return;
+            }
+
+            ++failures;
+            continue;
+        }
+    }
+    /* Concrete end - Reference counter for RegionFile */
 }
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
index d2b328945..03bdc6d70 100644
--- a/src/main/java/net/minecraft/server/RegionFileCache.java
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -176,7 +176,7 @@ public abstract class RegionFileCache implements AutoCloseable {
     }
 
 
-    private static NBTTagCompound readOversizedChunk(RegionFile regionfile, ChunkCoordIntPair chunkCoordinate) throws IOException {
+    public static NBTTagCompound readOversizedChunk(RegionFile regionfile, ChunkCoordIntPair chunkCoordinate) throws IOException { /* Concrete - make public */
         synchronized (regionfile) {
             try (DataInputStream datainputstream = regionfile.getReadStream(chunkCoordinate)) {
                 // Paper start - Handle bad chunks more gracefully - also handle similarly with oversized data
@@ -283,7 +283,7 @@ public abstract class RegionFileCache implements AutoCloseable {
         return nbttagcompound;
     }
 
-    protected void write(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws IOException {
+    public void write(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws IOException { /* Concrete - protected -> public */
         int attempts = 0; Exception laste = null; while (attempts++ < 5) { try { // Paper
         // Paper start
         this.writeRegion(chunkcoordintpair, nbttagcompound);
diff --git a/src/main/java/net/minecraft/server/RegionFileSection.java b/src/main/java/net/minecraft/server/RegionFileSection.java
index aabfcd04e..5d109832d 100644
--- a/src/main/java/net/minecraft/server/RegionFileSection.java
+++ b/src/main/java/net/minecraft/server/RegionFileSection.java
@@ -94,8 +94,14 @@ public class RegionFileSection<R extends MinecraftSerializable> extends RegionFi
     }
 
     private void b(ChunkCoordIntPair chunkcoordintpair) {
-        this.a(chunkcoordintpair, DynamicOpsNBT.a, this.c(chunkcoordintpair));
+        /* Concrete start - load in data function */
+        this.loadInData(chunkcoordintpair, this.c(chunkcoordintpair));
     }
+    public void loadInData(ChunkCoordIntPair chunkPos, NBTTagCompound compound) {
+        this.a(chunkPos, DynamicOpsNBT.a, compound);
+        /* Concrete end - load in data function */
+    }
+
 
     @Nullable
     private NBTTagCompound c(ChunkCoordIntPair chunkcoordintpair) {
@@ -157,6 +163,20 @@ public class RegionFileSection<R extends MinecraftSerializable> extends RegionFi
 
     }
 
+    /* Concrete start - copied from above */
+    private NBTTagCompound getDataInternal(ChunkCoordIntPair chunkcoordintpair) {
+        Dynamic<NBTBase> dynamic = this.a(chunkcoordintpair, DynamicOpsNBT.a); /* TODO obfhelper */
+        NBTBase nbtbase = (NBTBase) dynamic.getValue();
+
+        if (nbtbase instanceof NBTTagCompound) {
+            return (NBTTagCompound)nbtbase;
+        } else {
+            RegionFileSection.LOGGER.error("Expected compound tag, got {}", nbtbase);
+        }
+        return null;
+    }
+    /* Concrete end - copied from above */
+
     private <T> Dynamic<T> a(ChunkCoordIntPair chunkcoordintpair, DynamicOps<T> dynamicops) {
         Map<T, T> map = Maps.newHashMap();
 
@@ -203,4 +223,21 @@ public class RegionFileSection<R extends MinecraftSerializable> extends RegionFi
         }
 
     }
+
+    /* Concrete start - copied from above */
+    public NBTTagCompound getData(ChunkCoordIntPair chunkcoordintpair) {
+        /* This is checking if the data exists, then it builds it later in getDataInternal(ChunkCoordIntPair) */
+        if (!this.d.isEmpty()) { /* TODO obfhelper */
+            for (int i = 0; i < 16; ++i) {
+                long j = SectionPosition.a(chunkcoordintpair, i).v(); /* TODO obfhelper */
+
+                if (this.d.contains(j)) { /* TODO obfhelper */
+                    return this.getDataInternal(chunkcoordintpair);
+                }
+            }
+        }
+        return null;
+    }
+    /* Concrete end - copied from above */
+
 }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index ccc129525..0a88ceb32 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread;
 import co.aikar.timings.TimingHistory;
 import co.aikar.timings.Timings;
 
@@ -17,6 +18,8 @@ import it.unimi.dsi.fastutil.objects.Object2IntMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
+
+import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -28,6 +31,7 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
+import java.util.function.Function;
 import java.util.function.Predicate;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
@@ -74,6 +78,81 @@ public class WorldServer extends World {
     private static Throwable getAddToWorldStackTrace(Entity entity) {
         return new Throwable(entity + " Added to world at " + new java.util.Date());
     }
+    /* Concrete start - File io thread */
+    public final RegionFileCache regionFileCache;
+    public final VillagePlace villagePlaceData;
+    public final Object persistentStructureLegacyLock = new Object();
+    public PersistentStructureLegacy persistentStructureLegacy;
+
+    public final ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.ChunkDataController poiDataController = new ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.ChunkDataController() {
+        @Override
+        public void writeData(int chunkX, int chunkZ, NBTTagCompound compound) throws IOException {
+            WorldServer.this.villagePlaceData.write(new ChunkCoordIntPair(chunkX, chunkZ), compound);
+        }
+
+        @Override
+        public NBTTagCompound readData(int chunkX, int chunkZ) throws IOException {
+            return WorldServer.this.villagePlaceData.read(new ChunkCoordIntPair(chunkX, chunkZ));
+        }
+
+        @Override
+        public <T> T computeForRegionFile(int chunkX, int chunkZ, Function<RegionFile, T> function) {
+            synchronized (WorldServer.this.villagePlaceData) {
+                RegionFile file;
+
+                try {
+                    file = WorldServer.this.villagePlaceData.getRegionFile(new ChunkCoordIntPair(chunkX, chunkZ), false);
+                } catch (IOException ex) {
+                    throw new RuntimeException(ex);
+                }
+
+                return function.apply(file);
+            }
+        }
+
+        @Override
+        public <T> T computeForRegionFileIfLoaded(int chunkX, int chunkZ, Function<RegionFile, T> function) {
+            synchronized (WorldServer.this.villagePlaceData) {
+                RegionFile file = WorldServer.this.villagePlaceData.getRegionFileIfLoaded(new ChunkCoordIntPair(chunkX, chunkZ));
+                return function.apply(file);
+            }
+        }
+    };
+    public final ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.ChunkDataController chunkDataController = new ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.ChunkDataController() {
+        @Override
+        public void writeData(int chunkX, int chunkZ, NBTTagCompound compound) throws IOException {
+            WorldServer.this.regionFileCache.write(new ChunkCoordIntPair(chunkX, chunkZ), compound);
+        }
+
+        @Override
+        public NBTTagCompound readData(int chunkX, int chunkZ) throws IOException {
+            return WorldServer.this.regionFileCache.read(new ChunkCoordIntPair(chunkX, chunkZ));
+        }
+
+        @Override
+        public <T> T computeForRegionFile(int chunkX, int chunkZ, Function<RegionFile, T> function) {
+            synchronized (WorldServer.this.regionFileCache) {
+                RegionFile file;
+
+                try {
+                    file = WorldServer.this.regionFileCache.getRegionFile(new ChunkCoordIntPair(chunkX, chunkZ), false);
+                } catch (IOException ex) {
+                    throw new RuntimeException(ex);
+                }
+
+                return function.apply(file);
+            }
+        }
+
+        @Override
+        public <T> T computeForRegionFileIfLoaded(int chunkX, int chunkZ, Function<RegionFile, T> function) {
+            synchronized (WorldServer.this.regionFileCache) {
+                RegionFile file = WorldServer.this.regionFileCache.getRegionFileIfLoaded(new ChunkCoordIntPair(chunkX, chunkZ));
+                return function.apply(file);
+            }
+        }
+    };
+    /* Concrete end - File io thread */
 
     // Add env and gen to constructor
     public WorldServer(MinecraftServer minecraftserver, Executor executor, WorldNBTStorage worldnbtstorage, WorldData worlddata, DimensionManager dimensionmanager, GameProfilerFiller gameprofilerfiller, WorldLoadListener worldloadlistener, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen) {
-- 
2.22.0

