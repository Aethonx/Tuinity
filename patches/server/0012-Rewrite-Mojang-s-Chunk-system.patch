From 0a418e25f4d9a963df18e431e7ccac569ed582a4 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Thu, 23 May 2019 15:32:45 -0700
Subject: [PATCH] Rewrite Mojang's Chunk system

WIP
---
 .../concrete/chunk/ChunkHolder.java           |  60 ++
 .../concrete/chunk/PrioritizedTaskQueue.java  | 272 ++++++++
 .../chunk/io/ConcreteFileIOThread.java        | 604 ++++++++++++++++++
 .../chunk/management/ChunkGenerateTask.java   |  15 +
 .../chunk/management/ChunkLoadTask.java       |  61 ++
 .../chunk/management/ChunkTaskHandler.java    |  75 +++
 .../management/ConcreteChunkManager.java      | 114 ++++
 .../ticket/ConcreteChunkTicket.java           | 158 +++++
 .../ticket/ConcreteTicketManager.java         | 258 ++++++++
 .../ca/spottedleaf/concrete/util/Util.java    |  49 ++
 .../minecraft/server/ChunkRegionLoader.java   |   5 +
 .../net/minecraft/server/MinecraftServer.java |   3 +-
 .../java/net/minecraft/server/RegionFile.java |  64 +-
 .../net/minecraft/server/RegionFileCache.java |   4 +-
 .../minecraft/server/RegionFileSection.java   |  31 +
 .../net/minecraft/server/WorldServer.java     |   8 +
 16 files changed, 1777 insertions(+), 4 deletions(-)
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/ChunkHolder.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/PrioritizedTaskQueue.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/io/ConcreteFileIOThread.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkGenerateTask.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkLoadTask.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkTaskHandler.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ConcreteChunkManager.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteChunkTicket.java
 create mode 100644 src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteTicketManager.java

diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/ChunkHolder.java b/src/main/java/ca/spottedleaf/concrete/chunk/ChunkHolder.java
new file mode 100644
index 000000000..9d269a43c
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/ChunkHolder.java
@@ -0,0 +1,60 @@
+package ca.spottedleaf.concrete.chunk;
+
+import ca.spottedleaf.concrete.chunk.management.ticket.ConcreteChunkTicket;
+import ca.spottedleaf.concrete.util.Util;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
+
+public final class ChunkHolder {
+
+    public final int x;
+    public final int z;
+
+    private final ObjectOpenHashSet<ConcreteChunkTicket<?>> ticketsInRangeOf = new ObjectOpenHashSet<>();
+
+    protected ChunkHolder(final int x, final int z) {
+        this.x = x;
+        this.z = z;
+    }
+
+    public void addTicket(final ConcreteChunkTicket<?> ticket) {
+       this.ticketsInRangeOf.add(ticket);
+    }
+
+    public void removeTicket(final ConcreteChunkTicket<?> ticket) {
+        this.ticketsInRangeOf.remove(ticket);
+    }
+
+    public boolean hasTickets() {
+        return !this.ticketsInRangeOf.isEmpty();
+    }
+
+    public boolean canChunkTick() {
+        for (final ConcreteChunkTicket<?> ticket : this.ticketsInRangeOf) {
+            if (Util.rangeCheck(this.x, this.z, ticket.getChunkX(), ticket.getChunkZ(), ticket.chunkTickRadius)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean canEntityTick() {
+        for (final ConcreteChunkTicket<?> ticket : this.ticketsInRangeOf) {
+            if (Util.rangeCheck(this.x, this.z, ticket.getChunkX(), ticket.getChunkZ(), ticket.entityTickRadius)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean isInactive() {
+        for (final ConcreteChunkTicket<?> ticket : this.ticketsInRangeOf) {
+            final int radius = Util.branchlessAbsMax(this.x - ticket.getChunkX(), this.z - ticket.getChunkZ());
+            final int activeRadius = Util.branchlessMax(ticket.chunkTickRadius, ticket.entityTickRadius);
+            if (radius <= activeRadius) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/PrioritizedTaskQueue.java b/src/main/java/ca/spottedleaf/concrete/chunk/PrioritizedTaskQueue.java
new file mode 100644
index 000000000..de4230175
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/PrioritizedTaskQueue.java
@@ -0,0 +1,272 @@
+package ca.spottedleaf.concrete.chunk;
+
+import ca.spottedleaf.concrete.util.Util;
+import ca.spottedleaf.concurrentutil.ConcurrentUtil;
+import ca.spottedleaf.concurrentutil.queue.ConcurrentLinkedList;
+
+import java.lang.invoke.VarHandle;
+
+public class PrioritizedTaskQueue<T extends PrioritizedTaskQueue.PrioritizedTask> {
+
+    // lower numbers are a higher priority (except < 0)
+    // higher priorities are always executed before lower priorities
+
+    /**
+     * Priority value indicating the task has completed or is being completed.
+     */
+    public static final int COMPLETING_PRIORITY   = -1;
+
+    /**
+     * Highest priority, should only be used for main thread tasks or tasks that are blocking the main thread.
+     */
+    public static final int HIGHEST_PRIORITY      = 0;
+
+    /**
+     * Should be only used in an IO task so that chunk loads do not wait on other IO tasks.
+     * This only exists because IO tasks are scheduled before chunk load tasks to decrease IO waiting times.
+     */
+    public static final int HIGHER_PRIORITY       = 1;
+
+    /**
+     * Should be used for scheduling chunk loads/generation that would increase response times to users.
+     */
+    public static final int HIGH_PRIORITY         = 2;
+
+    /**
+     * Default priority.
+     */
+    public static final int NORMAL_PRIORITY       = 3;
+
+    /**
+     * Use for tasks not at all critical and can potentially be delayed.
+     */
+    public static final int LOW_PRIORITY          = 4;
+
+    /**
+     * Use for tasks that should "eventually" execute.
+     */
+    public static final int LOWEST_PRIORITY       = 5;
+
+    private static final int TOTAL_PRIORITIES     = 6;
+
+    final ConcurrentLinkedList<T>[] queues = (ConcurrentLinkedList<T>[])new ConcurrentLinkedList[TOTAL_PRIORITIES];
+
+    {
+        for (int i = 0; i < TOTAL_PRIORITIES; ++i) {
+            this.queues[i] = new ConcurrentLinkedList<>();
+        }
+    }
+
+    /**
+     * Queues a task.
+     * @throws IllegalStateException If the task has already been queued. Use {@link PrioritizedTask#raisePriority(int)} to
+     *                               raise a task's priority.
+     *                               This can also be thrown if the queue has shutdown.
+     */
+    public void add(final T task) throws IllegalStateException {
+        task.onQueue(this);
+        if (!this.queues[task.getPriority()].add(task)) {
+            throw new IllegalStateException("Queue has shutdown, refusing to execute task " + Util.genericToString(task));
+        }
+    }
+
+    /**
+     * Polls the highest priority task currently available. {@code null} if none.
+     */
+    public T poll() {
+        T task;
+        for (int i = 0; i < TOTAL_PRIORITIES; ++i) {
+            final ConcurrentLinkedList<T> queue = this.queues[i];
+
+            while ((task = queue.poll()) != null) {
+                final int prevPriority = task.tryComplete(i);
+                if (prevPriority != COMPLETING_PRIORITY && prevPriority <= i) {
+                    // if the prev priority was greater-than or equal to our current priority
+                    return task;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Prevent further additions to this queue. Attempts to add after this call has completed (potentially during) will
+     * result in {@link IllegalStateException} being thrown.
+     * <p>
+     *     This operation is atomic with respect to other shutdown calls
+     * </p>
+     * <p>
+     *     After this call has completed, regardless of return value, this queue will be shutdown.
+     * </p>
+     * @return {@code true} if the queue was shutdown, {@code false} if it has shut down already
+     */
+    public boolean shutdown() {
+        boolean ret = this.queues[0].preventAdds();
+        for (int i = 1; i < TOTAL_PRIORITIES; ++i) {
+            this.queues[i].preventAdds();
+        }
+        return ret;
+    }
+
+    public abstract static class PrioritizedTask {
+
+        private PrioritizedTaskQueue queue;
+
+        private volatile int priority;
+
+        private static final VarHandle PRIORITY_HANDLE = ConcurrentUtil.getVarHandle(PrioritizedTask.class, "priority", int.class);
+
+        protected PrioritizedTask() {
+            this(PrioritizedTaskQueue.NORMAL_PRIORITY);
+        }
+
+        protected PrioritizedTask(final int priority) {
+            this.setPriorityPlain(priority);
+        }
+
+        /**
+         * Returns the current priority. Note that {@link PrioritizedTaskQueue#COMPLETING_PRIORITY} will be returned
+         * if this task is completing or has completed.
+         */
+        public final int getPriority() {
+            return this.getPriorityVolatile();
+        }
+
+        final int tryComplete(final int minPriority) {
+            if (minPriority < 0 || minPriority >= PrioritizedTaskQueue.TOTAL_PRIORITIES) {
+                throw new IllegalStateException("Invalid priority");
+            }
+
+            for (int curr = this.getPriorityVolatile(), failures = 0;;) {
+                if (curr == COMPLETING_PRIORITY) {
+                    return COMPLETING_PRIORITY;
+                }
+                if (curr > minPriority) {
+                    // curr is lower priority
+                    return curr;
+                }
+
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.pause();
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, minPriority))) {
+                    return curr;
+                }
+                ++failures;
+                continue;
+            }
+        }
+
+        /**
+         * Forces this task to be completed.
+         * @return {@code true} if the task was cancelled, {@code false} if the task has already completed or is being completed.
+         */
+        public boolean cancel() {
+            return this.exchangePriorityVolatile(PrioritizedTaskQueue.COMPLETING_PRIORITY) != PrioritizedTaskQueue.COMPLETING_PRIORITY;
+        }
+
+        /**
+         * Attempts to raise the priority to the priority level specified.
+         * @param priority Priority specified
+         * @return {@code true} if successful, {@code false} otherwise.
+         */
+        public boolean raisePriority(final int priority) {
+            if (priority < 0 || priority >= PrioritizedTaskQueue.TOTAL_PRIORITIES) {
+                throw new IllegalStateException("Invalid priority");
+            }
+
+            final PrioritizedTaskQueue queue = this.queue;
+
+            if (queue == null) {
+                throw new IllegalStateException("Not queued");
+            }
+
+            for (int curr = this.getPriorityVolatile(), failures = 0;;) {
+                if (curr == COMPLETING_PRIORITY) {
+                    return false;
+                }
+                if (priority >= curr) {
+                    return true;
+                }
+
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.pause();
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority))) {
+                    //noinspection unchecked
+                    queue.queues[priority].add(this); // silently fail on shutdown
+                    return true;
+                }
+                ++failures;
+                continue;
+            }
+        }
+
+        /**
+         * Attempts to set this task's priority level to the level specified.
+         * @param priority Specified priority level.
+         * @return {@code true} if successful, {@code false} if this task is completing or has completed.
+         */
+        public boolean updatePriority(final int priority) {
+            if (priority < 0 || priority >= PrioritizedTaskQueue.TOTAL_PRIORITIES) {
+                throw new IllegalStateException("Invalid priority");
+            }
+
+            final PrioritizedTaskQueue queue = this.queue;
+
+            if (queue == null) {
+                throw new IllegalStateException("Not queued");
+            }
+
+            for (int curr = this.getPriorityVolatile(), failures = 0;;) {
+                if (curr == COMPLETING_PRIORITY) {
+                    return false;
+                }
+                if (curr == priority) {
+                    return true;
+                }
+
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.pause();
+                }
+
+                if (curr == (curr = this.compareAndExchangePriorityVolatile(curr, priority))) {
+                    //noinspection unchecked
+                    queue.queues[priority].add(this); // silently fail on shutdown
+                    return true;
+                }
+                ++failures;
+                continue;
+            }
+        }
+
+        void onQueue(final PrioritizedTaskQueue queue) {
+            if (this.queue != null) {
+                throw new IllegalStateException("Already queued!");
+            }
+            this.queue = queue;
+        }
+
+
+        /* priority */
+
+        private final int getPriorityVolatile() {
+            return (int)PRIORITY_HANDLE.getVolatile(this);
+        }
+
+        private final void setPriorityPlain(final int value) {
+            PRIORITY_HANDLE.set(this, value);
+        }
+
+        private final int compareAndExchangePriorityVolatile(final int expect, final int update) {
+            return (int)PRIORITY_HANDLE.compareAndExchange(this, expect, update);
+        }
+
+        private final int exchangePriorityVolatile(final int value) {
+            return (int)PRIORITY_HANDLE.getAndSet(this, value);
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/io/ConcreteFileIOThread.java b/src/main/java/ca/spottedleaf/concrete/chunk/io/ConcreteFileIOThread.java
new file mode 100644
index 000000000..20244c249
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/io/ConcreteFileIOThread.java
@@ -0,0 +1,604 @@
+package ca.spottedleaf.concrete.chunk.io;
+
+import ca.spottedleaf.concrete.chunk.PrioritizedTaskQueue;
+import ca.spottedleaf.concrete.util.Util;
+import ca.spottedleaf.concurrentutil.queue.ConcurrentLinkedList;
+import ca.spottedleaf.concurrentutil.util.Validate;
+import com.destroystokyo.paper.event.server.ServerExceptionEvent;
+import com.destroystokyo.paper.exception.ServerException;
+import net.minecraft.server.*;
+import org.apache.logging.log4j.Logger;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.LockSupport;
+import java.util.function.Consumer;
+
+/**
+ * Prioritized singleton thread responsible for all chunk IO that occurs in a minecraft server.
+ *
+ * <p>
+ *    Singleton access: {@link Holder#INSTANCE}
+ * </p>
+ *
+ * <p>
+ *     All functions provided are MT-Safe, however certain ordering constraints are made for loading and unloading chunks,
+ *     however they are NOT enforced:
+ *     <li>
+ *         Chunk saves may not occur for unloaded chunks.
+ *     </li>
+ * </p>
+ *
+ * @see Holder#INSTANCE
+ * @see #scheduleSave(WorldServer, int, int, NBTTagCompound, NBTTagCompound, int)
+ * @see #loadChunkDataAsync(WorldServer, int, int, int, Consumer, boolean, boolean)
+ */
+public final class ConcreteFileIOThread extends Thread {
+
+    private static final Logger LOGGER = MinecraftServer.LOGGER;
+
+    public static final class Holder {
+
+        public static final ConcreteFileIOThread INSTANCE = new ConcreteFileIOThread();
+
+        static {
+            INSTANCE.start();
+        }
+    }
+
+    private final PrioritizedTaskQueue<PrioritizedTaskQueue.PrioritizedTask> queue = new PrioritizedTaskQueue<>();
+    private final AtomicLong writeCounter = new AtomicLong();
+
+    private volatile boolean closed;
+    private final AtomicBoolean parked = new AtomicBoolean();
+
+    private final ConcurrentLinkedList<Thread> flushQueue = new ConcurrentLinkedList<>();
+    private volatile int flushCounter;
+
+    private ConcreteFileIOThread() {
+        this.setName("Concrete RegionFile IO Thread");
+        this.setPriority(Thread.NORM_PRIORITY - 1); // we keep priority close to normal because threads can wait on us
+        this.setUncaughtExceptionHandler((final Thread unused, final Throwable thr) -> {
+            LOGGER.fatal("Uncaught exception thrown from IO thread, report this!", thr);
+        });
+    }
+
+    @Override
+    public void run() {
+        final long spinWaitTime = (int)(1.0e6); // 1.0ms // TODO tune this
+main_loop:
+        for (;;) {
+            this.pollTasks();
+
+            // spinwait
+
+            final long start = System.nanoTime();
+
+            for (;;) {
+                // If we are interrpted for any reason, park() will always return immediately. Clear so that we don't needlessly use cpu in such an event.
+                Thread.interrupted();
+                LockSupport.parkNanos("Spinwaiting on tasks", 1000L); // 1us
+
+                if (this.pollTasks()) {
+                    continue main_loop;
+                }
+
+                if (this.handleClose()) {
+                    return; // we're done
+                }
+
+                if ((System.nanoTime() - start) >= spinWaitTime) {
+                    break;
+                }
+            }
+
+            if (this.handleClose()) {
+                return;
+            }
+
+            this.parked.set(true);
+            // We need to parse here to avoid a race condition where a thread queues a task before we set parked to true
+            if (this.pollTasks()) {
+                this.parked.set(false);
+                continue;
+            }
+
+            do {
+                Thread.interrupted();
+                LockSupport.park("Waiting on tasks");
+            } while (this.parked.get());
+        }
+    }
+
+    private boolean handleClose() {
+        if (this.closed) {
+            // at this stage no task may be queued
+            this.pollTasks(); // this ensures we've emptied the queue
+            this.handleFlushThreads(true);
+            return true;
+        }
+        return false;
+    }
+
+    private boolean pollTasks() {
+        Runnable task;
+        boolean ret = false;
+
+        while ((task = (Runnable)this.queue.poll()) != null) {
+            ret = true;
+            try {
+                task.run();
+            } catch (final Throwable throwable) {
+                if (throwable instanceof ThreadDeath) {
+                    throw (ThreadDeath)throwable;
+                }
+                LOGGER.fatal("Exception thrown from runnable task in IO thread" + Util.genericToString(task), throwable);
+            }
+        }
+
+        this.handleFlushThreads(false);
+
+        return ret;
+    }
+
+    private void handleFlushThreads(final boolean shutdown) {
+        //noinspection NonAtomicOperationOnVolatileField
+        ++this.flushCounter;
+        this.flushQueue.drain(LockSupport::unpark, shutdown);
+    }
+
+    /**
+     * Schedules the chunk data to be written asynchronously.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     This function presumes a chunk load for the coordinates is not called during this function (anytime after is OK). This means
+     *     saves must be scheduled before a chunk is unloaded.
+     * </li>
+     * <li>
+     *     Writes may be called concurrently, although only the "later" write will go through.
+     * </li>
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param poiData Chunk point of interest data. If {@code null}, then no poi data is saved.
+     * @param chunkData Chunk data. If {@code null}, then no chunk data is saved.
+     * @param priority Priority level for this task. See {@link PrioritizedTaskQueue}
+     * @return The {@link PrioritizedTaskQueue.PrioritizedTask} associated with this task
+     * @throws IllegalArgumentException If both {@code poiData} and {@code chunkData} are {@code null}.
+     */
+    public PrioritizedTaskQueue.PrioritizedTask scheduleSave(final WorldServer world, final int chunkX, final int chunkZ,
+                                                             final NBTTagCompound poiData, final NBTTagCompound chunkData,
+                                                             final int priority) throws IllegalArgumentException {
+        if (poiData == null && chunkData == null) {
+            throw new IllegalArgumentException("poi and chunk data must not both be null");
+        }
+        final long chunkKey = Util.getCoordinateKey(chunkX, chunkZ);
+
+        final long writeCounter = this.writeCounter.getAndAdd(2);
+
+        final long poiWriteCounter = poiData == null ? -1L : writeCounter;
+        final long chunkWriteCounter = chunkData == null ? -1L : writeCounter + 1;
+
+        final ChunkData data = new ChunkData(poiData, chunkData);
+
+        // we push our data to the in progress writes
+        // we do this to prevent ordering issues for following reads and writes (reads will read the cached data,
+        // and writes will not overwrite later data)
+        world.inProgressWrites.compute(Long.valueOf(chunkKey), (final Long keyInMap, final InProgressWrite write) -> {
+            if (write == null) {
+                return new InProgressWrite(new ChunkData(poiData, chunkData), poiWriteCounter, chunkWriteCounter);
+            } else {
+                synchronized (write) {
+                    if (poiWriteCounter != -1L) {
+                        write.writeCounterPoiData = poiWriteCounter;
+                    } else if (chunkWriteCounter != -1L) {
+                        write.writeCounterChunkData = chunkWriteCounter;
+                    }
+                    write.data.merge(poiData, chunkData);
+                    return write;
+                }
+            }
+        });
+
+        final SaveChunkTask ret = new SaveChunkTask(priority, world, chunkX, chunkZ, data, poiWriteCounter, chunkWriteCounter);
+
+        this.queueTask(ret);
+        return ret;
+    }
+
+    /**
+     * Same as {@link #loadChunkDataAsync(WorldServer, int, int, int, Consumer, boolean, boolean)}, except this function returns
+     * a {@link CompletableFuture} which is potentially completed <b>ASYNCHRONOUSLY ON THE FILE IO THREAD</b> when the load task
+     * has completed.
+     * <p>
+     *     Note that if the chunk fails to load the returned future is completed with {@code null}.
+     * </p>
+     */
+    public CompletableFuture<ChunkData> loadChunkDataAsyncFuture(final WorldServer world, final int chunkX, final int chunkZ,
+                                                                 final int priority, final boolean readPoiData, final boolean readChunkData) {
+        final CompletableFuture<ChunkData> future = new CompletableFuture<>();
+        this.loadChunkDataAsync(world, chunkX, chunkZ, priority, future::complete, readPoiData, readChunkData);
+        return future;
+    }
+
+    /**
+     * Schedules a save to be executed asynchronously.
+     * <p>
+     *     Impl notes:
+     * </p>
+     * <li>
+     *     If a chunk fails to load, the {@code onComplete} parameter is completed with {@code null}.
+     * </li>
+     * <li>
+     *     It is possible for the {@code onComplete} parameter to be given {@link ChunkData} containing data
+     *     this call did not request.
+     * </li>
+     * <li>
+     *     The {@code onComplete} parameter may be completed during the execution of this function synchronously or it may
+     *     be completed asynchronously on this file io thread.
+     * </li>
+     * @param world Chunk's world
+     * @param chunkX Chunk's x coordinate
+     * @param chunkZ Chunk's z coordinate
+     * @param priority Priority level for this task. See {@link PrioritizedTaskQueue}
+     * @param onComplete Consumer to execute once this task has completed
+     * @param readPoiData Whether to read point of interest data. If {@code false}, the {@code NBTTagCompound} will be {@code null}.
+     * @param readChunkData Whether to read chunk data. If {@code false}, the {@code NBTTagCompound} will be {@code null}.
+     * @return The {@link PrioritizedTaskQueue.PrioritizedTask} associated with this task
+     */
+    public PrioritizedTaskQueue.PrioritizedTask loadChunkDataAsync(final WorldServer world, final int chunkX, final int chunkZ,
+                                                                   final int priority, final Consumer<ChunkData> onComplete,
+                                                                   final boolean readPoiData, final boolean readChunkData) {
+        if (!(readPoiData | readChunkData)) {
+            throw new IllegalArgumentException("Must read either poi data and/or chunk data");
+        }
+        final ReadChunkTask ret = new ReadChunkTask(priority, world, chunkX, chunkZ, onComplete, readPoiData, readChunkData);
+
+        final InProgressWrite writeInProgress = world.inProgressWrites.get(Long.valueOf(Util.getCoordinateKey(chunkX, chunkZ)));
+        if (writeInProgress != null) {
+            synchronized (writeInProgress) {
+                final NBTTagCompound poiData = writeInProgress.data.poiData;
+                final NBTTagCompound chunkData = writeInProgress.data.chunkData;
+
+                if (!(readPoiData && poiData == null) && !(readChunkData && chunkData == null)) {
+                    ret.cancel();
+                    onComplete.accept(new ChunkData(poiData, chunkData));
+
+                    return ret;
+                }
+                // fall through to queue if the current cached data isn't enough
+            }
+        }
+
+        this.queueTask(ret);
+        return ret;
+    }
+
+    /**
+     * Same as {@link #loadChunkDataAsync(WorldServer, int, int, int, Consumer, boolean, boolean)}, except this function returns
+     * the {@link ChunkData} associated with the specified chunk when the task is complete.
+     * @return The chunk data, or {@code null} if the chunk failed to load.
+     */
+    public ChunkData loadChunkData(final WorldServer world, final int chunkX, final int chunkZ, final int priority,
+                                   final boolean readPoiData, final boolean readChunkData) {
+        return this.loadChunkDataAsyncFuture(world, chunkX, chunkZ, priority, readPoiData, readChunkData).join();
+    }
+
+    /**
+     * Schedules the given task at the specified priority to be executed on the IO thread.
+     * <p>
+     *     Internal api. Do not use.
+     * </p>
+     */
+    public void runTask(final int priority, final Runnable runnable) {
+        this.queueTask(new GeneralTask(priority, runnable));
+    }
+
+    private void queueTask(final PrioritizedTaskQueue.PrioritizedTask task) {
+        this.queue.add(task);
+        if (this.parked.get() && this.parked.getAndSet(false)) {
+            LockSupport.unpark(this);
+        }
+    }
+
+    /**
+     * Waits until the IO thread's queue is empty.
+     *
+     * @throws IllegalStateException If the current thread is the IO thread
+     */
+    public void flush() {
+        final Thread currentThread = Thread.currentThread();
+
+        if (currentThread == this) {
+            throw new IllegalStateException("Cannot flush while on the IO thread");
+        }
+
+        // order is important
+
+        if (this.parked.get()) {
+            return; // no tasks queued
+        }
+
+        int flushCounter = this.flushCounter;
+
+        if (!this.flushQueue.add(currentThread)) {
+            return;
+        }
+
+        // re-check parked status
+        if (this.parked.get()) {
+            return;
+        }
+
+        // force a response from the IO thread, we're not sure of its state currently
+        this.parked.set(false);
+        LockSupport.unpark(this);
+
+        boolean interrupted = false; // preserve interrupted status
+
+        while (this.flushCounter == flushCounter) {
+            interrupted |= Thread.interrupted();
+            LockSupport.park();
+        }
+
+        if (interrupted) {
+            Thread.currentThread().interrupt();
+        }
+    }
+
+    /**
+     * Closes the IO thread and optionally waits until it is finished with its queued tasks.
+     * @param wait If this call is to wait until the IO thread has emptied the task queue
+     * @return {@code true} if the IO thread was shutdown, {@code false} if it already is
+     */
+    public boolean close(final boolean wait) {
+        boolean ret = this.queue.shutdown();
+        this.closed = true;
+        if (wait) {
+            this.flush();
+        }
+        return ret;
+    }
+
+    // we do not do any optimizing around chaining read tasks looking at the same chunk data since the chunk management will
+    // not try to double load a chunk.
+    static final class ReadChunkTask extends PrioritizedTaskQueue.PrioritizedTask implements Runnable {
+
+        private final int chunkX;
+        private final int chunkZ;
+        private final WorldServer world;
+
+        private final Consumer<ChunkData> onComplete;
+
+        private final boolean readPoiData;
+        private final boolean readChunkData;
+
+        public ReadChunkTask(final int priority, final WorldServer world, final int chunkX, final int chunkZ, final Consumer<ChunkData> onComplete,
+                             final boolean readPoiData, final boolean readChunkData) {
+            super(priority);
+            this.world = world;
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+            this.onComplete = onComplete;
+            this.readPoiData = readPoiData;
+            this.readChunkData = readChunkData;
+        }
+
+        @Override
+        public void run() {
+            final long chunkKey = Util.getCoordinateKey(this.chunkX, this.chunkZ);
+            final ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(this.chunkX, this.chunkZ);
+
+            NBTTagCompound poiData = null;
+            NBTTagCompound chunkData = null;
+
+            final ConcreteFileIOThread.InProgressWrite writeInProgress = this.world.inProgressWrites.get(Long.valueOf(chunkKey));
+
+            if (writeInProgress != null) {
+                synchronized (writeInProgress) {
+                    poiData = writeInProgress.data.poiData;
+                    chunkData = writeInProgress.data.chunkData;
+                }
+                // fall through to null checks
+            }
+
+            // TODO this mess of trycatch is serious cancer
+
+            try {
+                if (poiData == null && this.readPoiData) {
+                    poiData = this.world.villagePlaceData.read(chunkPos);
+                }
+                if (chunkData == null && this.readChunkData) {
+                    chunkData = this.world.regionFileCache.read(chunkPos);
+                }
+                final ChunkData complete = new ChunkData(poiData, chunkData);
+                try {
+                    this.onComplete.accept(complete);
+                } catch (final Throwable throwable) {
+                    if (throwable instanceof ThreadDeath) {
+                        throw (ThreadDeath)throwable;
+                    }
+                    LOGGER.fatal("Failed to complete chunk data for chunk (" + this.chunkX + "," + this.chunkZ + "):", throwable);
+                    MinecraftServer.getServer().scheduleOnMain(() -> {
+                        new ServerExceptionEvent(new ServerException(throwable)).callEvent(); // TODO async?
+                    });
+                }
+            } catch (final Throwable throwable) {
+                try {
+                    this.onComplete.accept(null);
+                } catch (final Throwable thr2) {
+                    if (thr2 instanceof ThreadDeath) {
+                        throw (ThreadDeath)thr2;
+                    }
+                    LOGGER.fatal("Failed to complete chunk data for chunk (" + this.chunkX + "," + this.chunkZ + "):", thr2);
+                    MinecraftServer.getServer().scheduleOnMain(() -> {
+                        new ServerExceptionEvent(new ServerException(thr2)).callEvent(); // TODO async?
+                    });
+                    // fall through to report the other exception
+                }
+                if (throwable instanceof ThreadDeath) {
+                    throw (ThreadDeath)throwable;
+                }
+                LOGGER.fatal("Failed to read chunk data for chunk (" + this.chunkX + "," + this.chunkZ + "):", throwable);
+                MinecraftServer.getServer().scheduleOnMain(() -> {
+                    new ServerExceptionEvent(new ServerException(throwable)).callEvent(); // TODO async?
+                });
+            }
+        }
+    }
+
+    static final class SaveChunkTask extends PrioritizedTaskQueue.PrioritizedTask implements Runnable {
+
+        private final int chunkX;
+        private final int chunkZ;
+        private final WorldServer world;
+
+        private final ChunkData data;
+
+        private final long expectedPoiCounter;
+        private final long expectedChunkCounter;
+
+        public SaveChunkTask(final int priority, final WorldServer world, final int chunkX, final int chunkZ,
+                             final ChunkData data, final long poiWriteCounter, final long chunkWriteCounter) {
+            super(priority);
+            this.world = world;
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+            this.data = data;
+            this.expectedPoiCounter = poiWriteCounter;
+            this.expectedChunkCounter = chunkWriteCounter;
+        }
+
+        @Override
+        public void run() {
+            final Long boxedChunkKey = Long.valueOf(Util.getCoordinateKey(this.chunkX, this.chunkZ));
+            final ConcreteFileIOThread.InProgressWrite writeInProgress;
+
+            NBTTagCompound poiData = this.data.poiData;
+            NBTTagCompound chunkData = this.data.chunkData;
+
+            if ((writeInProgress = this.world.inProgressWrites.get(boxedChunkKey)) == null) {
+                // return here, a write has already completed with more-up-to-date data
+                return;
+            }
+
+            // this can be replaced with atomic reads of the write counters
+            synchronized (writeInProgress) {
+                if (writeInProgress.writeCounterPoiData != this.expectedPoiCounter) {
+                    poiData = null; // invalidate write, we've been overwritten
+                }
+                if (writeInProgress.writeCounterChunkData != this.expectedChunkCounter) {
+                    chunkData = null; // invalidate write, we've been overwritten
+                }
+            }
+
+            try {
+                this.world.checkSession();
+            } catch (ExceptionWorldConflict exceptionworldconflict) {
+                LOGGER.error("Couldn't save chunk; already in use by another instance of Minecraft?", exceptionworldconflict);
+                MinecraftServer.getServer().scheduleOnMain(() -> {
+                    com.destroystokyo.paper.exception.ServerInternalException.reportInternalException(exceptionworldconflict); // Paper // TODO async?
+                });
+            }
+
+            final ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(this.chunkX, this.chunkZ);
+
+            try {
+                if (poiData != null) {
+                    this.world.villagePlaceData.write(chunkPos, poiData);
+                }
+                if (chunkData != null) {
+                    this.world.regionFileCache.write(chunkPos, chunkData);
+                }
+            } catch (final Exception ex) {
+                LOGGER.fatal("Failed to write chunk data for (" + this.chunkX + "," + this.chunkZ + ")! Keeping data loaded", ex);
+                MinecraftServer.getServer().scheduleOnMain(() -> {
+                    new ServerExceptionEvent(new ServerException(ex)).callEvent(); // TODO async?
+                });
+                return; // refuse to unload the nbt compound to avoid data loss
+            }
+
+            // we need to remove our data if possible to prevent a memory leak.
+            // we can't remove it if a task queued for later will.
+            this.world.inProgressWrites.compute(boxedChunkKey, (final Long keyInMap, final ConcreteFileIOThread.InProgressWrite write) -> {
+                if (write == null) {
+                    LOGGER.fatal("Concurrent write completed, please report this", new Throwable());
+                    return null;
+                }
+                synchronized (write) {
+                    return write.checkAndInvalidate(SaveChunkTask.this.expectedPoiCounter, SaveChunkTask.this.expectedChunkCounter) ? null : write;
+                }
+            });
+        }
+    }
+
+    public static final class ChunkData {
+
+        public NBTTagCompound poiData;
+        public NBTTagCompound chunkData;
+
+        public ChunkData(final NBTTagCompound poiData, final NBTTagCompound chunkData) {
+            this.poiData = poiData;
+            this.chunkData = chunkData;
+        }
+
+        public void merge(final NBTTagCompound newPoiData, final NBTTagCompound newChunkData) {
+            if (newPoiData != null) {
+                this.poiData = newPoiData;
+            } else if (newChunkData != null) {
+                this.chunkData = newChunkData;
+            }
+        }
+    }
+
+    public static final class InProgressWrite {
+        protected long writeCounterPoiData;
+        protected long writeCounterChunkData;
+
+        protected final ChunkData data;
+
+        public InProgressWrite(final ChunkData data, final long writeCounterPoiData,
+                               final long writeCounterChunkData) {
+            this.writeCounterPoiData = writeCounterPoiData;
+            this.writeCounterChunkData = writeCounterChunkData;
+            this.data = data;
+        }
+
+        public boolean checkAndInvalidate(final long poiCounter, final long chunkCounter) {
+            if (this.writeCounterPoiData == poiCounter) {
+                this.writeCounterPoiData = -1L;
+                this.data.poiData = null;
+            }
+            if (this.writeCounterChunkData == chunkCounter) {
+                this.writeCounterChunkData = -1L;
+                this.data.chunkData = null;
+            }
+            return (this.writeCounterPoiData & this.writeCounterChunkData) == -1L;
+        }
+    }
+
+    public static class GeneralTask extends PrioritizedTaskQueue.PrioritizedTask implements Runnable {
+
+        private final Runnable run;
+
+        public GeneralTask(final int priority, final Runnable run) {
+            super(priority);
+            this.run = Validate.notNull(run, "Task may not be null");
+        }
+
+        @Override
+        public void run() {
+            try {
+                this.run.run();
+            } catch (final Throwable throwable) {
+                if (throwable instanceof ThreadDeath) {
+                    throw (ThreadDeath)throwable;
+                }
+                LOGGER.fatal("Failed to execute general task on IO thread " + Util.genericToString(this.run), throwable);
+            }
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkGenerateTask.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkGenerateTask.java
new file mode 100644
index 000000000..db0bb1bd1
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkGenerateTask.java
@@ -0,0 +1,15 @@
+package ca.spottedleaf.concrete.chunk.management;
+
+import net.minecraft.server.WorldServer;
+
+final class ChunkGenerateTask extends ChunkTaskHandler.ChunkTask {
+
+    public ChunkGenerateTask(final int priority, final ChunkTaskHandler handler, final WorldServer world, final int chunkX, final int chunkZ) {
+        super(priority, handler, world, chunkX, chunkZ);
+    }
+
+    @Override
+    public void run() {
+
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkLoadTask.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkLoadTask.java
new file mode 100644
index 000000000..a69512b37
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkLoadTask.java
@@ -0,0 +1,61 @@
+package ca.spottedleaf.concrete.chunk.management;
+
+import ca.spottedleaf.concrete.chunk.PrioritizedTaskQueue;
+import ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread;
+import net.minecraft.server.*;
+
+import java.net.ProtocolException;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Consumer;
+
+final class ChunkLoadTask extends ChunkTaskHandler.ChunkTask {
+
+    final CompletableFuture<ConcreteFileIOThread.ChunkData> ioLoadFuture;
+    final PrioritizedTaskQueue.PrioritizedTask ioLoadTask;
+    final Consumer<Chunk> onComplete;
+    final boolean generate;
+
+    Chunk chunk;
+
+    public ChunkLoadTask(final int priority, final ChunkTaskHandler handler, final WorldServer world, final int chunkX, final int chunkZ,
+                         final Consumer<Chunk> onComplete, final boolean generate) {
+        super(priority, handler, world, chunkX, chunkZ);
+        this.ioLoadFuture = new CompletableFuture<>();
+        this.ioLoadTask = ConcreteFileIOThread.Holder.INSTANCE.loadChunkDataAsync(world, chunkX, chunkZ, priority, this.ioLoadFuture::complete, true, true);
+        this.onComplete = onComplete;
+        this.generate = generate;
+    }
+
+    private NBTTagCompound applyFixes(final NBTTagCompound compound) {
+
+    }
+
+    @Override
+    public void run() {
+        this.ioLoadTask.raisePriority(PrioritizedTaskQueue.HIGHER_PRIORITY);
+
+        final ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(this.chunkX, this.chunkZ);
+
+        final ConcreteFileIOThread.ChunkData chunkDataHolder = this.ioLoadFuture.join();
+        final NBTTagCompound chunkData = this.applyFixes(chunkDataHolder.chunkData);
+
+        boolean isChunk = chunkData.hasKeyOfType("Level", 10) && chunkData.getCompound("Level").hasKeyOfType("Status", 8);
+        if (!isChunk) {
+            // TODO
+        }
+
+        final ProtoChunk protoChunk = ChunkRegionLoader.loadChunk(this.world, this.handler.definedStructureManager,
+                this.handler.villagePlace, chunkPos, chunkData); // TODO make MT-Safe
+
+        if (protoChunk instanceof ProtoChunkExtension) {
+            this.chunk = ((ProtoChunkExtension)protoChunk).u(); // TODO obfhelper
+        } else {
+            // TODO schedule chunk generate
+        }
+    }
+
+    // called once we're on main
+    private void loadMainCallback() {
+
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkTaskHandler.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkTaskHandler.java
new file mode 100644
index 000000000..97d0e1736
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ChunkTaskHandler.java
@@ -0,0 +1,75 @@
+package ca.spottedleaf.concrete.chunk.management;
+
+import ca.spottedleaf.concrete.chunk.PrioritizedTaskQueue;
+import com.mojang.datafixers.DataFixer;
+import net.minecraft.server.*;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class ChunkTaskHandler {
+
+    public final ConcreteChunkManager chunkManager;
+    private final PrioritizedTaskQueue<ChunkLoadTask> loadQueue = new PrioritizedTaskQueue<>();
+    private final PrioritizedTaskQueue<ChunkGenerateTask> generateQueue = new PrioritizedTaskQueue<>();
+
+    private final ConcurrentHashMap<Long, ChunkTask> tasksByChunk = new ConcurrentHashMap<>();
+
+    private final ExecutorService loadThreads;
+    private final ExecutorService generateThreads;
+
+    final DataFixer chunkDataFixer;
+
+    public final DefinedStructureManager definedStructureManager;
+    public final VillagePlace villagePlace;
+
+    public ChunkTaskHandler(final ConcreteChunkManager chunkManager, final DataFixer chunkDataFixer, final int loaderThreads, final int generatorThreads) {
+        this.chunkManager = chunkManager;
+        this.chunkDataFixer = chunkDataFixer;
+
+        this.loadThreads = Executors.newFixedThreadPool(loaderThreads, new ThreadFactory() {
+
+            private final AtomicInteger threadCount = new AtomicInteger();
+
+            @Override
+            public Thread newThread(final Runnable runnable) {
+                final Thread ret = new Thread(runnable, "Concrete chunk loader thread #" + this.threadCount.getAndIncrement());
+
+                ret.setPriority(Math.max(ret.getPriority() - 2, Thread.MIN_PRIORITY)); // do not choke the main thread
+
+                return ret;
+            }
+        });
+
+        this.generateThreads = Executors.newFixedThreadPool(generatorThreads, new ThreadFactory() {
+
+            private final AtomicInteger threadCount = new AtomicInteger();
+
+            @Override
+            public Thread newThread(final Runnable runnable) {
+                final Thread ret = new Thread(runnable, "Concrete chunk generator thread #" + this.threadCount.getAndIncrement());
+
+                ret.setPriority(Math.max(ret.getPriority() - 2, Thread.MIN_PRIORITY)); // do not choke the main thread
+
+                return ret;
+            }
+        });
+    }
+
+    abstract static class ChunkTask extends PrioritizedTaskQueue.PrioritizedTask implements Runnable {
+
+        public final ChunkTaskHandler handler;
+
+        public final WorldServer world;
+        public final int chunkX;
+        public final int chunkZ;
+
+        public ChunkTask(final int priority, final ChunkTaskHandler handler, final WorldServer world, final int chunkX, final int chunkZ) {
+            super(priority);
+            this.handler = handler;
+            this.world = world;
+            this.chunkX = chunkX;
+            this.chunkZ = chunkZ;
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ConcreteChunkManager.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ConcreteChunkManager.java
new file mode 100644
index 000000000..3601dfaf5
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ConcreteChunkManager.java
@@ -0,0 +1,114 @@
+package ca.spottedleaf.concrete.chunk.management;
+
+import ca.spottedleaf.concrete.chunk.ChunkHolder;
+import ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread;
+import ca.spottedleaf.concrete.chunk.management.ticket.ConcreteTicketManager;
+import ca.spottedleaf.concrete.util.Util;
+import com.mojang.datafixers.DataFixer;
+import it.unimi.dsi.fastutil.longs.*;
+import net.minecraft.server.*;
+import org.bukkit.util.Consumer;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import java.io.File;
+
+public class ConcreteChunkManager {
+
+    public final WorldServer world;
+    public final File rootFolder;
+    public final ConcreteTicketManager ticketManager;
+
+    private final ChunkTaskHandler chunkLoader;
+    private final Long2ObjectOpenHashMap<Chunk> loadedChunks = new Long2ObjectOpenHashMap<>(8192 * 2, 0.5f);
+    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> chunkHolders = new Long2ObjectLinkedOpenHashMap<>(8192 * 2, 0.5f);
+    private final Long2ShortOpenHashMap unloadQueue = new Long2ShortOpenHashMap(8192, 0.5f);
+
+    public ConcreteChunkManager(final WorldServer world, final File rootFolder, final DataFixer chunkDataFixer,
+                                final int chunkLoaderThreads, final int chunkGeneratorThreads) {
+        this.world = world;
+        this.rootFolder = rootFolder;
+        this.chunkLoader = new ChunkTaskHandler(this, chunkDataFixer, chunkLoaderThreads, chunkGeneratorThreads);
+        this.ticketManager = new ConcreteTicketManager(this);
+    }
+
+    public void queueChunkSave(final IChunkAccess chunk, final int ioPriority) {
+        // TODO add obfhelpers
+        // TODO refuse to overwrite stuff on disk if we're a protochunk & disk stuff is levelchunk
+
+        final ChunkCoordIntPair chunkPos = chunk.getPos();
+        final int chunkX = chunkPos.x;
+        final int chunkZ = chunkPos.z;
+
+        final NBTTagCompound poiData = this.world.villagePlaceData.getData(chunkPos);
+
+        final NBTTagCompound chunkData;
+
+        if (!chunk.isNeedsSaving()) {
+            chunkData = null;
+        } else {
+            chunk.setLastSaved(this.world.getTime());
+            chunk.setNeedsSaving(false);
+
+            ChunkStatus chunkstatus = chunk.getChunkStatus();
+
+            if (chunkstatus != ChunkStatus.EMPTY || !chunk.h().values().stream().noneMatch(StructureStart::e)) {
+                chunkData = ChunkRegionLoader.saveChunk(this.world, chunk);
+            } else {
+                chunkData = null; // no point in saving
+            }
+        }
+
+        if (poiData == null && chunkData == null) {
+            return; // nothing to save
+        }
+
+        ConcreteFileIOThread.Holder.INSTANCE.scheduleSave(this.world, chunkX, chunkZ, poiData, chunkData, ioPriority);
+    }
+
+    public void tick() {
+        this.ticketManager.tick();
+    }
+
+    public Iterable<ChunkHolder> getChunkHolders() {
+
+    }
+
+    public ChunkHolder getChunkHolder(final int x, final int z) {
+
+    }
+
+
+    public ChunkHolder getOrCreateChunkHolder(final int x, final int z) {
+
+    }
+
+    public boolean isChunkLoaded(final int x, final int z) {
+        return this.getChunkIfLoaded(x, z) != null;
+    }
+
+    public boolean isChunkGenerated(final int x, final int z) throws RuntimeException {
+
+    }
+
+    @Nullable
+    public Chunk getChunkIfLoaded(final int x, final int z) {
+        return this.loadedChunks.get(Util.getCoordinateKey(x, z));
+    }
+
+    @Nullable
+    public Chunk getChunkIfGenerated(final int x, final int z) {
+
+    }
+
+    @Nonnull
+    public Chunk loadOrGenerate(final int x, final int z) {
+
+    }
+
+    // should ONLY be called through the ticket manager
+    public void queueUnload(final int x, final int z, final short time) {
+        this.unloadQueue.put(Util.getCoordinateKey(x, z), time);
+    }
+
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteChunkTicket.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteChunkTicket.java
new file mode 100644
index 000000000..1705ef2f9
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteChunkTicket.java
@@ -0,0 +1,158 @@
+package ca.spottedleaf.concrete.chunk.management.ticket;
+
+import net.minecraft.server.Entity;
+import org.bukkit.plugin.Plugin;
+
+import java.util.function.Consumer;
+
+public final class ConcreteChunkTicket<T> {
+
+    public static final long NEVER_EXPIRE = Long.MAX_VALUE;
+
+    public final ConcreteTicketType ticketType;
+    public final int mainRadius; // square radius
+    public final int chunkTickRadius; // square radius
+    public final int entityTickRadius; // square radius
+    public final int cachedRadius; // square radius
+    public final long creationTick;
+    public final long expireTick; // inclusive
+    public final T reason;
+
+    private int chunkX;
+    private int chunkZ;
+    private int nextX;
+    private int nextZ;
+
+    private boolean pendingRemvoal;
+
+    ConcreteChunkTicket(final ConcreteTicketType ticketType, final int mainRadius, final int chunkTickRadius,
+                        final int entityTickRadius, final int cachedRadius, final long creationTick, final long expireTick,
+                        final T reason) {
+        this.ticketType = ticketType;
+        this.mainRadius = mainRadius;
+        this.chunkTickRadius = chunkTickRadius;
+        this.entityTickRadius = entityTickRadius;
+        this.cachedRadius = cachedRadius;
+        this.creationTick = creationTick;
+        this.expireTick = expireTick;
+        this.reason = reason;
+
+        this.ticketType.validate(this);
+        ConcreteChunkTicket.checkRadius(mainRadius, chunkTickRadius, entityTickRadius, cachedRadius);
+    }
+
+    private static void checkRadius(final int mainRadius, final int chunkTickRadius, final int entityTickRadius, final int cachedRadius) {
+        if (mainRadius < cachedRadius || cachedRadius < entityTickRadius || entityTickRadius < chunkTickRadius) {
+            throw new IllegalArgumentException("Invalid radii! Must be: cachedRadius >= mainRadius >= entityTickRadius >= chunkTickRadius");
+        }
+        if (cachedRadius < 0) {
+            throw new IllegalArgumentException("Cached radius must be >= 0");
+        }
+    }
+
+    public int getChunkX() {
+        return this.chunkX;
+    }
+
+    public int getChunkZ() {
+        return this.chunkZ;
+    }
+
+    void updateNext() {
+        if (this.ticketType != ConcreteTicketType.ENTITY) {
+            if (this.ticketType == ConcreteTicketType.PLUGIN) {
+                if (!((Plugin)this.reason).isEnabled()) {
+                    this.remove();
+                    return;
+                }
+            }
+            return;
+        }
+
+        final Entity target = (Entity)this.reason;
+
+        if (target.dead || !target.valid) {
+            this.remove();
+            return;
+        }
+
+        this.nextX = (int)Math.floor(target.locX) >> 4;
+        this.nextZ = (int)Math.floor(target.locZ) >> 4;
+    }
+
+    void updateCurrent() {
+        this.chunkX = this.nextX;
+        this.chunkZ = this.nextZ;
+    }
+
+    public void remove() {
+        this.pendingRemvoal = true; // TODO check prev val?
+    }
+
+    public boolean isPendingRemvoal() {
+        return this.pendingRemvoal;
+    }
+
+    public void move(final int chunkX, final int chunkZ) {
+        this.nextX = chunkX;
+        this.nextZ = chunkZ;
+    }
+
+    @Override
+    public String toString() {
+        return "Ticket: {type=" + this.ticketType.name() + ", reason=" + this.reason + ", main_radius=" + this.mainRadius
+                + ", chunk_tick_radius=" + this.chunkTickRadius + ", entity_tick_radius=" + this.entityTickRadius
+                + ", cached_radius=" + this.cachedRadius + ", creation_tick=" + this.creationTick
+                + ", expire_tick=" + (this.expireTick == NEVER_EXPIRE ? "never" : Long.toString(this.expireTick)) + "}";
+    }
+
+    // chunks without a ticket are considered transient and will be removed eventually
+    public static enum ConcreteTicketType {
+
+        /**
+         * Ticket type which follows the entity's position until it dies. Once the entity dies the ticket is unregistered.
+         */
+        ENTITY((final ConcreteChunkTicket<?> ticket) -> {
+            if (!(ticket.reason instanceof Entity)) {
+                throw new IllegalArgumentException("Reason is invalid, '" + ticket.reason + "', must be an Entity");
+            }
+        }),
+
+        /**
+         * Ticket type for plugins. Once a plugin is disabled all of its tickets are unregistered.
+         */
+        PLUGIN((final ConcreteChunkTicket<?> ticket) -> {
+            if (!(ticket.reason instanceof Plugin)) {
+                throw new IllegalArgumentException("Reason is invalid, '" + ticket.reason + "', must be a Plugin");
+            }
+        }),
+
+        /**
+         * Ticket type for spawn.
+         */
+        SPAWN((final ConcreteChunkTicket<?> ticket) -> {
+            if (ticket.reason != null) {
+                throw new IllegalArgumentException("Reason is invalid, '" + ticket.reason + "', must be null");
+            }
+        }),
+
+        /**
+         * Ambiguous ticket type.
+         */
+        OTHER((final ConcreteChunkTicket<?> ticket) -> {
+            if (ticket.reason == null) {
+                throw new IllegalArgumentException("Reason is invalid '" + "null" + "' must be non-null");
+            }
+        });
+
+        final Consumer<ConcreteChunkTicket<?>> validate;
+
+        ConcreteTicketType(final Consumer<ConcreteChunkTicket<?>> validate) {
+            this.validate = validate;
+        }
+
+        public void validate(final ConcreteChunkTicket<?> ticket) {
+            this.validate.accept(ticket);
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteTicketManager.java b/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteTicketManager.java
new file mode 100644
index 000000000..85ffec778
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/chunk/management/ticket/ConcreteTicketManager.java
@@ -0,0 +1,258 @@
+package ca.spottedleaf.concrete.chunk.management.ticket;
+
+import ca.spottedleaf.concrete.chunk.ChunkHolder;
+import ca.spottedleaf.concrete.chunk.management.ConcreteChunkManager;
+import ca.spottedleaf.concrete.util.Util;
+import ca.spottedleaf.concurrentutil.util.IntegerUtil;
+import net.minecraft.server.MinecraftServer;
+
+import java.util.ArrayDeque;
+import java.util.Arrays;
+import java.util.function.Predicate;
+
+/**
+ * Chunk ticket management
+ */
+public final class ConcreteTicketManager {
+
+    private final ArrayDeque<ConcreteChunkTicket<?>> pendingAddition = new ArrayDeque<>();
+    private final ConcreteTicketManager.TicketList currentTickets = new ConcreteTicketManager.TicketList();
+
+    public final ConcreteChunkManager chunkManager;
+    public int gcRate = MinecraftServer.TPS * 60;
+    public short unloadDelay = MinecraftServer.TPS * 15;
+
+    private long currentTick;
+
+    public ConcreteTicketManager(final ConcreteChunkManager chunkManager) {
+        this.chunkManager = chunkManager;
+    }
+
+    // should NOT be called more than once in a tick
+    public void tick() {
+        ++this.currentTick;
+
+        this.update();
+
+        if (this.currentTick % this.gcRate == 0) {
+            this.performCleanup();
+        }
+    }
+
+    public void update() {
+        this.handlePending();
+        this.currentTickets.removeIf(this::forceUpdate);
+    }
+
+    // UB if the ticket has not been added yet
+    // returns true if the ticket is pending removal
+    public boolean forceUpdate(final ConcreteChunkTicket<?> ticket) {
+        ticket.updateNext();
+
+        if (ticket.isPendingRemvoal() || ticket.expireTick >= ConcreteTicketManager.this.currentTick) {
+            this.removeTickets(ticket);
+            return true;
+        }
+
+        final int currX = ticket.getChunkX(), currZ = ticket.getChunkZ();
+        ticket.updateCurrent(); // this is a sad excuse to not have getNextX() etc
+        final int nextX = ticket.getChunkX(), nextZ = ticket.getChunkZ();
+
+        if (((currX ^ nextX) | (currZ ^ nextZ)) == 0) {
+            return false; // no change
+        }
+
+        this.handleMove(ticket, currX, currZ, nextX, nextZ);
+
+        return false;
+    }
+
+    public void addTicket(final ConcreteChunkTicket<?> ticket) {
+        this.pendingAddition.add(ticket);
+    }
+
+    public boolean addTicketNow(final ConcreteChunkTicket<?> ticket) {
+        ticket.updateNext();
+        ticket.updateCurrent();
+
+        if (ticket.isPendingRemvoal() || ticket.expireTick <= this.currentTick) {
+            return false;
+        }
+
+        this.assignTickets(ticket);
+
+        return true;
+    }
+
+    private void performCleanup() {
+        for (final ChunkHolder holder : this.chunkManager.getChunkHolders()) {
+            if (!holder.hasTickets()) {
+                this.chunkManager.queueUnload(holder.x, holder.z, (short)0);
+            }
+        }
+    }
+
+    private void assignTickets(final ConcreteChunkTicket<?> ticket) {
+        // add affected chunk holders
+        final int radius = ticket.cachedRadius;
+        final int originX = ticket.getChunkX(), originZ = ticket.getChunkZ();
+
+        // note: cached radius >= main radius
+        for (int dx = -radius; dx <= radius; ++dx) {
+            for (int dz = -radius; dz <= radius; ++dz) {
+                final ChunkHolder holder = this.chunkManager.getOrCreateChunkHolder(originX + dx, originZ + dz);
+
+                holder.addTicket(ticket);
+            }
+        }
+    }
+
+    private void handlePending() {
+        ConcreteChunkTicket<?> currTicket;
+        while ((currTicket = this.pendingAddition.poll()) != null) {
+            if (currTicket.isPendingRemvoal() || this.currentTick >= currTicket.expireTick) {
+                continue;
+            }
+
+            currTicket.updateNext();
+            currTicket.updateCurrent();
+
+            this.currentTickets.add(currTicket);
+
+            this.assignTickets(currTicket);
+        }
+    }
+
+    private void removeTickets(final ConcreteChunkTicket<?> ticket) {
+        // remove affected chunk holders
+        final int radius = ticket.cachedRadius;
+        final int originX = ticket.getChunkX(), originZ = ticket.getChunkZ();
+
+        // note: cached radius >= main radius
+        for (int dx = -radius; dx <= radius; ++dx) {
+            for (int dz = -radius; dz <= radius; ++dz) {
+                final ChunkHolder holder = this.chunkManager.getChunkHolder(originX + dz, originZ + dz);
+
+                holder.removeTicket(ticket);
+
+                if (!holder.hasTickets()) {
+                    // Note: Later ticket additions will reverse our unload queue action if necessary.
+                    // We queue unload here to better spread out chunk unloads across ticks, it is not necessary however.
+                    this.chunkManager.queueUnload(holder.x, holder.z, this.unloadDelay);
+                }
+            }
+        }
+    }
+
+    private void handleMove(final ConcreteChunkTicket<?> ticket, final int fromX, final int fromZ, final int toX, final int toZ) {
+        final int dx = toX - fromX;
+        final int dz = toZ - fromZ;
+        final int totalX = IntegerUtil.branchlessAbs(dx);
+        final int totalZ = IntegerUtil.branchlessAbs(dz);
+        final int radius = ticket.cachedRadius;
+
+        if (Util.branchlessMax(totalX, totalZ) > (2 * radius)) {
+            // moved entirely out of the radius (teleport?)
+            this.removeTickets(ticket);
+            this.assignTickets(ticket);
+
+            return;
+        }
+
+        // x axis is width
+        // z axis is height
+        // right refers to the x axis of where we moved
+        // top refers to the z axis of where we moved
+
+        final int up = 1 | (dz >> (Integer.SIZE - 1)); // 1 if dz >= 0, -1 otherwise
+        final int right = 1 | (dx >> (Integer.SIZE - 1)); // 1 if dx >= 0, -1 otherwise
+
+        // up is -1 if we've moved in the negative z direction, 1 if we've moved in the positive
+        final int offsetUp = up * totalZ;
+
+        // right is -1 if we've moved in the negative x direction, 1 if we've moved in the positive
+        final int offsetRight = right * totalX;
+
+        // remove tickets for down
+        for (int xoff = -radius; xoff <= radius; ++xoff) {
+            for (int zoff = -offsetUp; zoff != 0; zoff += up) {
+                // use from* since that's where we were
+                final ChunkHolder holder = this.chunkManager.getChunkHolder(xoff + fromX, zoff + fromX);
+
+                holder.removeTicket(ticket);
+            }
+        }
+
+        // remove tickets for left
+        for (int xoff = -offsetRight; xoff != 0; xoff += right) {
+            for (int zoff = -radius; zoff <= radius; ++zoff) {
+                // use from* since that's where we were
+                final ChunkHolder holder = this.chunkManager.getChunkHolder(xoff + fromX, zoff + fromZ);
+
+                holder.removeTicket(ticket);
+            }
+        }
+
+        // add tickets for up
+        for (int xoff = -radius; xoff <= radius; ++xoff) {
+            for (int zoff = offsetUp; zoff != 0; zoff -= up) {
+                // use to* since that's where we're going
+                final ChunkHolder holder = this.chunkManager.getOrCreateChunkHolder(xoff + toX, zoff + toZ);
+
+                holder.addTicket(ticket);
+
+            }
+        }
+
+        // add tickets for right
+        for (int xoff = offsetRight; xoff != 0; xoff -= right) {
+            for (int zoff = -radius; zoff <= radius; ++zoff) {
+                // use to* since that's where we're going
+                final ChunkHolder holder = this.chunkManager.getOrCreateChunkHolder(xoff + toX, zoff + toZ);
+
+                holder.addTicket(ticket);
+            }
+        }
+    }
+
+    public static final class TicketList {
+
+        private ConcreteChunkTicket<?>[] tickets;
+        private int size;
+
+        public TicketList() {
+            this(16);
+        }
+
+        public TicketList(final int capacity) {
+            this.tickets = new ConcreteChunkTicket[capacity];
+        }
+
+        public void add(final ConcreteChunkTicket<?> ticket) {
+            if (this.size == this.tickets.length) {
+                // copyOf does overflow detection for us :)
+                this.tickets = Arrays.copyOf(this.tickets, this.tickets.length * 2);
+            }
+            this.tickets[this.size++] = ticket;
+        }
+
+        // optimized removeIf function
+        public void removeIf(final Predicate<ConcreteChunkTicket<?>> predicate) {
+            int removed = 0;
+            for (int i = 0, len = this.size; i < len; ++i) {
+                final ConcreteChunkTicket<?> ticket = this.tickets[i];
+                if (predicate.test(ticket)) {
+                    ++removed;
+                } else {
+                    if (removed == 0) { // not necessary, just for performance
+                        continue;
+                    }
+                    this.tickets[i - removed] = ticket;
+                }
+            }
+            Arrays.fill(this.tickets, this.size - removed, this.size, null);
+
+            this.size -= removed;
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/util/Util.java b/src/main/java/ca/spottedleaf/concrete/util/Util.java
index 1282e3fb1..9783f7999 100644
--- a/src/main/java/ca/spottedleaf/concrete/util/Util.java
+++ b/src/main/java/ca/spottedleaf/concrete/util/Util.java
@@ -1,5 +1,6 @@
 package ca.spottedleaf.concrete.util;
 
+import ca.spottedleaf.concurrentutil.util.IntegerUtil;
 import org.bukkit.Bukkit;
 
 public final class Util {
@@ -14,4 +15,52 @@ public final class Util {
 
     }
 
+    // Note: not sure about behavior for x and z close to Integer.MIN_VALUE
+    public static int branchlessAbsMax(final int x, final int z) {
+        final int xa = IntegerUtil.branchlessAbs(x);
+        final int za = IntegerUtil.branchlessAbs(z);
+
+        return branchlessMax(xa, za);
+    }
+
+    // Note: not sure about behavior for x and z close to Integer.MIN_VALUE
+    public static int branchlessMax(final int x, final int z) {
+        final int diff = (x - z);
+
+        final int mask = diff >> (Integer.SIZE - 1); // 0 if za > xa, -1 otherwise
+
+        // (diff & mask) -> 0 if za > xa, else (diff & mask) -> (za - xa)
+        // thus: if za > xa, the following is za - 0, else it is za - (za - xa) -> za - za + xa
+        return z - (diff & mask);
+    }
+
+    // Checks if the two points are in the square radius
+    public static boolean rangeCheck(final int originX, final int originZ, final int toX, final int toZ, final int radius) {
+        return branchlessAbsMax(toX - originX, toZ - originZ) <= radius;
+    }
+
+    public static long getCoordinateKey(final int x, final int z) {
+        return ((long)z << 32) | (x & 0xFFFFFFFFL);
+    }
+
+    public static int getCoordinateX(final long key) {
+        return (int)key;
+    }
+
+    public static int getCoordinateZ(final long key) {
+        return (int)(key >>> 32);
+    }
+
+    public static int getRegionCoordinate(final int chunkCoordinate) {
+        return chunkCoordinate >> 5;
+    }
+
+    public static int getChunkInRegion(final int chunkCoordinate) {
+        return chunkCoordinate & 31;
+    }
+
+    public static String genericToString(final Object object) {
+        return object == null ? "null" : object.getClass().getName() + ":" + object.toString();
+    }
+
 }
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 287f11358..c4a26d186 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -264,9 +264,14 @@ public class ChunkRegionLoader {
 
         for (int i = -1; i < 17; ++i) {
             int finalI = i;
+            /* Concrete start - Why in god's green earth are you using A STREAM over array[i] */
+            /*
             ChunkSection chunksection = (ChunkSection) Arrays.stream(achunksection).filter((chunksection1) -> {
                 return chunksection1 != null && chunksection1.getYPosition() >> 4 == finalI;
             }).findFirst().orElse(Chunk.a);
+             */
+            ChunkSection chunksection = (i & 15) == i ? achunksection[i] : Chunk.a;
+            /* Concrete end - Why in god's green earth are you using A STREAM over array[i] */
             NibbleArray nibblearray = lightenginethreaded.a(EnumSkyBlock.BLOCK).a(SectionPosition.a(chunkcoordintpair, i));
             NibbleArray nibblearray1 = lightenginethreaded.a(EnumSkyBlock.SKY).a(SectionPosition.a(chunkcoordintpair, i));
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 0c535f065..e8b167724 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -658,7 +658,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
 
     public abstract boolean k();
 
-    public boolean saveChunks(boolean flag, boolean flag1, boolean flag2) {
+    public boolean saveChunks(boolean flag, boolean flag1, boolean flag2) { // flag is silent, flag1 is
         boolean flag3 = false;
 
         for (Iterator iterator = this.getWorlds().iterator(); iterator.hasNext(); flag3 = true) {
@@ -764,6 +764,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
             this.getUserCache().c(false); // Paper
         }
         // Spigot end
+        ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.Holder.INSTANCE.close(true); /* Concrete - File IO thread */
     }
 
     public String getServerIp() {
diff --git a/src/main/java/net/minecraft/server/RegionFile.java b/src/main/java/net/minecraft/server/RegionFile.java
index d610253b9..031dbb6c0 100644
--- a/src/main/java/net/minecraft/server/RegionFile.java
+++ b/src/main/java/net/minecraft/server/RegionFile.java
@@ -150,6 +150,11 @@ public class RegionFile implements AutoCloseable {
 
     @Nullable
     public synchronized DataInputStream getReadStream(ChunkCoordIntPair chunkcoordintpair) { return this.a(chunkcoordintpair); } public synchronized DataInputStream a(ChunkCoordIntPair chunkcoordintpair) { // Paper - OBFHELPER
+        /* Concrete start - check thread */
+        if (Thread.currentThread() != ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.Holder.INSTANCE) {
+            MinecraftServer.LOGGER.warn("Some thread is performing IO operations off the IO thread (RegionFile read)", new Throwable());
+        }
+        /* Concrete end - check thread */
         try {
             int i = this.getOffset(chunkcoordintpair);
 
@@ -230,6 +235,11 @@ public class RegionFile implements AutoCloseable {
     }
 
     protected synchronized void a(ChunkCoordIntPair chunkcoordintpair, byte[] abyte, int i) {
+        /* Concrete start - check thread */
+        if (Thread.currentThread() != ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.Holder.INSTANCE) {
+            MinecraftServer.LOGGER.warn("Some thread is performing IO operations off the IO thread (RegionFile write)", new Throwable());
+        }
+        /* Concrete end - check thread */
         try {
             int j = this.getOffset(chunkcoordintpair);
             int k = j >> 8; final int oldSectorOffset = k; // Paper - store variable for later
@@ -327,6 +337,7 @@ public class RegionFile implements AutoCloseable {
         return this.c[this.f(chunkcoordintpair)];
     }
 
+    public boolean chunkExists(ChunkCoordIntPair chunkcoordintpair) { return this.d(chunkcoordintpair); } /* Concrete - OBFHELPER */
     public boolean d(ChunkCoordIntPair chunkcoordintpair) {
         return this.getOffset(chunkcoordintpair) != 0;
     }
@@ -455,7 +466,7 @@ public class RegionFile implements AutoCloseable {
     private static int getChunkIndex(int x, int z) {
         return (x & 31) + (z & 31) * 32;
     }
-    synchronized boolean isOversized(int x, int z) {
+    public synchronized boolean isOversized(int x, int z) { /* Concrete - make public */
         return this.oversized[getChunkIndex(x, z)] == 1;
     }
     synchronized void setOversized(int x, int z, boolean oversized) throws IOException {
@@ -582,4 +593,55 @@ public class RegionFile implements AutoCloseable {
     }
     // Paper end
 
+    /* Concrete start - Reference counter for RegionFile  */
+    private final java.util.concurrent.atomic.AtomicInteger refcount = new java.util.concurrent.atomic.AtomicInteger();
+
+    public boolean tryKillRegionFile() {
+        final int curr = this.refcount.get();
+
+        return curr == 0 && curr == this.refcount.compareAndExchange(0, -1);
+    }
+
+    public int getRefcount() {
+        return this.refcount.get();
+    }
+
+    public boolean acquireReference() {
+        for (int curr = this.refcount.get(), failures = 0;;) {
+            if (curr == -1) {
+                // closing or closed
+                return false;
+            }
+            for (int i = 0; i < failures; ++i) {
+                ca.spottedleaf.concurrentutil.ConcurrentUtil.pause();
+            }
+
+            if (curr == (curr = this.refcount.compareAndExchange(curr, curr + 1))) {
+                return true;
+            }
+
+            ++failures;
+            continue;
+        }
+    }
+
+    public void releaseReference() {
+        for (int curr = this.refcount.get(), failures = 0;;) {
+            if (curr <= 0) {
+                // closing or closed, or not acquired
+                throw new IllegalStateException("Cannot release regionfile that is closed or has no holders!");
+            }
+            for (int i = 0; i < failures; ++i) {
+                ca.spottedleaf.concurrentutil.ConcurrentUtil.pause();
+            }
+
+            if (curr == (curr = this.refcount.compareAndExchange(curr, curr - 1))) {
+                return;
+            }
+
+            ++failures;
+            continue;
+        }
+    }
+    /* Concrete end - Reference counter for RegionFile */
 }
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
index d2b328945..03bdc6d70 100644
--- a/src/main/java/net/minecraft/server/RegionFileCache.java
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -176,7 +176,7 @@ public abstract class RegionFileCache implements AutoCloseable {
     }
 
 
-    private static NBTTagCompound readOversizedChunk(RegionFile regionfile, ChunkCoordIntPair chunkCoordinate) throws IOException {
+    public static NBTTagCompound readOversizedChunk(RegionFile regionfile, ChunkCoordIntPair chunkCoordinate) throws IOException { /* Concrete - make public */
         synchronized (regionfile) {
             try (DataInputStream datainputstream = regionfile.getReadStream(chunkCoordinate)) {
                 // Paper start - Handle bad chunks more gracefully - also handle similarly with oversized data
@@ -283,7 +283,7 @@ public abstract class RegionFileCache implements AutoCloseable {
         return nbttagcompound;
     }
 
-    protected void write(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws IOException {
+    public void write(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws IOException { /* Concrete - protected -> public */
         int attempts = 0; Exception laste = null; while (attempts++ < 5) { try { // Paper
         // Paper start
         this.writeRegion(chunkcoordintpair, nbttagcompound);
diff --git a/src/main/java/net/minecraft/server/RegionFileSection.java b/src/main/java/net/minecraft/server/RegionFileSection.java
index aabfcd04e..080070475 100644
--- a/src/main/java/net/minecraft/server/RegionFileSection.java
+++ b/src/main/java/net/minecraft/server/RegionFileSection.java
@@ -157,6 +157,20 @@ public class RegionFileSection<R extends MinecraftSerializable> extends RegionFi
 
     }
 
+    /* Concrete start - copied from above */
+    private NBTTagCompound getDataInternal(ChunkCoordIntPair chunkcoordintpair) {
+        Dynamic<NBTBase> dynamic = this.a(chunkcoordintpair, DynamicOpsNBT.a); /* TODO obfhelper */
+        NBTBase nbtbase = (NBTBase) dynamic.getValue();
+
+        if (nbtbase instanceof NBTTagCompound) {
+            return (NBTTagCompound)nbtbase;
+        } else {
+            RegionFileSection.LOGGER.error("Expected compound tag, got {}", nbtbase);
+        }
+        return null;
+    }
+    /* Concrete end - copied from above */
+
     private <T> Dynamic<T> a(ChunkCoordIntPair chunkcoordintpair, DynamicOps<T> dynamicops) {
         Map<T, T> map = Maps.newHashMap();
 
@@ -203,4 +217,21 @@ public class RegionFileSection<R extends MinecraftSerializable> extends RegionFi
         }
 
     }
+
+    /* Concrete start - copied from above */
+    public NBTTagCompound getData(ChunkCoordIntPair chunkcoordintpair) {
+        /* This is checking if the data exists, then it builds it later in getDataInternal(ChunkCoordIntPair) */
+        if (!this.d.isEmpty()) { /* TODO obfhelper */
+            for (int i = 0; i < 16; ++i) {
+                long j = SectionPosition.a(chunkcoordintpair, i).v(); /* TODO obfhelper */
+
+                if (this.d.contains(j)) { /* TODO obfhelper */
+                    return this.getDataInternal(chunkcoordintpair);
+                }
+            }
+        }
+        return null;
+    }
+    /* Concrete end - copied from above */
+
 }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index ccc129525..cbedcefa7 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -74,6 +74,14 @@ public class WorldServer extends World {
     private static Throwable getAddToWorldStackTrace(Entity entity) {
         return new Throwable(entity + " Added to world at " + new java.util.Date());
     }
+    /* Concrete start - File io thread */
+    public final RegionFileCache regionFileCache;
+    public final VillagePlace villagePlaceData;
+    public final Object persistentStructureLegacyLock = new Object();
+    public PersistentStructureLegacy persistentStructureLegacy;
+
+    public final java.util.concurrent.ConcurrentHashMap<Long, ca.spottedleaf.concrete.chunk.io.ConcreteFileIOThread.InProgressWrite> inProgressWrites = new java.util.concurrent.ConcurrentHashMap<>(64, 0.5f);
+    /* Concrete end - File io thread */
 
     // Add env and gen to constructor
     public WorldServer(MinecraftServer minecraftserver, Executor executor, WorldNBTStorage worldnbtstorage, WorldData worlddata, DimensionManager dimensionmanager, GameProfilerFiller gameprofilerfiller, WorldLoadListener worldloadlistener, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen) {
-- 
2.22.0

