From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sat, 21 Sep 2019 00:44:19 -0700
Subject: [PATCH] Per player view distance implementation

This patch implements CraftPlayer#setViewDistance and
CraftPlayer#getViewDistance

This patch replaces the existing system to handle player tickets
and chunk sending to players.
 Most of the work is pulled by two
PlayerAreaMap's controlling: a radius for sending chunks and a radius
for adding player tickets. Currently the difference between the two
radii is just 1.
Normal vanilla has a difference of two, but this
causes issues where outer chunks in the view distance sometimes
do not send. This is because the outer radius is not guaranteed to
be at ticket level 32, which is required to be sent to players.

THe ticket manager in ChunkMapDistance for players is no longer used and
is entirely replaced by the ticket distance map.

This patch moves the order of the distance map update in movePlayer
until after a client is sent a center section packet. This is required
to avoid the client rejecting chunks it receives when teleporting.

diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 91b744ea6beee592d35253e7d768a4f807a3ab36..cf4dc00eae102bbb1323b12c0f4e917f738ec4cb 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import ca.spottedleaf.concrete.util.Util; /* Concrete */
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Either;
@@ -35,7 +36,7 @@ public abstract class ChunkMapDistance {
     public final Long2ObjectOpenHashMap<ObjectSortedSet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap(); // CraftBukkit - private -> public
     private final ChunkMapDistance.a e = new ChunkMapDistance.a();
     private final ChunkMapDistance.b f = new ChunkMapDistance.b(8);
-    private final ChunkMapDistance.c g = new ChunkMapDistance.c(33);
+    //private final ChunkMapDistance.c g = new ChunkMapDistance.c(33); /* Concrete - no longer used */
     private final java.util.Queue<PlayerChunk> pendingChunkUpdates = new java.util.LinkedList<>(); // PAIL pendingChunkUpdates // Paper - use a queue
     private final ChunkTaskQueueSorter i;
     private final Mailbox<ChunkTaskQueueSorter.a<Runnable>> j;
@@ -44,6 +45,11 @@ public abstract class ChunkMapDistance {
     private final Executor m;
     private long currentTick;
 
+    /* Concrete start */
+    protected PlayerChunkMap chunkMap;
+    protected final ChunkMapDistance.TicketTracker playerTicketHandler = new TicketTracker();
+    /* Concrete end */
+
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
         Mailbox<Runnable> mailbox = Mailbox.a("player ticket throttler", executor1::execute);
@@ -96,7 +102,7 @@ public abstract class ChunkMapDistance {
 
     public boolean a(PlayerChunkMap playerchunkmap) {
         this.f.a();
-        this.g.a();
+        //this.g.a(); /* Concrete - no longer used */
         int i = Integer.MAX_VALUE - this.e.a(Integer.MAX_VALUE);
         boolean flag = i != 0;
 
@@ -239,7 +245,7 @@ public abstract class ChunkMapDistance {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
         this.f.b(i, 0, true);
-        this.g.b(i, 0, true);
+        //this.g.b(i, 0, true); /* Concrete - no longer used */
     }
 
     public void b(SectionPosition sectionposition, EntityPlayer entityplayer) {
@@ -251,7 +257,7 @@ public abstract class ChunkMapDistance {
         if (objectset.isEmpty()) {
             this.c.remove(i);
             this.f.b(i, Integer.MAX_VALUE, false);
-            this.g.b(i, Integer.MAX_VALUE, false);
+            //this.g.b(i, Integer.MAX_VALUE, false); /* Concrete - no longer used */
         }
 
     }
@@ -269,9 +275,16 @@ public abstract class ChunkMapDistance {
         return s;
     }
 
+    protected void setViewDistance(int viewDistance) { this.a(viewDistance); } /* Concrete - OBFHELPER */
     protected void a(int i) {
-        this.g.a(i);
+        //this.g.a(i); /* Concrete - no longer used */
     }
+    /* Concrete start - per player view distance */
+    protected void setGlobalViewDistance(int viewDistance, PlayerChunkMap chunkMap) {
+        this.chunkMap = chunkMap;
+        this.setViewDistance(viewDistance);
+    }
+    /* Concrete end */
 
     public int b() {
         this.f.a();
@@ -353,6 +366,48 @@ public abstract class ChunkMapDistance {
         }
     }
 
+    /* Concrete start - Per player view distance */
+    class TicketTracker {
+
+        // this is copied from ChunkMapDistance.c(long, int, boolean, boolean)
+
+        // this is invoked if and only if there are no other players in range of the chunk.
+        public void playerMoveInRange(final int chunkX, final int chunkZ, final int fromX, final int fromZ) {
+            final long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+
+            final int dist = Math.max(Math.abs(chunkX - fromX), Math.abs(chunkZ - fromZ));
+            Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, ChunkMapDistance.b, new ChunkCoordIntPair(chunkX, chunkZ), ChunkMapDistance.this.currentTick);
+
+            ChunkMapDistance.this.j.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
+                ChunkMapDistance.this.m.execute(() -> {
+                    if (ChunkMapDistance.this.chunkMap.playerViewDistanceTicketMap.getObjectsInRange(coordinate) != null) {
+                        ChunkMapDistance.this.addTicket(coordinate, ticket);
+                        ChunkMapDistance.this.l.add(coordinate);
+                    } else {
+                        ChunkMapDistance.this.k.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
+                        }, coordinate, false));
+                    }
+                });
+            }, coordinate, () -> {
+                return dist;
+            }));
+        }
+
+        // this is invoked if and only if there are no other players in range of the chunk.
+        public void playerMoveOutOfRange(final int chunkX, final int chunkZ, final int fromX, final int fromZ) {
+            final long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+
+            Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, ChunkMapDistance.b, new ChunkCoordIntPair(chunkX, chunkZ), ChunkMapDistance.this.currentTick);
+
+            ChunkMapDistance.this.k.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
+                ChunkMapDistance.this.m.execute(() -> {
+                    ChunkMapDistance.this.removeTicket(coordinate, ticket);
+                });
+            }, coordinate, true));
+        }
+    }
+    /* Concrete end - per player view distance */
+
     class c extends ChunkMapDistance.b {
 
         private int e = 0;
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index c8c74f2b3ef67947ca797deef30077c034251138..02e3b53bce4ea7f0cecec18a3a6b49948182df99 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -570,9 +570,9 @@ public class EntityEnderDragon extends EntityInsentient implements IMonster {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API /* Concrete - per player view distance */
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = (player.getEffectiveViewDistance(player.getWorldServer().getChunkProvider().playerChunkMap) - 1) << 4; /* Concrete - per player view distance */
                     // Paper end
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index ea0767b3361336a8af7791363621732fa194babd..42d61ff05710b8137730ddf2e12186c5d9e5bc50 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -102,6 +102,11 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
 
     /* Concrete start */
     public final ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> cachedSingleHashSet;
+
+    public int viewDistance = -1;
+    public int getEffectiveViewDistance(PlayerChunkMap chunkMap) {
+        return this.viewDistance == -1 ? chunkMap.viewDistance : this.viewDistance + 1;
+    }
     /* Concrete end */
 
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 8b3052b1132ec728e1b266f3aede6bbd922ce617..61734ae530c866a73a7fc4a7bd1a469297579cf7 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -208,9 +208,9 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1023, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API /* Concrete - per player view distance */
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = (player.getEffectiveViewDistance(player.getWorldServer().getChunkProvider().playerChunkMap) - 1) << 4; /* Concrete - per player view distance */
                     // Paper end
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 34d0ab0d5e145bd7cd14348adda54eea8b43d175..b1749decbe5537f1c5532e3183e0bc622f1c06c2 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -248,6 +248,38 @@ public class PlayerChunk {
     }
 
     private void a(Packet<?> packet, boolean flag) {
+        /* Concrete start - per player view distance */
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        if (this.players instanceof PlayerChunkMap) {
+            PlayerChunkMap chunkMap = ((PlayerChunkMap)this.players);
+            ca.spottedleaf.concrete.util.map.PlayerAreaMap viewDistanceMap = ((PlayerChunkMap)this.players).playerViewDistanceMap;
+            Iterable<EntityPlayer> players = viewDistanceMap.getObjectsInRange(this.location);
+            if (players == null) {
+                return;
+            }
+
+            if (flag) { // flag -> border only
+                for (EntityPlayer player : players) {
+                    int viewDistance = player.getEffectiveViewDistance(chunkMap);
+                    long lastPosition = viewDistanceMap.getLastCoordinate(player);
+
+                    int distX = Math.abs(ca.spottedleaf.concrete.util.Util.getCoordinateX(lastPosition) - this.location.x);
+                    int distZ = Math.abs(ca.spottedleaf.concrete.util.Util.getCoordinateZ(lastPosition) - this.location.z);
+
+                    if (Math.max(distX, distZ) == viewDistance) {
+                        player.playerConnection.sendPacket(packet);
+                    }
+                }
+            } else {
+                for (EntityPlayer player : players) {
+                    player.playerConnection.sendPacket(packet);
+                }
+            }
+
+            return;
+        }
+        /* Concrete end - per player view distance */
         this.players.a(this.location, flag).forEach((entityplayer) -> {
             entityplayer.playerConnection.sendPacket(packet);
         });
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index e79cacd642446571f47cbd10eca3757486e950aa..e88f311224894b01369f021d78c79a4e19fa22e1 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -77,7 +77,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private final PlayerMap playerMap;
     public final Int2ObjectMap<PlayerChunkMap.EntityTracker> trackedEntities;
     private final Queue<Runnable> A;
-    int viewDistance; // Paper - private -> package private
+    int viewDistance; public final int getViewDistance() { return this.viewDistance; } // Paper - private -> package private /* Concrete - OBFHELPER */
     //public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper /* Concrete - replaced by view distance map */
 
     // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
@@ -112,6 +112,15 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     public final ca.spottedleaf.concrete.util.map.PlayerAreaMap entityTrackerTrackMap;
     public final int maxEntityTrackRangeChunk;
 
+    public final ca.spottedleaf.concrete.util.map.PlayerAreaMap playerViewDistanceTicketMap;
+
+    // TODO this needs to be re-checked on update
+    // we subtract two since we want the outer chunks in a player's view distance to be at level 33
+    // we add tickets at level 31
+    private static int getTicketLevelDistance(final int distance) {
+        return distance - 1;
+    }
+
     void addPlayerToDistanceMaps(EntityPlayer player) {
         try (co.aikar.timings.Timing ignored = this.world.timings.playerViewDistanceMapAdd.startTiming()) {
             this.updateMaps(player);
@@ -120,6 +129,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     void removePlayerFromDistanceMaps(EntityPlayer player) {
         try (co.aikar.timings.Timing ignored = this.world.timings.playerViewDistanceMapRemove.startTiming()) {
+            this.playerViewDistanceTicketMap.remove(player);
             this.playerViewDistanceMap.remove(player);
             if (this.playerMobSpawnRangeMap != null) {
                 this.playerMobSpawnRangeMap.remove(player);
@@ -134,16 +144,37 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         }
     }
 
+    public void updateViewDistance(EntityPlayer player, int viewDistance) {
+        player.viewDistance = viewDistance;
+
+        int chunkX = ca.spottedleaf.concrete.util.Util.getChunkCoordinate(player.locX);
+        int chunkZ = ca.spottedleaf.concrete.util.Util.getChunkCoordinate(player.locZ);
+
+        int effectiveViewDistance = viewDistance == -1 ? this.viewDistance : viewDistance + 1;
+
+        player.playerConnection.sendPacket(new PacketPlayOutViewDistance(effectiveViewDistance));
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTicketMap.update(player, chunkX, chunkZ, getTicketLevelDistance(effectiveViewDistance));
+        }
+        this.playerViewDistanceMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+    }
+
     private void updateMaps(EntityPlayer player) {
         int chunkX = ca.spottedleaf.concrete.util.Util.getChunkCoordinate(player.locX);
         int chunkZ = ca.spottedleaf.concrete.util.Util.getChunkCoordinate(player.locZ);
 
-        this.playerViewDistanceMap.update(player, chunkX, chunkZ, this.viewDistance);
+        int effectiveViewDistance = player.getEffectiveViewDistance(this);
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTicketMap.update(player, chunkX, chunkZ, getTicketLevelDistance(effectiveViewDistance));
+        }
+        this.playerViewDistanceMap.update(player, chunkX, chunkZ, effectiveViewDistance); /* Concrete - per player view distance */
 
         if (this.playerMobSpawnRangeMap != null) {
             // copied from outside range check
             int chunkRange = world.spigotConfig.mobSpawnRange;
-            chunkRange = (chunkRange > world.spigotConfig.viewDistance) ? (byte) world.spigotConfig.viewDistance : chunkRange;
+            chunkRange = (chunkRange > effectiveViewDistance - 1) ? (byte) (effectiveViewDistance - 1) : chunkRange; /* Concrete - per player view distance */
             chunkRange = (chunkRange > 8) ? 8 : chunkRange;
 
             this.playerMobSpawnRangeMap.update(player, chunkX, chunkZ, chunkRange);
@@ -187,7 +218,33 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         //this.playerMobDistanceMap = this.world.paperConfig.perPlayerMobSpawns ? new com.destroystokyo.paper.util.PlayerMobDistanceMap() : null; // Paper /* Concrete - use the distance map */
         /* Concrete start - distance maps */
         ca.spottedleaf.concrete.util.map.PooledLinkedHashSets<EntityPlayer> sets = new ca.spottedleaf.concrete.util.map.PooledLinkedHashSets<>();
-        this.playerViewDistanceMap = new ca.spottedleaf.concrete.util.map.PlayerAreaMap(sets);
+        this.playerViewDistanceTicketMap = new ca.spottedleaf.concrete.util.map.PlayerAreaMap(sets,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState.size() != 1) {
+                        return;
+                    }
+                    PlayerChunkMap.this.chunkDistanceManager.playerTicketHandler.playerMoveInRange(rangeX, rangeZ, currPosX, currPosZ);
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState != null) {
+                        return;
+                    }
+                    PlayerChunkMap.this.chunkDistanceManager.playerTicketHandler.playerMoveOutOfRange(rangeX, rangeZ, currPosX, currPosZ);
+                });
+        final Packet[] tempPacket = new Packet[2];
+        this.playerViewDistanceMap = new ca.spottedleaf.concrete.util.map.PlayerAreaMap(sets,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    java.util.Arrays.fill(tempPacket, null);
+                    PlayerChunkMap.this.sendChunk(player, rangeX, rangeZ, tempPacket, false, true); // unloaded, loaded
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    java.util.Arrays.fill(tempPacket, null);
+                    PlayerChunkMap.this.sendChunk(player, rangeX, rangeZ, tempPacket, true, false); // unloaded, loaded
+                });
         this.playerMobSpawnRangeMap = ca.spottedleaf.concrete.config.ConcreteConfig.optimizeChunkRangeCheck ? new ca.spottedleaf.concrete.util.map.PlayerAreaMap(sets) : null;
 
         int maxEntityTrackRangeBlock = this.world.spigotConfig.playerTrackingRange;
@@ -913,9 +970,16 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 this.v.getAndIncrement();
                 Packet<?>[] apacket = new Packet[2];
 
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    this.a(entityplayer, apacket, chunk);
-                });
+                /* Concrete start - per player view distance */
+                // there can be potential desync with player's last mapped section and the view distance map, so use the
+                // view distance map here.
+                Iterable<EntityPlayer> players = PlayerChunkMap.this.playerViewDistanceMap.getObjectsInRange(chunkcoordintpair);
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        this.a(player, apacket, chunk);
+                    }
+                }
+                /* Concrete end - per player view distance */
                 return Either.left(chunk);
             });
         }, (runnable) -> {
@@ -1024,22 +1088,16 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             int k = this.viewDistance;
 
             this.viewDistance = j;
-            this.chunkDistanceManager.a(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunks.values().iterator();
-
-            while (objectiterator.hasNext()) {
-                PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-                Packet<?>[] apacket = new Packet[2];
-
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = b(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
-
-                    this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
+            this.chunkDistanceManager.setGlobalViewDistance(this.viewDistance, this); /* Concrete - per player view distance */
+            /* Concrete start - view distance map handles this */
+            if (this.world != null && this.world.players != null) { // ... called inside constructor, where these may not be initialized
+                for (EntityPlayer player : this.world.players) {
+                    if (player.viewDistance == -1) {
+                        this.updateViewDistance(player, -1);
+                    }
+                }
             }
+            /* Concrete end - view distance map handles this */
         }
 
     }
@@ -1330,6 +1388,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         /* Concrete end */
     }
 
+    private boolean cannotLoadChunks(EntityPlayer entityplayer) { return this.b(entityplayer); } /* Concrete - OBFHELPER */
     private boolean b(EntityPlayer entityplayer) {
         return entityplayer.isSpectator() && !this.world.getGameRules().getBoolean(GameRules.SPECTATORS_GENERATE_CHUNKS);
     }
@@ -1355,15 +1414,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
-        Packet[] cachedPackets = new Packet[2]; /* Concrete */
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                /* Concrete start - remove excess object creation (ChunkCoordIntPair and Packet[]) */
-                this.sendChunk(entityplayer, k, l, cachedPackets, !flag, flag);
-                java.util.Arrays.fill(cachedPackets, null);
-                /* Concrete end */
-            }
-        }
+        this.updateMaps(entityplayer); /* Concrete - view distance map handles this */
 
     }
 
@@ -1376,7 +1427,6 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     public void movePlayer(EntityPlayer entityplayer) {
-        this.updateDistanceMaps(entityplayer); /* Concrete - distance maps */
         if (false) { /* Concrete - tracker optimization takes care of this */
         ObjectIterator objectiterator = this.trackedEntities.values().iterator();
 
@@ -1429,66 +1479,42 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance;
-            l1 = Math.min(j, j1) - this.viewDistance;
-            int i2 = Math.max(i, i1) + this.viewDistance;
-            int j2 = Math.max(j, j1) + this.viewDistance;
+        this.updateDistanceMaps(entityplayer); /* Concrete - this is replaced by the calllbacks in the view distance map */
+
+    }
+
+    @Override
+    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
+        /* Concrete start - per player view distance */
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        Iterable<EntityPlayer> inRange = this.playerViewDistanceMap.getObjectsInRange(chunkcoordintpair);
+
+        if (inRange == null) {
+            return Stream.empty();
+        }
+        // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
+        List<EntityPlayer> players = new ArrayList<>();
 
-            Packet[] cachedPackets = new Packet[2]; /* Concrete */
+        if (flag) { // flag -> border only
+            for (EntityPlayer player : inRange) {
+                int viewDistance = player.getEffectiveViewDistance(this);
+                long lastPosition = this.playerViewDistanceMap.getLastCoordinate(player);
 
-            for (int k2 = k1; k2 <= i2; ++k2) {
-                for (int l2 = l1; l2 <= j2; ++l2) {
-                    /* Concrete start - remove ChunkCoordIntPair allocation */
-                    boolean flag3 = getSquareRadiusDistance(k2, l2, i1, j1) <= this.viewDistance;
-                    boolean flag4 = getSquareRadiusDistance(k2, l2, i, j) <= this.viewDistance;
+                int distX = Math.abs(ca.spottedleaf.concrete.util.Util.getCoordinateX(lastPosition) - chunkcoordintpair.x);
+                int distZ = Math.abs(ca.spottedleaf.concrete.util.Util.getCoordinateZ(lastPosition) - chunkcoordintpair.z);
 
-                    this.sendChunk(entityplayer, k2, l2, cachedPackets, flag3, flag4);
-                    java.util.Arrays.fill(cachedPackets, null);
-                    /* Concrete end */
+                if (Math.max(distX, distZ) == viewDistance) {
+                    players.add(player);
                 }
             }
         } else {
-            //ChunkCoordIntPair chunkcoordintpair1; /* Concrete - we don't set, so compile fail on further uses */
-            boolean flag5;
-            boolean flag6;
-
-            Packet[] cachedPackets = new Packet[2]; /* Concrete */
-
-            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
-                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    /* Concrete - remove ChunkCoordIntPair allocation */
-                    flag5 = true;
-                    flag6 = false;
-                    /* Concrete start - remove ChunkCoordIntPair allocation */
-                    this.sendChunk(entityplayer, k1, l1, cachedPackets, true, false);
-                    java.util.Arrays.fill(cachedPackets, null);
-                    /* Concrete end */
-                }
-            }
-
-            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
-                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    /* Concrete - remove ChunkCoordIntPair allocation */
-                    flag5 = false;
-                    flag6 = true;
-                    /* Concrete start - remove ChunkCoordIntPair allocation */
-                    this.sendChunk(entityplayer, k1, l1, cachedPackets, false, true);
-                    java.util.Arrays.fill(cachedPackets, null);
-                    /* Concrete end */
-                }
+            for (EntityPlayer player : inRange) {
+                players.add(player);
             }
         }
-
-    }
-
-    @Override
-    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
-        return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
-            int i = b(chunkcoordintpair, entityplayer, true);
-
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
-        });
+        return players.stream();
+        /* Concrete end - per player view distance */
     }
 
     protected void addEntity(Entity entity) {
@@ -1784,7 +1810,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (entityplayer != this.tracker) {
                 Vec3D vec3d = (new Vec3D(entityplayer.locX, entityplayer.locY, entityplayer.locZ)).d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
-                int i = Math.min(this.trackingDistance, (PlayerChunkMap.this.viewDistance - 1) * 16);
+                int i = Math.min(this.trackingDistance, (entityplayer.getEffectiveViewDistance(PlayerChunkMap.this) - 1) * 16); /* Concrete - per player view distance */
                 boolean flag = vec3d.x >= (double) (-i) && vec3d.x <= (double) i && vec3d.z >= (double) (-i) && vec3d.z <= (double) i && this.tracker.a(entityplayer);
 
                 if (flag) {
@@ -1795,7 +1821,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
 
                         if (playerchunk != null && playerchunk.getChunk() != null) {
-                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
+                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= entityplayer.getEffectiveViewDistance(PlayerChunkMap.this); /* Concrete - per player view distance */
                         }
                     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 3cb443c4ffbb8916b2c47c3f799ed4907178cdf2..7c62e75aaad25786d88a59501662c76ade303eba 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -155,7 +155,7 @@ public abstract class PlayerList {
 
         // CraftBukkit - getType()
         // Spigot - view distance
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.spigotConfig.viewDistance, worldserver.getGameRules().getBoolean(GameRules.REDUCED_DEBUG_INFO)));
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), entityplayer.getEffectiveViewDistance(worldserver.getChunkProvider().playerChunkMap) - 1, worldserver.getGameRules().getBoolean(GameRules.REDUCED_DEBUG_INFO))); /* Concrete - per player view distance */
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload(PacketPlayOutCustomPayload.a, (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
         playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -699,7 +699,7 @@ public abstract class PlayerList {
         WorldData worlddata = worldserver.getWorldData();
 
         entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(worldserver.worldProvider.getDimensionManager().getType(), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(entityplayer1.getEffectiveViewDistance(worldserver.getChunkProvider().playerChunkMap) - 1)); // Spigot /* Concrete - per player view distance */
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX, entityplayer1.locY, entityplayer1.locZ, entityplayer1.yaw, entityplayer1.pitch));
@@ -1174,7 +1174,7 @@ public abstract class PlayerList {
 
     public void a(int i) {
         this.viewDistance = i;
-        this.sendAll(new PacketPlayOutViewDistance(i));
+        //this.sendAll(new PacketPlayOutViewDistance(i)); /* Concrete - move into setViewDistance */
         Iterator iterator = this.server.getWorlds().iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index e920545df1037fc542eaec0755a6f389dc16e239..a1e1766bd5671fc7bccf4f06682ee435389939b2 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit.entity;
 
+import ca.spottedleaf.concrete.util.TickThread; /* Concrete */
 import com.destroystokyo.paper.Title;
 import com.destroystokyo.paper.profile.CraftPlayerProfile;
 import com.destroystokyo.paper.profile.PlayerProfile;
@@ -1986,12 +1987,20 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getViewDistance() {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        return getHandle().viewDistance == -1 ? ((WorldServer)getHandle().world).getChunkProvider().playerChunkMap.getViewDistance() - 1 : getHandle().viewDistance; /* Concrete - per player view distance */
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        TickThread.ensureTickThread("Cannot update view distance safely off of the main thread");
+        /* Concrete start - per player view distance */
+        if ((viewDistance < 2 || viewDistance > 32) && viewDistance != -1) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        if (viewDistance != getHandle().viewDistance) {
+            ((WorldServer)getHandle().world).getChunkProvider().playerChunkMap.updateViewDistance(getHandle(), viewDistance);
+        }
+        /* Concrete end - per player view distance */
     }
     //Paper end
 
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 92601c581cffac471872226abeb93ef9aa24f079..9e16fb626c2c337473336361369927d670eaea96 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -33,6 +33,7 @@ import net.minecraft.server.MathHelper;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.World;
 import co.aikar.timings.MinecraftTimings;
+import net.minecraft.server.WorldServer; /* Concrete */
 
 public class ActivationRange
 {
@@ -119,14 +120,15 @@ public class ActivationRange
         final int animalActivationRange = world.spigotConfig.animalActivationRange;
         final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
 
-        int maxRange = Math.max( monsterActivationRange, animalActivationRange );
-        maxRange = Math.max( maxRange, raiderActivationRange );
-        maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        /* Concrete start - per player view distance */
+        int maxRangeTemp = Math.max( monsterActivationRange, animalActivationRange );
+        maxRangeTemp = Math.max( maxRangeTemp, raiderActivationRange );
+        maxRangeTemp = Math.max( maxRangeTemp, miscActivationRange );
 
         for ( EntityHuman player : world.getPlayers() )
         {
-
+            final int maxRange = Math.min( ( ( player instanceof net.minecraft.server.EntityPlayer ? ((net.minecraft.server.EntityPlayer)player).getEffectiveViewDistance(((WorldServer)world).getChunkProvider().playerChunkMap) - 1 : world.spigotConfig.viewDistance ) << 4 ) - 8, maxRangeTemp );
+            /* Concrete end - per player view distance */
             player.activatedTick = MinecraftServer.currentTick;
             maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
             ActivationType.MISC.boundingBox = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
