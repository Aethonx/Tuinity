From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sat, 12 Oct 2019 15:34:24 -0700
Subject: [PATCH] Optimize Entity#move

WORK IN PROGRESS

diff --git a/src/main/java/ca/spottedleaf/concrete/collision/AxisCycle.java b/src/main/java/ca/spottedleaf/concrete/collision/AxisCycle.java
new file mode 100644
index 0000000000000000000000000000000000000000..70f8646a39d1a1254dc1c415b94ef134288e86d0
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/collision/AxisCycle.java
@@ -0,0 +1,67 @@
+package ca.spottedleaf.concrete.collision;
+
+public final class AxisCycle {
+
+    public static final int NONE = 0;
+    public static final int FORWARDS = 1;
+    public static final int BACKWARDS = 2;
+
+    public static final int AXIS_X = 1 << 0;
+    public static final int AXIS_Y = 1 << 1;
+    public static final int AXIS_Z = 1 << 2;
+
+    public static int toValue(final int cycle) {
+        // 0 -> 0
+        // 1 -> 1
+        // 2 -> -1
+        return ((cycle << 30) >> 31) | cycle;
+    }
+
+    public static int inverse(final int cycle) {
+        final int index = cycle << 1;
+        final int table = (0 << 0) | (2 << 2) | (1 << 4); // 0, 1, 2 -> 0, 2, 1
+        return (table >>> index) & 3;
+    }
+
+    public static int choose(int x, int y, int z, int axis) {
+        // axis = X -> x
+        // axis = Y -> y
+        // axis = Z -> z
+        int maskX = ((axis << 31) >> 31);
+        int maskY = ((axis << 30) >> 31);
+        int maskZ = ((axis << 29) >> 31);
+
+        return (x & maskX) | (y & maskY) | (z & maskZ);
+    }
+
+    private static final int[] CYCLE_TABLE = {
+            /* 0: 0, 1, 2  ------> */ 0, 1, 2,
+            /* 1: 0, 1, 2  ------> */ 1, 2, 0,
+            /* 2: 0, 1, 2  ------> */ 2, 0, 1,
+    };
+
+    // see above table
+    public static int cycle(final int currentCycle, final int nextCycle) {
+        final int index = (currentCycle * 3 + nextCycle) << 1;
+        final int table = (0 <<  0) | (1 <<  2) | (2 <<  4) |
+                          (1 <<  6) | (2 <<  8) | (0 << 10) |
+                          (2 << 12) | (0 << 14) | (1 << 16); // variant of CYCLE_TABLE but included in one integer
+
+        return (table >>> index) & 3;
+    }
+
+    private static final int[] BETWEEN_TABLE = {
+            /* 0: 0, 1, 2  ------> */ 0, 2, 1,
+            /* 1: 0, 1, 2  ------> */ 1, 0, 2,
+            /* 2: 0, 1, 2  ------> */ 2, 1 ,0,
+    };
+
+    public static int between(final int axis0, final int axis1) {
+        final int index = (axis1 * 3 + axis0) << 1;
+        final int table = (0 <<  0) | (1 <<  2) | (2 <<  4) |
+                          (2 <<  6) | (0 <<  8) | (1 << 10) |
+                          (1 << 12) | (2 << 14) | (0 << 16); // variant of BETWEEN_TABLE but included in one integer
+
+        return (table >>> index) & 3;
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/collision/CollisionConstants.java b/src/main/java/ca/spottedleaf/concrete/collision/CollisionConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..45415e45da4274a1e1db482a5d5d3abb86bc4163
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/collision/CollisionConstants.java
@@ -0,0 +1,7 @@
+package ca.spottedleaf.concrete.collision;
+
+public final class CollisionConstants {
+
+    public static final double EPSILON = 1.0E-7D;
+
+}
\ No newline at end of file
diff --git a/src/main/java/ca/spottedleaf/concrete/util/pool/CachedLists.java b/src/main/java/ca/spottedleaf/concrete/util/pool/CachedLists.java
new file mode 100644
index 0000000000000000000000000000000000000000..cdd83833688f983441aa2235d3b3eeffe1289bb7
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/pool/CachedLists.java
@@ -0,0 +1,21 @@
+package ca.spottedleaf.concrete.util.pool;
+
+import net.minecraft.server.Entity;
+import net.minecraft.server.VoxelShape;
+import org.bukkit.craftbukkit.util.UnsafeList;
+
+public final class CachedLists {
+
+    public static final UnsafeList<VoxelShape> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
+    public static final UnsafeList<Entity> TEMP_ENTITY_LIST = new UnsafeList<>(1024);
+    public static final UnsafeList<Entity> TEMP_COLLIDE_NEARBY_LIST = new UnsafeList<>(1024);
+
+
+
+    public static void reset() {
+        TEMP_COLLISION_LIST.completeReset();
+        TEMP_ENTITY_LIST.completeReset();
+        TEMP_COLLIDE_NEARBY_LIST.completeReset();
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
index c950139c0f819e87ded97dc8fb915b6755e51e71..d5ed9a9ee051c784b262d3cdcc1ecb3075ab3008 100644
--- a/src/main/java/net/minecraft/server/AxisAlignedBB.java
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -193,6 +193,7 @@ public class AxisAlignedBB {
         return this.d(vec3d.x, vec3d.y, vec3d.z);
     }
 
+    public final boolean intersects(AxisAlignedBB axisalignedbb) { return this.c(axisalignedbb); } /* Concrete - OBFHELPER */
     public boolean c(AxisAlignedBB axisalignedbb) {
         return this.a(axisalignedbb.minX, axisalignedbb.minY, axisalignedbb.minZ, axisalignedbb.maxX, axisalignedbb.maxY, axisalignedbb.maxZ);
     }
diff --git a/src/main/java/net/minecraft/server/DataPaletteBlock.java b/src/main/java/net/minecraft/server/DataPaletteBlock.java
index 44aed67274b1a10726ad91b261b159289f36b6d9..0fc826da5959179f3c0bce005324f4b157d93723 100644
--- a/src/main/java/net/minecraft/server/DataPaletteBlock.java
+++ b/src/main/java/net/minecraft/server/DataPaletteBlock.java
@@ -170,6 +170,7 @@ public class DataPaletteBlock<T> implements DataPaletteExpandable<T> {
         return this.a(b(i, j, k));
     }
 
+    public final T rawGet(int index) { return this.a(index); } /* Concrete - OBFHELPER */
     protected T a(int i) {
         T t0 = this.h.a(this.a.a(i));
 
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 427160fd5b649648edf8ce302dd62111e3e40bbb..9fb84236c09933a8e46f2f6a35e78a3361a6558f 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -815,25 +815,31 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return d0;
     }
 
+    private static final org.bukkit.craftbukkit.util.UnsafeList<VoxelShape> TEMP_COLLISION_LIST = ca.spottedleaf.concrete.util.pool.CachedLists.TEMP_COLLISION_LIST; /* Concrete - optimize Entity#move */
+    private static final org.bukkit.craftbukkit.util.UnsafeList<Entity> TEMP_ENTITY_LIST = ca.spottedleaf.concrete.util.pool.CachedLists.TEMP_ENTITY_LIST; /* Concrete - optimize Entity#move */
+
     private Vec3D e(Vec3D vec3d) {
         AxisAlignedBB axisalignedbb = this.getBoundingBox();
         VoxelShapeCollision voxelshapecollision = VoxelShapeCollision.a(this);
         VoxelShape voxelshape = this.world.getWorldBorder().a();
-        Stream<VoxelShape> stream = VoxelShapes.c(voxelshape, VoxelShapes.a(axisalignedbb.shrink(1.0E-7D)), OperatorBoolean.AND) ? Stream.empty() : Stream.of(voxelshape);
-        Stream<VoxelShape> stream1 = this.world.b(this, axisalignedbb.a(vec3d), (Set) ImmutableSet.of());
-        StreamAccumulator<VoxelShape> streamaccumulator = new StreamAccumulator<>(Stream.concat(stream1, stream));
-        Vec3D vec3d1 = vec3d.g() == 0.0D ? vec3d : a(this, vec3d, axisalignedbb, this.world, voxelshapecollision, streamaccumulator);
+        /* Concrete start - optimize Entity#move */
+        if (!VoxelShapes.c(voxelshape, VoxelShapes.a(axisalignedbb.shrink(1.0E-7D)), OperatorBoolean.AND)) {
+            TEMP_COLLISION_LIST.add(voxelshape);
+        }
+        this.world.getEntityShapesColliding(this, axisalignedbb.a(vec3d), null, TEMP_ENTITY_LIST, TEMP_COLLISION_LIST);
+        Vec3D vec3d1 = vec3d.g() == 0.0D ? vec3d : calculateCollision(this, vec3d, axisalignedbb, this.world, voxelshapecollision, TEMP_COLLISION_LIST);
+        /* Concrete end - optimize Entity#move */
         boolean flag = vec3d.x != vec3d1.x;
         boolean flag1 = vec3d.y != vec3d1.y;
         boolean flag2 = vec3d.z != vec3d1.z;
         boolean flag3 = this.onGround || flag1 && vec3d.y < 0.0D;
 
         if (this.H > 0.0F && flag3 && (flag || flag2)) {
-            Vec3D vec3d2 = a(this, new Vec3D(vec3d.x, (double) this.H, vec3d.z), axisalignedbb, this.world, voxelshapecollision, streamaccumulator);
-            Vec3D vec3d3 = a(this, new Vec3D(0.0D, (double) this.H, 0.0D), axisalignedbb.b(vec3d.x, 0.0D, vec3d.z), this.world, voxelshapecollision, streamaccumulator);
+            Vec3D vec3d2 = calculateCollision(this, new Vec3D(vec3d.x, (double) this.H, vec3d.z), axisalignedbb, this.world, voxelshapecollision, TEMP_COLLISION_LIST); /* Concrete - optimize Entity#move */
+            Vec3D vec3d3 = calculateCollision(this, new Vec3D(0.0D, (double) this.H, 0.0D), axisalignedbb.b(vec3d.x, 0.0D, vec3d.z), this.world, voxelshapecollision, TEMP_COLLISION_LIST); /* Concrete - optimize Entity#move */
 
             if (vec3d3.y < (double) this.H) {
-                Vec3D vec3d4 = a(this, new Vec3D(vec3d.x, 0.0D, vec3d.z), axisalignedbb.b(vec3d3), this.world, voxelshapecollision, streamaccumulator).e(vec3d3);
+                Vec3D vec3d4 = calculateCollision(this, new Vec3D(vec3d.x, 0.0D, vec3d.z), axisalignedbb.b(vec3d3), this.world, voxelshapecollision, TEMP_COLLISION_LIST).e(vec3d3); /* Concrete - optimize Entity#move */
 
                 if (b(vec3d4) > b(vec3d2)) {
                     vec3d2 = vec3d4;
@@ -841,16 +847,112 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             }
 
             if (b(vec3d2) > b(vec3d1)) {
-                return vec3d2.e(a(this, new Vec3D(0.0D, -vec3d2.y + vec3d.y, 0.0D), axisalignedbb.b(vec3d2), this.world, voxelshapecollision, streamaccumulator));
+                return vec3d2.e(calculateCollision(this, new Vec3D(0.0D, -vec3d2.y + vec3d.y, 0.0D), axisalignedbb.b(vec3d2), this.world, voxelshapecollision, TEMP_COLLISION_LIST)); /* Concrete - optimize Entity#move */
             }
         }
 
+        TEMP_ENTITY_LIST.setSize(0); /* Concrete */
+        TEMP_COLLISION_LIST.setSize(0); /* Concrete */
+
         return vec3d1;
     }
 
     public static double b(Vec3D vec3d) {
         return vec3d.x * vec3d.x + vec3d.z * vec3d.z;
     }
+    /* Concrete start - optimize Entity#move */
+    public static Vec3D calculateCollision(@Nullable Entity entity, Vec3D vec3d, AxisAlignedBB axisalignedbb,
+                                           World world, VoxelShapeCollision voxelshapecollision,
+                                           org.bukkit.craftbukkit.util.UnsafeList<VoxelShape> collisions) {
+        boolean flag = vec3d.x == 0.0D;
+        boolean flag1 = vec3d.y == 0.0D;
+        boolean flag2 = vec3d.z == 0.0D;
+
+        if ((!flag || !flag1) && (!flag || !flag2) && (!flag1 || !flag2)) {
+            int preCollisions = collisions.size();
+            world.getCollidingBlocks(entity, axisalignedbb.a(vec3d), collisions);
+
+            Vec3D ret = calculateCollisions(vec3d, axisalignedbb, collisions);
+            collisions.setSize(preCollisions);
+            return ret;
+        } else {
+            return calculateCollisions(vec3d, axisalignedbb, world, voxelshapecollision, collisions);
+        }
+    }
+
+    public static Vec3D calculateCollisions(Vec3D vec3d, AxisAlignedBB axisalignedbb,
+                                            org.bukkit.craftbukkit.util.UnsafeList<VoxelShape> collisions) {
+        double d0 = vec3d.x;
+        double d1 = vec3d.y;
+        double d2 = vec3d.z;
+
+        if (d1 != 0.0D) {
+            d1 = VoxelShapes.a(EnumDirection.EnumAxis.Y, axisalignedbb, collisions, d1);
+            if (d1 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(0.0D, d1, 0.0D);
+            }
+        }
+
+        boolean flag = Math.abs(d0) < Math.abs(d2);
+
+        if (flag && d2 != 0.0D) {
+            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, collisions, d2);
+            if (d2 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(0.0D, 0.0D, d2);
+            }
+        }
+
+        if (d0 != 0.0D) {
+            d0 = VoxelShapes.a(EnumDirection.EnumAxis.X, axisalignedbb, collisions, d0);
+            if (!flag && d0 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(d0, 0.0D, 0.0D);
+            }
+        }
+
+        if (!flag && d2 != 0.0D) {
+            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, collisions, d2);
+        }
+
+        return new Vec3D(d0, d1, d2);
+    }
+
+    public static Vec3D calculateCollisions(Vec3D vec3d, AxisAlignedBB axisalignedbb, IWorldReader iworldreader,
+                          VoxelShapeCollision voxelshapecollision,
+                          org.bukkit.craftbukkit.util.UnsafeList<VoxelShape> collisions) {
+        double d0 = vec3d.x;
+        double d1 = vec3d.y;
+        double d2 = vec3d.z;
+
+        if (d1 != 0.0D) {
+            d1 = VoxelShapes.a(EnumDirection.EnumAxis.Y, axisalignedbb, iworldreader, d1, voxelshapecollision, collisions);
+            if (d1 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(0.0D, d1, 0.0D);
+            }
+        }
+
+        boolean flag = Math.abs(d0) < Math.abs(d2);
+
+        if (flag && d2 != 0.0D) {
+            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, collisions);
+            if (d2 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(0.0D, 0.0D, d2);
+            }
+        }
+
+        if (d0 != 0.0D) {
+            d0 = VoxelShapes.a(EnumDirection.EnumAxis.X, axisalignedbb, iworldreader, d0, voxelshapecollision, collisions);
+            if (!flag && d0 != 0.0D) {
+                axisalignedbb = axisalignedbb.d(d0, 0.0D, 0.0D);
+            }
+        }
+
+        if (!flag && d2 != 0.0D) {
+            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, collisions);
+        }
+
+        return new Vec3D(d0, d1, d2);
+    }
+    /* Concrete end - optimize Entity#move */
 
     public static Vec3D a(@Nullable Entity entity, Vec3D vec3d, AxisAlignedBB axisalignedbb, World world, VoxelShapeCollision voxelshapecollision, StreamAccumulator<VoxelShape> streamaccumulator) {
         boolean flag = vec3d.x == 0.0D;
@@ -1111,8 +1213,8 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
 
     }
 
-    @Nullable
-    public AxisAlignedBB au() {
+    @Nullable public final AxisAlignedBB getHardCollisionBox() { return this.au(); } /* Concrete - OBFHELPER */
+    @Nullable public AxisAlignedBB au() { /* Concrete - OBFHELPER */
         return null;
     }
 
@@ -2017,8 +2119,8 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return false;
     }
 
-    @Nullable
-    public AxisAlignedBB j(Entity entity) {
+    @Nullable public final AxisAlignedBB getHardCollisionWith(Entity entity) { return this.j(entity); } /* Concrete - OBFHELPER */
+    @Nullable public AxisAlignedBB j(Entity entity) { /* Concrete - OBFHELPER */
         return null;
     }
 
@@ -3122,6 +3224,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return entity;
     }
 
+    public final boolean rootVehiclesMatch(Entity entity) { return this.x(entity); } /* Concrete - OBFHELPER */
     public boolean x(Entity entity) {
         return this.getRootVehicle() == entity.getRootVehicle();
     }
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index 3c6c96745454c4758977bccda1bdc5e8ec44acce..3c93a78fe66461701be9ec0f60b7be38e46f1e11 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -2658,8 +2658,13 @@ public abstract class EntityLiving extends Entity {
 
     protected void doTick() {}
 
+    private static org.bukkit.craftbukkit.util.UnsafeList<Entity> TEMP_COLLIDE_NEARBY_LIST = ca.spottedleaf.concrete.util.pool.CachedLists.TEMP_COLLIDE_NEARBY_LIST; /* Concrete */
+
     protected void collideNearby() {
-        List<Entity> list = this.world.getEntities(this, this.getBoundingBox(), IEntitySelector.a(this));
+        /* Concrete start */
+        org.bukkit.craftbukkit.util.UnsafeList<Entity> tempList = TEMP_COLLIDE_NEARBY_LIST;
+        List<Entity> list = this.world.getEntities( this, this.getBoundingBox(), IEntitySelector.a(this), tempList);
+        /* Concrete end */
 
         if (!list.isEmpty()) {
             int i = this.world.getGameRules().getInt(GameRules.MAX_ENTITY_CRAMMING);
@@ -2688,7 +2693,12 @@ public abstract class EntityLiving extends Entity {
                 this.C(entity);
             }
         }
-
+        /* Concrete start */
+        if (tempList != null) {
+            tempList.setSize(0);
+            TEMP_COLLIDE_NEARBY_LIST = tempList;
+        }
+        /* Concrete end */
     }
 
     protected void a(AxisAlignedBB axisalignedbb, AxisAlignedBB axisalignedbb1) {
diff --git a/src/main/java/net/minecraft/server/IEntityAccess.java b/src/main/java/net/minecraft/server/IEntityAccess.java
index c8512f9f414413bc4f717c291180114e782e6a43..9215bcc13b99f2d7444f50e498d6ff93e5533c21 100644
--- a/src/main/java/net/minecraft/server/IEntityAccess.java
+++ b/src/main/java/net/minecraft/server/IEntityAccess.java
@@ -14,6 +14,14 @@ public interface IEntityAccess {
 
     List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate);
 
+    default List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate, @Nullable List<Entity> ret) {
+        if (ret == null) {
+            return this.getEntities(entity, axisalignedbb, predicate);
+        }
+        ret.addAll(this.getEntities(entity, axisalignedbb, predicate));
+        return ret;
+    }
+
     <T extends Entity> List<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super T> predicate);
 
     default <T extends Entity> List<T> b(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super T> predicate) {
@@ -23,7 +31,12 @@ public interface IEntityAccess {
     List<? extends EntityHuman> getPlayers();
 
     default List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
-        return this.getEntities(entity, axisalignedbb, IEntitySelector.f);
+        /* Concrete start - Add ret param */
+        return this.getEntities((List<Entity>)null, entity, axisalignedbb);
+    }
+    default List<Entity> getEntities(@Nullable List<Entity> ret, @Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+        return this.getEntities(entity, axisalignedbb, IEntitySelector.f, ret);
+        /* Concrete end - Add ret param */
     }
 
     default boolean a(@Nullable Entity entity, VoxelShape voxelshape) {
@@ -42,6 +55,93 @@ public interface IEntityAccess {
         return this.b(oclass, axisalignedbb, IEntitySelector.f);
     }
 
+    /* Concrete start */
+    // this function is copied from a(Entity, AxisAlignedBB, Set) but without streams
+    // this function is also duplicated below
+    default List<VoxelShape> getEntityShapesColliding(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Set<Entity> exclude,
+                                                  @Nullable List<Entity> tempEntityList, @Nullable List<VoxelShape> tempRetList) {
+        if (axisalignedbb.a() < 1.0E-7D) {
+            return tempRetList == null ? java.util.Collections.emptyList() : tempRetList;
+        }
+
+        AxisAlignedBB axisalignedbb1 = axisalignedbb.g(1.0E-7D);
+        List<Entity> entities = this.getEntities(tempEntityList, entity, axisalignedbb1);
+
+        if (entities.isEmpty()) {
+            return tempRetList == null ? java.util.Collections.emptyList() : tempRetList;
+        }
+
+        if (tempRetList == null) {
+            tempRetList = Lists.newArrayList();
+        }
+
+        for (Entity possibleCollide : entities) {
+            if (exclude != null && exclude.contains(possibleCollide)) {
+                continue;
+            }
+            if (entity != null && entity.rootVehiclesMatch(possibleCollide)) {
+                continue;
+            }
+
+            AxisAlignedBB current = possibleCollide.getHardCollisionBox();
+            if (current != null && axisalignedbb1.intersects(current)) {
+                tempRetList.add(VoxelShapes.of(current));
+            }
+
+            if (entity != null) {
+                current = entity.getHardCollisionWith(possibleCollide);
+                if (current != null && axisalignedbb1.intersects(current)) {
+                    tempRetList.add(VoxelShapes.of(current));
+                }
+            }
+        }
+
+        return tempRetList;
+    }
+
+    // copied from above
+    default boolean entityShapesCollidingAllMatch(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Set<Entity> exclude,
+                                                  @Nullable List<Entity> tempEntityList, Predicate<VoxelShape> predicate) {
+        if (axisalignedbb.a() < 1.0E-7D) {
+            return true;
+        }
+
+        AxisAlignedBB axisalignedbb1 = axisalignedbb.g(1.0E-7D);
+        List<Entity> entities = this.getEntities(tempEntityList, entity, axisalignedbb1);
+
+        if (entities.isEmpty()) {
+            return true;
+        }
+
+        for (Entity possibleCollide : entities) {
+            if (exclude != null && exclude.contains(possibleCollide)) {
+                continue;
+            }
+            if (entity != null && entity.rootVehiclesMatch(possibleCollide)) {
+                continue;
+            }
+
+            AxisAlignedBB current = possibleCollide.getHardCollisionBox();
+            if (current != null && axisalignedbb1.intersects(current)) {
+                if (!predicate.test(VoxelShapes.of(current))) {
+                    return false;
+                }
+            }
+
+            if (entity != null) {
+                current = entity.getHardCollisionWith(possibleCollide);
+                if (current != null && axisalignedbb1.intersects(current)) {
+                    if (!predicate.test(VoxelShapes.of(current))) {
+                        return false;
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+    /* Concrete end */
+
     default Stream<VoxelShape> b(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Set<Entity> set) {
         if (axisalignedbb.a() < 1.0E-7D) {
             return Stream.empty();
diff --git a/src/main/java/net/minecraft/server/IWorldReader.java b/src/main/java/net/minecraft/server/IWorldReader.java
index cbe2aa4c0acbdcc0b453fdad9a192a3e264406c6..9ffa9f2ade847cdf8c737cd440593796e22a6a8a 100644
--- a/src/main/java/net/minecraft/server/IWorldReader.java
+++ b/src/main/java/net/minecraft/server/IWorldReader.java
@@ -87,12 +87,291 @@ public interface IWorldReader extends IBlockLightAccess, ICollisionAccess, Biome
         return this.getChunkAt(i, j, chunkstatus, true);
     }
 
-    @Nullable
-    @Override
-    default IBlockAccess c(int i, int j) {
+    @Nullable default IBlockAccess getHighestStatusChunkAt(int x, int z) { return this.c(x, z); } @Override @Nullable default IBlockAccess c(int i, int j) { /* Concrete - OBFHELPER */
         return this.getChunkAt(i, j, ChunkStatus.EMPTY, false);
     }
 
+    /* Concrete start */
+    // note: order will be different than from the copied method
+    default java.util.Collection<VoxelShape> getCollidingBlocks(@Nullable Entity entity, AxisAlignedBB axisalignedbb,
+                                                          @Nullable java.util.Collection<VoxelShape> ret) {
+        // TODO obfhelpers
+        if (ret == null) {
+            ret = new java.util.ArrayList<>();
+        }
+
+        if (entity != null) {
+            VoxelShape voxelshape1 = IWorldReader.this.getWorldBorder().a();
+            boolean flag = VoxelShapes.c(voxelshape1, VoxelShapes.a(entity.getBoundingBox().shrink(1.0E-7D)), OperatorBoolean.AND);
+            boolean flag1 = VoxelShapes.c(voxelshape1, VoxelShapes.a(entity.getBoundingBox().g(1.0E-7D)), OperatorBoolean.AND);
+
+            if (!flag && flag1) {
+                ret.add(voxelshape1);
+            }
+        }
+
+        int minBlockX = MathHelper.floor(axisalignedbb.minX - 1.0E-7D) - 1;
+        int maxBlockX = MathHelper.floor(axisalignedbb.maxX + 1.0E-7D) + 1;
+
+        int minChunkX = minBlockX >> 4;
+        int maxChunkX = maxBlockX >> 4;
+
+        int minBlockY = MathHelper.floor(axisalignedbb.minY - 1.0E-7D) - 1;
+        int maxBlockY = MathHelper.floor(axisalignedbb.maxY + 1.0E-7D) + 1;
+
+        int minChunkY = minBlockY >> 4;
+        int maxChunkY = maxBlockY >> 4;
+
+        int minBlockZ = MathHelper.floor(axisalignedbb.minZ - 1.0E-7D) - 1;
+        int maxBlockZ = MathHelper.floor(axisalignedbb.maxZ + 1.0E-7D) + 1;
+
+        int minChunkZ = minBlockZ >> 4;
+        int maxChunkZ = maxBlockZ >> 4;
+
+        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity);
+        BlockPosition.MutableBlockPosition mutableBlockPosition = new BlockPosition.MutableBlockPosition();
+        VoxelShape voxelshape = VoxelShapes.of(axisalignedbb);
+
+        boolean useOptimizedGet = this instanceof WorldServer;
+        ChunkProviderServer chunkProvider = !useOptimizedGet ? null : ((WorldServer)this).getChunkProvider();
+
+        if (maxBlockY < 0) {
+            // no point in checking
+            return ret;
+        }
+
+        for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
+            int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
+            int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 15; // coordinate in chunk
+
+            for (int currChunkY = minChunkY; currChunkY <= maxChunkY; ++currChunkY) {
+                int minY = minBlockY;
+                int maxY = maxBlockY;
+
+                for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
+                    int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
+                    int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 15; // coordinate in chunk
+
+                    IChunkAccess chunk = useOptimizedGet ? chunkProvider.getChunkAtIfLoadedMainThread(currChunkX, currChunkZ) : // avoid loading chunks
+                            (IChunkAccess)this.getHighestStatusChunkAt(currChunkX, currChunkZ);
+
+                    if (chunk == null) {
+                        continue;
+                    }
+
+                    // TODO it might be better to throw the next 3 nested for loops into their own method.
+
+                    ChunkSection[] sections = chunk.getSections(); // TODO on update, make sure this is RAW access
+                    int maxSectionY = sections.length * 16;
+
+                    // bound y
+
+                    if (maxY >= maxSectionY) {
+                        maxY = maxSectionY - 1;
+                    }
+                    if (minY < 0) {
+                        minY = 0;
+                    }
+
+                    for (int currY = minY; currY <= maxY; ++currY) {
+                        ChunkSection section = sections[currY >>> 4];
+                        if (section == null) {
+                            // empty
+                            continue;
+                        }
+
+                        DataPaletteBlock<IBlockData> blocks = section.blockIds;
+                        int blockKeyY = (currY & 15) << 8;
+
+                        int edgeCountY = (currY == minY || currY == maxY) ? 1 : 0;
+
+                        for (int currX = minX; currX <= maxX; ++currX) {
+                            int blockKeyXY = blockKeyY | currX;
+                            int blockX = currX + (currChunkX << 4); // world position
+
+                            int edgeCountXY;
+                            if (blockX == minBlockX || blockX == maxBlockX) {
+                                edgeCountXY = edgeCountY + 1;
+                            } else {
+                                edgeCountXY = edgeCountY;
+                            }
+
+                            for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                                int blockZ = currZ + (currChunkZ << 4); // world position
+
+                                int edgeCountFull;
+                                if (blockZ == minBlockZ || blockZ == maxBlockZ) {
+                                    edgeCountFull = edgeCountXY + 1;
+                                } else {
+                                    edgeCountFull = edgeCountXY;
+                                }
+
+                                if (edgeCountFull == 3) {
+                                    continue;
+                                }
+
+                                int blockKeyFull = blockKeyXY | (currZ << 4);
+                                IBlockData blockData = blocks.rawGet(blockKeyFull);
+
+                                if ((edgeCountFull != 1 || blockData.f()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
+                                    mutableBlockPosition.setValues(blockX, currY, blockZ);
+                                    VoxelShape voxelshape2 = blockData.b((IBlockAccess)IWorldReader.this, mutableBlockPosition, collisionShape);
+                                    VoxelShape voxelshape3 = voxelshape2.a((double)blockX, (double)currY, (double)blockZ);
+
+                                    if (VoxelShapes.c(voxelshape, voxelshape3, OperatorBoolean.AND)) { // TODO Optimize, the enum axis cycle,
+                                        ret.add(voxelshape3);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return ret;
+    }
+
+    default boolean collidingBlocksMatchAll(@Nullable Entity entity, AxisAlignedBB axisalignedbb,
+                                                               java.util.function.Predicate<VoxelShape> predicate) {
+        // TODO obfhelpers
+        if (entity != null) {
+            VoxelShape voxelshape1 = IWorldReader.this.getWorldBorder().a();
+            boolean flag = VoxelShapes.c(voxelshape1, VoxelShapes.a(entity.getBoundingBox().shrink(1.0E-7D)), OperatorBoolean.AND);
+            boolean flag1 = VoxelShapes.c(voxelshape1, VoxelShapes.a(entity.getBoundingBox().g(1.0E-7D)), OperatorBoolean.AND);
+
+            if (!flag && flag1) {
+                if (!predicate.test(voxelshape1)) {
+                    return false;
+                }
+            }
+        }
+
+        int minBlockX = MathHelper.floor(axisalignedbb.minX - 1.0E-7D) - 1;
+        int maxBlockX = MathHelper.floor(axisalignedbb.maxX + 1.0E-7D) + 1;
+
+        int minChunkX = minBlockX >> 4;
+        int maxChunkX = maxBlockX >> 4;
+
+        int minBlockY = MathHelper.floor(axisalignedbb.minY - 1.0E-7D) - 1;
+        int maxBlockY = MathHelper.floor(axisalignedbb.maxY + 1.0E-7D) + 1;
+
+        int minChunkY = minBlockY >> 4;
+        int maxChunkY = maxBlockY >> 4;
+
+        int minBlockZ = MathHelper.floor(axisalignedbb.minZ - 1.0E-7D) - 1;
+        int maxBlockZ = MathHelper.floor(axisalignedbb.maxZ + 1.0E-7D) + 1;
+
+        int minChunkZ = minBlockZ >> 4;
+        int maxChunkZ = maxBlockZ >> 4;
+
+        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity);
+        BlockPosition.MutableBlockPosition mutableBlockPosition = new BlockPosition.MutableBlockPosition();
+        VoxelShape voxelshape = VoxelShapes.of(axisalignedbb);
+
+        boolean useOptimizedGet = this instanceof WorldServer;
+        ChunkProviderServer chunkProvider = !useOptimizedGet ? null : ((WorldServer)this).getChunkProvider();
+
+        if (maxBlockY < 0) {
+            // no point in checking
+            return true;
+        }
+
+        for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
+            int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
+            int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 15; // coordinate in chunk
+
+            for (int currChunkY = minChunkY; currChunkY <= maxChunkY; ++currChunkY) {
+                int minY = minBlockY;
+                int maxY = maxBlockY;
+
+                for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
+                    int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
+                    int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 15; // coordinate in chunk
+
+                    IChunkAccess chunk = useOptimizedGet ? chunkProvider.getChunkAtIfLoadedMainThread(currChunkX, currChunkZ) : // avoid loading chunks
+                            (IChunkAccess)this.getHighestStatusChunkAt(currChunkX, currChunkZ);
+
+                    if (chunk == null) {
+                        continue;
+                    }
+
+                    // TODO it might be better to throw the next 3 nested for loops into their own method.
+
+                    ChunkSection[] sections = chunk.getSections(); // TODO on update, make sure this is RAW access
+                    int maxSectionY = sections.length * 16;
+
+                    // bound y
+
+                    if (maxY >= maxSectionY) {
+                        maxY = maxSectionY - 1;
+                    }
+                    if (minY < 0) {
+                        minY = 0;
+                    }
+
+                    for (int currY = minY; currY <= maxY; ++currY) {
+                        ChunkSection section = sections[currY >>> 4];
+                        if (section == null) {
+                            // empty
+                            continue;
+                        }
+
+                        DataPaletteBlock<IBlockData> blocks = section.blockIds;
+                        int blockKeyY = (currY & 15) << 8;
+
+                        int edgeCountY = (currY == minY || currY == maxY) ? 1 : 0;
+
+                        for (int currX = minX; currX <= maxX; ++currX) {
+                            int blockKeyXY = blockKeyY | currX;
+                            int blockX = currX + (currChunkX << 4); // world position
+
+                            int edgeCountXY;
+                            if (blockX == minBlockX || blockX == maxBlockX) {
+                                edgeCountXY = edgeCountY + 1;
+                            } else {
+                                edgeCountXY = edgeCountY;
+                            }
+
+                            for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                                int blockZ = currZ + (currChunkZ << 4); // world position
+
+                                int edgeCountFull;
+                                if (blockZ == minBlockZ || blockZ == maxBlockZ) {
+                                    edgeCountFull = edgeCountXY + 1;
+                                } else {
+                                    edgeCountFull = edgeCountXY;
+                                }
+
+                                if (edgeCountFull == 3) {
+                                    continue;
+                                }
+
+                                int blockKeyFull = blockKeyXY | (currZ << 4);
+                                IBlockData blockData = blocks.rawGet(blockKeyFull);
+
+                                if ((edgeCountFull != 1 || blockData.f()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
+                                    mutableBlockPosition.setValues(blockX, currY, blockZ);
+                                    VoxelShape voxelshape2 = blockData.b((IBlockAccess)IWorldReader.this, mutableBlockPosition, collisionShape);
+                                    VoxelShape voxelshape3 = voxelshape2.a((double)blockX, (double)currY, (double)blockZ);
+
+                                    if (VoxelShapes.c(voxelshape, voxelshape3, OperatorBoolean.AND)) {
+                                        if (!predicate.test(voxelshape3)) {
+                                            return false;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+    /* Concrete end */
+
     default boolean y(BlockPosition blockposition) {
         return this.getFluid(blockposition).a(TagsFluid.WATER);
     }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index a192abc0c90625bb8d017b6c7f3bb45f5e1c31e1..2b346ca838d271619d65326006224b4acc6173a6 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1171,6 +1171,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         long remaining = (TICK_TIME - (endTime - lastTick)) - catchupTime;
         new com.destroystokyo.paper.event.server.ServerTickEndEvent(this.ticks, ((double)(endTime - lastTick) / 1000000D), remaining).callEvent();
         // Paper end
+        ca.spottedleaf.concrete.util.pool.CachedLists.reset(); /* Concrete */
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
     }
 
diff --git a/src/main/java/net/minecraft/server/VoxelShape.java b/src/main/java/net/minecraft/server/VoxelShape.java
index 0f95bcbccb96f9d525583f6bb6c0c0ed7fb7561b..82233166359f429e59433b9a3ece8b2a9b6cba5d 100644
--- a/src/main/java/net/minecraft/server/VoxelShape.java
+++ b/src/main/java/net/minecraft/server/VoxelShape.java
@@ -145,7 +145,7 @@ public abstract class VoxelShape {
         return this.a(EnumAxisCycle.a(enumdirection_enumaxis, EnumDirection.EnumAxis.X), axisalignedbb, d0);
     }
 
-    protected double a(EnumAxisCycle enumaxiscycle, AxisAlignedBB axisalignedbb, double d0) {
+    protected double a(EnumAxisCycle enumaxiscycle, AxisAlignedBB axisalignedbb, double d0) {//TODO optimize
         if (this.isEmpty()) {
             return d0;
         } else if (Math.abs(d0) < 1.0E-7D) {
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index 731ed7a7a6e9784719e18806b37e1c401ddacd45..f3ae06b80dbaae3602948ac254af6da8c59f9881 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -184,11 +184,32 @@ public final class VoxelShapes {
         return d0;
     }
 
+    /* Concrete start - optimize Entity#move */
+    public static double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb,
+                           org.bukkit.craftbukkit.util.UnsafeList<VoxelShape> stream, double d0) {
+        Object[] data = stream.getRawDataArray();
+        for (int i = 0, size = stream.size(); i < size; ++i) {
+            if (Math.abs(d0) < 1.0E-7D) {
+                return 0.0;
+            }
+            VoxelShape shape = (VoxelShape)data[i];
+            d0 = shape.a(enumdirection_enumaxis, axisalignedbb, d0);
+        }
+        return d0;
+    }
+    /* Concrete start - optimize Entity#move */
+
+    /* Concrete start - optimize Entity#move */
     public static double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, Stream<VoxelShape> stream) {
-        return a(axisalignedbb, iworldreader, d0, voxelshapecollision, EnumAxisCycle.a(enumdirection_enumaxis, EnumDirection.EnumAxis.Z), stream);
+        return a(axisalignedbb, iworldreader, d0, voxelshapecollision, EnumAxisCycle.a(enumdirection_enumaxis, EnumDirection.EnumAxis.Z), stream.iterator());
+    }
+
+    public static double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, Iterable<VoxelShape> stream) {
+        return a(axisalignedbb, iworldreader, d0, voxelshapecollision, EnumAxisCycle.a(enumdirection_enumaxis, EnumDirection.EnumAxis.Z), stream.iterator());
     }
 
-    private static double a(AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, EnumAxisCycle enumaxiscycle, Stream<VoxelShape> stream) {
+    private static double a(AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, EnumAxisCycle enumaxiscycle, Iterator<VoxelShape> stream) { // TODO optimize
+        /* Concrete end - optimize Entity#move */
         if (axisalignedbb.b() >= 1.0E-6D && axisalignedbb.c() >= 1.0E-6D && axisalignedbb.d() >= 1.0E-6D) {
             if (Math.abs(d0) < 1.0E-7D) {
                 return 0.0D;
@@ -254,12 +275,15 @@ public final class VoxelShapes {
                     l1 += k1;
                 }
 
-                double[] adouble = new double[]{d0};
+                /* Concrete start - optimize Entity#move */
+                double adouble = d0;
+                while (stream.hasNext()) {
+                    VoxelShape voxelshape = stream.next();
+                    adouble = voxelshape.a(enumdirection_enumaxis2, axisalignedbb, adouble);
+                }
 
-                stream.forEach((voxelshape) -> {
-                    adouble[0] = voxelshape.a(enumdirection_enumaxis2, axisalignedbb, adouble[0]);
-                });
-                return adouble[0];
+                return adouble;
+                /* Concrete end - optimize Entity#move */
             }
         } else {
             return d0;
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index c252664bc5d9c4ea60b3ae8045442e4f98097c8b..726976763f0c3940f947ec694b09d8a2e3ac8237 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1184,7 +1184,12 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
 
     @Override
     public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate) {
-        List<Entity> list = Lists.newArrayList();
+        /* Concrete start - Add ret param */
+        return this.getEntities(entity, axisalignedbb, predicate, (List)null);
+    }
+    public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate, @Nullable List<Entity> ret) {
+        List<Entity> list = ret == null ? Lists.newArrayList() : ret;
+        /* Concrete end - Add ret param */
         int i = MathHelper.floor((axisalignedbb.minX - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.maxX + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.minZ - 2.0D) / 16.0D);
diff --git a/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java b/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
index b3b0974365cf338a4b5a82a4eb5d257acf62d309..a273a2828ee355a59086785291043d3dd4daede1 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
@@ -119,6 +119,32 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
         return indexOf(o) >= 0;
     }
 
+    /* Concrete start */
+    int maxSize;
+    public void setSize(int size) {
+        if (maxSize < this.size) {
+            maxSize = this.size;
+        }
+        this.size = size;
+    }
+
+    public void completeReset() {
+        if (this.data != null) {
+            Arrays.fill(this.data, 0, Math.max(this.size, this.maxSize), null);
+        }
+        this.size = 0;
+        this.maxSize = 0;
+        if (this.iterPool != null) {
+            for (Iterator temp : this.iterPool) {
+                if (temp == null) {
+                    continue;
+                }
+                ((Itr)temp).valid = false;
+            }
+        }
+    }
+    /* Concrete end */
+
     @Override
     public void clear() {
         // Create new array to reset memory usage to initial capacity
-- 
2.24.0.windows.2

