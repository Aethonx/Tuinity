From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 27 Aug 2019 15:08:24 -0700
Subject: [PATCH] Remove logic creating lots of garbage on the heap

- PathfinderGoalSelector showed up at the top in memory profiling due
to streams

- ChunkMapDistance showed up at the top too due to bad iterator usage

- PlayerChunkMap#move and ChunkMap showed near the top when moving
around due to avoidable ChunkCoordIntPair allocations

- PathFinderNormal allocates a block position when checking the path
type of a block

- Either.Left/Right do not cache the optional returned for left()/right()
 (getChunk type calls all have to go through them...)

- ObjectAVLTreeSet does not override removeIf, so the default uses
an iterator. removeIf is invoked heavily in ChunkMapDistance (on every
tick). Replace with an impl that caches the iterator

- Some lighting stuff allocating AtomicInteger for passing a second
return value from a function. use a field since the JIT is not stack
allocating the variable

- Randomly ticking a block would allocate a BlockPosition, replace
with mutable pos

- Entity iteration for ticking would use a non-fast iterator, thus
creating lots of garbage entries.

- Replace how the chunk map and light data is updated
   Before the underlying maps were copy on write, however this obviously
   will not scale well at all for large player counts. The replacement is
   a system which will queue updates to a map locked by a seqlock.
   Intentionally, the constructors/fields were clobbered, breaking
   the ABI.

- Vec3d allocation by tracker for checking a simple delta

- Iterator usage in hot areas

diff --git a/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedAbstractDoubleList.java b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedAbstractDoubleList.java
new file mode 100644
index 0000000000000000000000000000000000000000..54b1878ccec21be399af4b89fff10ae94c03ad88
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedAbstractDoubleList.java
@@ -0,0 +1,39 @@
+package ca.spottedleaf.concrete.util.fastutil;
+
+import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+
+import java.util.List;
+
+public abstract class ExtendedAbstractDoubleList extends AbstractDoubleList {
+
+    @Override
+    public boolean equals(final Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof DoubleList)) {
+            if (other instanceof List) {
+                return super.equals(other);
+            }
+            return false;
+        }
+
+        final DoubleList otherList = (DoubleList)other;
+
+        final int otherSize = otherList.size();
+        final int thisSize = this.size();
+
+        if (otherSize != thisSize) {
+            return false;
+        }
+
+        for (int i = 0; i < thisSize; ++i) {
+            if (this.getDouble(i) != otherList.getDouble(i)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedDoubleArrayList.java b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedDoubleArrayList.java
new file mode 100644
index 0000000000000000000000000000000000000000..37a0fd2eb8473517f40877e9b784bb4a8c0e3013
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedDoubleArrayList.java
@@ -0,0 +1,65 @@
+package ca.spottedleaf.concrete.util.fastutil;
+
+import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class ExtendedDoubleArrayList extends DoubleArrayList {
+
+    public ExtendedDoubleArrayList() {
+        super();
+    }
+
+    public ExtendedDoubleArrayList(final int capacity) {
+        super(capacity);
+    }
+
+    public ExtendedDoubleArrayList(final double[] array) {
+        this(array, array.length, true);
+    }
+
+    public ExtendedDoubleArrayList(final double[] array, final int size, final boolean copy) {
+        super(copy ? array.clone() : array, false);
+        this.size = size;
+    }
+
+    public static ExtendedDoubleArrayList getList(final double[] list, final int requiredLength) {
+        if (list.length == requiredLength) {
+            return new ExtendedDoubleArrayList(list, requiredLength, false);
+        } else {
+            return new ExtendedDoubleArrayList(Arrays.copyOf(list, requiredLength), requiredLength, false);
+        }
+    }
+
+    @Override
+    public boolean equals(final Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof DoubleList)) {
+            if (other instanceof List) {
+                return super.equals(other);
+            }
+            return false;
+        }
+
+        final DoubleList otherList = (DoubleList)other;
+
+        final int otherSize = otherList.size();
+        final int thisSize = this.size();
+
+        if (otherSize != thisSize) {
+            return false;
+        }
+
+        for (int i = 0; i < thisSize; ++i) {
+            if (this.getDouble(i) != otherList.getDouble(i)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedObjectAVLTreeSet.java b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedObjectAVLTreeSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..2206beca4d39d4c12c3c8d1fbd7d0549618e46cf
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedObjectAVLTreeSet.java
@@ -0,0 +1,90 @@
+package ca.spottedleaf.concrete.util.fastutil;
+
+import it.unimi.dsi.fastutil.objects.ObjectAVLTreeSet;
+import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
+
+import java.lang.reflect.Field;
+import java.util.function.Predicate;
+
+public class ExtendedObjectAVLTreeSet<K> extends ObjectAVLTreeSet<K> {
+
+    private static final Field PREV_FIELD;
+    private static final Field NEXT_FIELD;
+    private static final Field CURR_FIELD;
+    private static final Field INDEX_FIELD;
+
+    private static final Integer ZERO = Integer.valueOf(0);
+
+    static {
+        try {
+            final Class clazz = Class.forName(ObjectAVLTreeSet.class.getCanonicalName() + "$SetIterator");
+            PREV_FIELD = clazz.getDeclaredField("prev");
+            PREV_FIELD.setAccessible(true);
+
+            NEXT_FIELD = clazz.getDeclaredField("next");
+            NEXT_FIELD.setAccessible(true);
+
+            CURR_FIELD = clazz.getDeclaredField("curr");
+            CURR_FIELD.setAccessible(true);
+
+            INDEX_FIELD = clazz.getDeclaredField("index");
+            INDEX_FIELD.setAccessible(true);
+        } catch (final Throwable thr) {
+            throw new RuntimeException(thr);
+        }
+    }
+
+    private ObjectBidirectionalIterator<K> cachedIterator = this.iterator();
+
+    {
+        this.nullIterator(this.cachedIterator);
+    }
+
+    @Override
+    public boolean removeIf(Predicate<? super K> filter) {
+        if (this.isEmpty()) {
+            return false;
+        }
+
+        if (this.cachedIterator == null) {
+            return super.removeIf(filter); // recursive...?
+        }
+
+        final ObjectBidirectionalIterator<K> iterator = this.cachedIterator;
+        this.cachedIterator = null;
+        this.startIterator(iterator);
+
+        boolean ret = false;
+
+        while (iterator.hasNext()) {
+            if (filter.test(iterator.next())) {
+                ret = true;
+                iterator.remove();
+            }
+        }
+
+        this.nullIterator(iterator);
+        this.cachedIterator = iterator;
+        return ret;
+    }
+
+    private void startIterator(final ObjectBidirectionalIterator<K> iterator) {
+        // assume iterator is null'd
+        try {
+            NEXT_FIELD.set(iterator, this.firstEntry);
+        } catch (final IllegalAccessException ex) {
+            throw new RuntimeException(ex); // not going to occur
+        }
+    }
+
+    private void nullIterator(final ObjectBidirectionalIterator<K> iterator) {
+        try {
+            PREV_FIELD.set(iterator, null);
+            NEXT_FIELD.set(iterator, null);
+            CURR_FIELD.set(iterator, null);
+            INDEX_FIELD.set(iterator, ZERO);
+        } catch (final IllegalAccessException ex) {
+            throw new RuntimeException(ex); // not going to occur
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/util/pool/PooledBlockPositions.java b/src/main/java/ca/spottedleaf/concrete/util/pool/PooledBlockPositions.java
new file mode 100644
index 0000000000000000000000000000000000000000..2438dba81884f6fc5f5a83961fa27fecf72e3182
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/pool/PooledBlockPositions.java
@@ -0,0 +1,40 @@
+package ca.spottedleaf.concrete.util.pool;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.MinecraftServer;
+
+public class PooledBlockPositions {
+
+    private static final int BLOCK_POOL_SIZE = 8192;
+
+    private static final BlockPosition.MutableBlockPosition[] POOL = new BlockPosition.MutableBlockPosition[BLOCK_POOL_SIZE];
+    private static int used = 0; // exclusive index of used positions
+
+    static {
+        for (int i = 0; i < BLOCK_POOL_SIZE; ++i) {
+            POOL[i] = new BlockPosition.MutableBlockPosition();
+        }
+    }
+
+    public static BlockPosition.MutableBlockPosition get(final int x, final int y, final int z) {
+        final int currentUsed = used;
+        if (Thread.currentThread() != MinecraftServer.getServer().serverThread || currentUsed >= POOL.length) {
+            return new BlockPosition.MutableBlockPosition(x, y, z);
+        }
+        used = currentUsed + 1;
+
+        final BlockPosition.MutableBlockPosition ret = POOL[currentUsed];
+        POOL[currentUsed] = null;
+
+        return ret.setValues(x, y, z);
+    }
+
+    public static void ret(final BlockPosition.MutableBlockPosition position) {
+        final int currentUsed = used;
+        if (Thread.currentThread() != MinecraftServer.getServer().serverThread || currentUsed == 0) {
+            return;
+        }
+
+        POOL[used = currentUsed - 1] = position;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/PaperCommand.java b/src/main/java/com/destroystokyo/paper/PaperCommand.java
index 132397b3f36e10d2eee266c257cecd96373015ff..662e6af3c2c77ed655b665397838b1869e55f429 100644
--- a/src/main/java/com/destroystokyo/paper/PaperCommand.java
+++ b/src/main/java/com/destroystokyo/paper/PaperCommand.java
@@ -215,7 +215,7 @@ public class PaperCommand extends Command {
             int ticking = 0;
             int entityTicking = 0;
 
-            for (PlayerChunk chunk : world.getChunkProvider().playerChunkMap.updatingChunks.values()) {
+            for (PlayerChunk chunk : world.getChunkProvider().playerChunkMap.chunkMap.getUpdatingValues()) { /* Concrete - replace chunk map */
                 if (chunk.getFullChunkIfCached() == null) {
                     continue;
                 }
diff --git a/src/main/java/com/mojang/datafixers/util/Either.java b/src/main/java/com/mojang/datafixers/util/Either.java
index a90adac7bd7ebd423f480e9ae0f44cb9d521fa4f..19763d89e5b2b09223b6a44fa11a7cfa179ec116 100644
--- a/src/main/java/com/mojang/datafixers/util/Either.java
+++ b/src/main/java/com/mojang/datafixers/util/Either.java
@@ -23,6 +23,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
     private static final class Left<L, R> extends Either<L, R> {
         private final L value;
+        private Optional<L> cachedLeft; /* Concrete - reduce allocation of these for chunks... */
 
         public Left(final L value) {
             this.value = value;
@@ -51,7 +52,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
         @Override
         public Optional<L> left() {
-            return Optional.of(value);
+            return this.cachedLeft == null ? this.cachedLeft = Optional.of(value) : this.cachedLeft; /* Concrete - cache optional */
         }
 
         @Override
@@ -84,6 +85,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
     private static final class Right<L, R> extends Either<L, R> {
         private final R value;
+        private Optional<R> cachedRight; /* Concrete - reduce allocation of these for chunks... */
 
         public Right(final R value) {
             this.value = value;
@@ -117,7 +119,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
         @Override
         public Optional<R> right() {
-            return Optional.of(value);
+            return this.cachedRight == null ? this.cachedRight = Optional.of(value) : this.cachedRight; /* Concrete - cache optional */
         }
 
         @Override
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index 16f0930404457772838e246d237e44c17e006764..e2bb63cc93fbda26f046592d02677fbd2b784ad4 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -449,6 +449,7 @@ public class BlockPosition extends BaseBlockPosition implements MinecraftSeriali
             return this.d(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
         }
 
+        public final BlockPosition.MutableBlockPosition setValues(final BaseBlockPosition baseblockposition) { return this.g(baseblockposition); } /* Concrete - OBFHELPER */
         public BlockPosition.MutableBlockPosition g(BaseBlockPosition baseblockposition) {
             return this.d(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
         }
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 55f9f4e6e7fddb2fcdbc1877d1bdfe8d3c9eff6f..50444a2f49f07e66ff9ea55dacc1819023ea6624 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -13,9 +13,10 @@ public abstract class ChunkMap extends LightEngineGraph {
 
     @Override
     protected void a(long i, int j, boolean flag) {
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int k = chunkcoordintpair.x;
-        int l = chunkcoordintpair.z;
+        /* Concrete start - remove allocation of ChunkCoordIntPair */
+        int k = ChunkCoordIntPair.getX(i);
+        int l = ChunkCoordIntPair.getZ(i);
+        /* Concrete end */
 
         for (int i1 = -1; i1 <= 1; ++i1) {
             for (int j1 = -1; j1 <= 1; ++j1) {
@@ -32,9 +33,10 @@ public abstract class ChunkMap extends LightEngineGraph {
     @Override
     protected int a(long i, long j, int k) {
         int l = k;
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int i1 = chunkcoordintpair.x;
-        int j1 = chunkcoordintpair.z;
+        /* Concrete start - remove allocation of ChunkCoordIntPair */
+        int i1 = ChunkCoordIntPair.getX(i);
+        int j1 = ChunkCoordIntPair.getZ(i);
+        /* Concrete end */
 
         for (int k1 = -1; k1 <= 1; ++k1) {
             for (int l1 = -1; l1 <= 1; ++l1) {
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 851bb2f01b1f59cf9d3fbd78c36d155b17efa1ab..7c5649de63d125e699bae4c3a91ac0ae82cf5d89 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -77,10 +77,14 @@ public abstract class ChunkMapDistance {
     }
 
     private int a(ObjectSortedSet<Ticket<?>> objectsortedset) {
-        ObjectBidirectionalIterator<Ticket<?>> objectbidirectionaliterator = objectsortedset.iterator();
+        return getLowestTicketLevel(objectsortedset); /* Concrete - this creates a lot of garbage so remove the iterator */
+    }
 
-        return objectbidirectionaliterator.hasNext() ? ((Ticket) objectbidirectionaliterator.next()).b() : PlayerChunkMap.GOLDEN_TICKET + 1;
+    /* Concrete start */
+    static int getLowestTicketLevel(ObjectSortedSet<Ticket<?>> set) {
+        return set.isEmpty() ? PlayerChunkMap.GOLDEN_TICKET + 1 : set.first().getTicketLevel();
     }
+    /* Concrete end */
 
     protected abstract boolean a(long i);
 
@@ -144,14 +148,9 @@ public abstract class ChunkMapDistance {
     private boolean addTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
         ca.spottedleaf.concrete.util.TickThread.softEnsureTickThread("Async ticket add"); /* Concrete */
         ObjectSortedSet<Ticket<?>> objectsortedset = this.e(i);
-        ObjectBidirectionalIterator<Ticket<?>> objectbidirectionaliterator = objectsortedset.iterator();
-        int j;
+        int j = getLowestTicketLevel(objectsortedset); /* Concrete - iterator creates a lot of garbage */
 
-        if (objectbidirectionaliterator.hasNext()) {
-            j = ((Ticket) objectbidirectionaliterator.next()).b();
-        } else {
-            j = PlayerChunkMap.GOLDEN_TICKET + 1;
-        }
+        /* Concrete - remove iterator usage */
 
         boolean ret = false; // CraftBukkit
         if (objectsortedset.add(ticket)) {
@@ -217,7 +216,7 @@ public abstract class ChunkMapDistance {
     private ObjectSortedSet<Ticket<?>> e(long i) {
         ca.spottedleaf.concrete.util.TickThread.softEnsureTickThread("Async tickets compute"); /* Concrete */
         return (ObjectSortedSet) this.tickets.computeIfAbsent(i, (j) -> {
-            return new ObjectAVLTreeSet();
+            return new ca.spottedleaf.concrete.util.fastutil.ExtendedObjectAVLTreeSet(); /* Concrete - Replace with optimized removeIf impl */
         });
     }
 
@@ -317,9 +316,7 @@ public abstract class ChunkMapDistance {
             if (objectsortedset == null) {
                 return Integer.MAX_VALUE;
             } else {
-                ObjectBidirectionalIterator<Ticket<?>> objectbidirectionaliterator = objectsortedset.iterator();
-
-                return !objectbidirectionaliterator.hasNext() ? Integer.MAX_VALUE : ((Ticket) objectbidirectionaliterator.next()).b();
+                return objectsortedset.isEmpty() ? Integer.MAX_VALUE : ((Ticket) objectsortedset.first()).b(); /* Concrete - iterator creates a lot of garbage */
             }
         }
 
@@ -372,7 +369,7 @@ public abstract class ChunkMapDistance {
         }
 
         public void a(int i) {
-            ObjectIterator objectiterator = this.a.long2ByteEntrySet().iterator();
+            ObjectIterator objectiterator = this.a.long2ByteEntrySet().fastIterator(); /* Concrete - use fast iterator (reduces entry creation) */
 
             while (objectiterator.hasNext()) {
                 it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
@@ -453,7 +450,7 @@ public abstract class ChunkMapDistance {
 
     class b extends ChunkMap {
 
-        protected final Long2ByteMap a = new Long2ByteOpenHashMap();
+        protected final Long2ByteOpenHashMap a = new Long2ByteOpenHashMap(); /* Concrete - change type for fast iterator */
         protected final int b;
 
         protected b(int i) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index e5b892bb3192aee3e5c6f17ac957c20a91fe6905..d7853daefca759588b2881eb18dc06b33422600c 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -607,6 +607,8 @@ public class ChunkProviderServer extends IChunkProvider {
         this.clearCache();
     }
 
+    private final List<PlayerChunk> chunksCopy = new java.util.ArrayList<>(8192); /* Concrete - replace chunk map */
+
     private void tickChunks() {
         long i = this.world.getTime();
         long j = i - this.lastTickTime;
@@ -644,7 +646,8 @@ public class ChunkProviderServer extends IChunkProvider {
 
             this.world.timings.countNaturalMobs.stopTiming(); // Paper - timings
             this.world.getMethodProfiler().exit();
-            this.playerChunkMap.f().forEach((playerchunk) -> {
+            this.chunksCopy.addAll(this.playerChunkMap.chunkMap.getVisibleValues()); /* Concrete - replace chunk map */
+            this.chunksCopy.forEach((playerchunk) -> { /* Concrete - replace chunk map */
                 Optional<Chunk> optional = ((Either) playerchunk.b().getNow(PlayerChunk.UNLOADED_CHUNK)).left();
 
                 if (optional.isPresent()) {
@@ -750,6 +753,7 @@ public class ChunkProviderServer extends IChunkProvider {
                     }
                 }
             });
+            this.chunksCopy.clear(); /* Concrete - replace chunk map */
             this.world.getMethodProfiler().enter("customSpawners");
             if (flag1) {
                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings
diff --git a/src/main/java/net/minecraft/server/DoubleListOffset.java b/src/main/java/net/minecraft/server/DoubleListOffset.java
index 73657f740731b9bc606e64d0a2a3f32a842db3f5..8dec9410868cef2b1b7974c4ff161f366587ef5c 100644
--- a/src/main/java/net/minecraft/server/DoubleListOffset.java
+++ b/src/main/java/net/minecraft/server/DoubleListOffset.java
@@ -3,7 +3,7 @@ package net.minecraft.server;
 import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 import it.unimi.dsi.fastutil.doubles.DoubleList;
 
-public class DoubleListOffset extends AbstractDoubleList {
+public class DoubleListOffset extends ca.spottedleaf.concrete.util.fastutil.ExtendedAbstractDoubleList { /* Concrete - remove iterator allocation */
 
     private final DoubleList a;
     private final double b;
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 5a990f0294f14ef5d7adbbcf51a53496ae6f1134..34d96f761aefcb2c33b29abad9a2a2c63133f999 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -1783,7 +1783,12 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void a(ChunkCoordIntPair chunkcoordintpair) {
-        this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(chunkcoordintpair.x, chunkcoordintpair.z));
+        /* Concrete start - remove ChunkCoordIntPair allocation */
+        this.sendChunkUnload(chunkcoordintpair.x, chunkcoordintpair.z);
+    }
+    public void sendChunkUnload(int chunkX, int chunkZ) {
+        this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(chunkX, chunkZ));
+        /* Concrete end */
     }
 
     public SectionPosition getPlayerMapSection() { return this.M(); } // Paper - OBFHELPER
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index fbac08c379659e2f38cb790d76f5428e8c92545f..f2f6ac9da615d1d3d0e026486af3359712459938 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -125,8 +125,12 @@ public class EntityTrackerEntry {
                 ++this.o;
                 i = MathHelper.d(this.tracker.yaw * 256.0F / 360.0F);
                 j = MathHelper.d(this.tracker.pitch * 256.0F / 360.0F);
-                Vec3D vec3d = (new Vec3D(this.tracker.locX, this.tracker.locY, this.tracker.locZ)).d(PacketPlayOutEntity.a(this.xLoc, this.yLoc, this.zLoc));
-                boolean flag1 = vec3d.g() >= 7.62939453125E-6D;
+                /* Concrete start - remove allocation of Vec3d here */
+                double vec3d_dx = this.tracker.locX - 2.44140625E-4D*(this.xLoc);
+                double vec3d_dy = this.tracker.locY - 2.44140625E-4D*(this.yLoc);
+                double vec3d_dz = this.tracker.locZ - 2.44140625E-4D*(this.zLoc);
+                boolean flag1 = (vec3d_dx * vec3d_dx + vec3d_dy * vec3d_dy + vec3d_dz * vec3d_dz) >= 7.62939453125E-6D;
+                /* Concrete end - remove allocation of Vec3d here */
                 Packet<?> packet1 = null;
                 boolean flag2 = flag1 || this.n % 60 == 0;
                 boolean flag3 = Math.abs(i - this.yRot) >= 1 || Math.abs(j - this.xRot) >= 1;
@@ -143,9 +147,11 @@ public class EntityTrackerEntry {
                 // CraftBukkit end
 
                 if (this.n > 0 || this.tracker instanceof EntityArrow) {
-                    long k = PacketPlayOutEntity.a(vec3d.x);
-                    long l = PacketPlayOutEntity.a(vec3d.y);
-                    long i1 = PacketPlayOutEntity.a(vec3d.z);
+                    /* Concrete start - remove allocation of Vec3d here */
+                    long k = PacketPlayOutEntity.a(vec3d_dx);
+                    long l = PacketPlayOutEntity.a(vec3d_dy);
+                    long i1 = PacketPlayOutEntity.a(vec3d_dz);
+                    /* Concrete end - remove allocation of Vec3d here */
                     boolean flag4 = k < -32768L || k > 32767L || l < -32768L || l > 32767L || i1 < -32768L || i1 > 32767L;
 
                     if (!flag4 && this.o <= 400 && !this.q && this.r == this.tracker.onGround) {
diff --git a/src/main/java/net/minecraft/server/LightEngineBlock.java b/src/main/java/net/minecraft/server/LightEngineBlock.java
index 7b0e24888e9f4bfbc0e65c6c59ca6f1b39d29c36..911f5834d528c60ecbdac1d71d42f57655ae250d 100644
--- a/src/main/java/net/minecraft/server/LightEngineBlock.java
+++ b/src/main/java/net/minecraft/server/LightEngineBlock.java
@@ -37,17 +37,19 @@ public final class LightEngineBlock extends LightEngineLayer<LightEngineStorageB
             if (enumdirection == null) {
                 return 15;
             } else {
-                AtomicInteger atomicinteger = new AtomicInteger();
-                IBlockData iblockdata = this.a(j, atomicinteger);
+                /* Concrete start - avoid allocating AtomicInteger */
+                IBlockData iblockdata = this.getTypeAndLevelForType(j, true);
+                int atomicinteger = this.lastLevel;
+                /* Concrete end - avoid allocating AtomicInteger */
 
-                if (atomicinteger.get() >= 15) {
+                if (atomicinteger >= 15) { /* Concrete - avoid allocating AtomicInteger */
                     return 15;
                 } else {
-                    IBlockData iblockdata1 = this.a(i, (AtomicInteger) null);
+                    IBlockData iblockdata1 = this.getTypeAndLevelForType(i, false); /* Concrete - avoid allocating AtomicInteger */
                     VoxelShape voxelshape = this.a(iblockdata1, i, enumdirection);
                     VoxelShape voxelshape1 = this.a(iblockdata, j, enumdirection.opposite());
 
-                    return VoxelShapes.b(voxelshape, voxelshape1) ? 15 : k + Math.max(1, atomicinteger.get());
+                    return VoxelShapes.b(voxelshape, voxelshape1) ? 15 : k + Math.max(1, atomicinteger); /* Concrete - avoid allocating AtomicInteger */
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/server/LightEngineLayer.java b/src/main/java/net/minecraft/server/LightEngineLayer.java
index bc5743501fb6b9b9d2c33afa2c781ce42f178136..72eef040a068a3bd90d5e24d92e433ff8d23686f 100644
--- a/src/main/java/net/minecraft/server/LightEngineLayer.java
+++ b/src/main/java/net/minecraft/server/LightEngineLayer.java
@@ -11,7 +11,7 @@ public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S e
     protected final EnumSkyBlock b;
     protected final S c;
     private boolean f;
-    protected final BlockPosition.MutableBlockPosition d = new BlockPosition.MutableBlockPosition();
+    protected final BlockPosition.MutableBlockPosition d = new BlockPosition.MutableBlockPosition(); protected int lastLevel; /* Concrete - avoid allocating AtomicInteger */
     private final long[] g = new long[2];
     private final IBlockAccess[] h = new IBlockAccess[2];
 
@@ -60,9 +60,18 @@ public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S e
     }
 
     protected IBlockData a(long i, @Nullable AtomicInteger atomicinteger) {
+        /* Concrete start - avoid allocating AtomicInteger */
+        IBlockData ret = this.getTypeAndLevelForType(i, atomicinteger != null);
+        if (atomicinteger != null) {
+            atomicinteger.lazySet(this.lastLevel);
+        }
+        return ret;
+    }
+    protected IBlockData getTypeAndLevelForType(long i, boolean getLevel) {
+        /* Concrete end */
         if (i == Long.MAX_VALUE) {
-            if (atomicinteger != null) {
-                atomicinteger.set(0);
+            if (getLevel) { /* Concrete - avoid allocating AtomicInteger */
+                this.lastLevel = 0; /* Concrete - avoid allocating AtomicInteger */
             }
 
             return Blocks.AIR.getBlockData();
@@ -72,8 +81,8 @@ public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S e
             IBlockAccess iblockaccess = this.a(j, k);
 
             if (iblockaccess == null) {
-                if (atomicinteger != null) {
-                    atomicinteger.set(16);
+                if (getLevel) { /* Concrete - avoid allocating AtomicInteger */
+                    this.lastLevel = 16; /* Concrete - avoid allocating AtomicInteger */
                 }
 
                 return Blocks.BEDROCK.getBlockData();
@@ -82,8 +91,8 @@ public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S e
                 IBlockData iblockdata = iblockaccess.getType(this.d);
                 boolean flag = iblockdata.o() && iblockdata.g();
 
-                if (atomicinteger != null) {
-                    atomicinteger.set(iblockdata.b(this.a.getWorld(), (BlockPosition) this.d));
+                if (getLevel) { /* Concrete - avoid allocating AtomicInteger */
+                    this.lastLevel = (iblockdata.b(this.a.getWorld(), (BlockPosition) this.d)); /* Concrete - avoid allocating AtomicInteger */
                 }
 
                 return flag ? iblockdata : Blocks.AIR.getBlockData();
diff --git a/src/main/java/net/minecraft/server/LightEngineSky.java b/src/main/java/net/minecraft/server/LightEngineSky.java
index 04c70d517c47edae497ec48bbff7a9d5d5f4e8a8..8c2597f0eece676500ac9a25a32a314f0966d96e 100644
--- a/src/main/java/net/minecraft/server/LightEngineSky.java
+++ b/src/main/java/net/minecraft/server/LightEngineSky.java
@@ -27,10 +27,12 @@ public final class LightEngineSky extends LightEngineLayer<LightEngineStorageSky
             if (k >= 15) {
                 return k;
             } else {
-                AtomicInteger atomicinteger = new AtomicInteger();
-                IBlockData iblockdata = this.a(j, atomicinteger);
+                /* Concrete start - avoid allocating AtomicInteger */
+                IBlockData iblockdata = this.getTypeAndLevelForType(j, true);
+                int atomicinteger = this.lastLevel;
+                /* Concrete end - avoid allocating AtomicInteger */
 
-                if (atomicinteger.get() >= 15) {
+                if (atomicinteger >= 15) { /* Concrete - avoid allocating AtomicInteger */
                     return 15;
                 } else {
                     int l = BlockPosition.b(i);
@@ -51,7 +53,7 @@ public final class LightEngineSky extends LightEngineLayer<LightEngineStorageSky
                         enumdirection = EnumDirection.a(j2, k2, l2);
                     }
 
-                    IBlockData iblockdata1 = this.a(i, (AtomicInteger) null);
+                    IBlockData iblockdata1 = this.getTypeAndLevelForType(i, false); /* Concrete - avoid allocating AtomicInteger */
                     VoxelShape voxelshape;
 
                     if (enumdirection != null) {
@@ -83,7 +85,7 @@ public final class LightEngineSky extends LightEngineLayer<LightEngineStorageSky
 
                     boolean flag1 = i == Long.MAX_VALUE || flag && i1 > l1;
 
-                    return flag1 && k == 0 && atomicinteger.get() == 0 ? 0 : k + Math.max(1, atomicinteger.get());
+                    return flag1 && k == 0 && atomicinteger == 0 ? 0 : k + Math.max(1, atomicinteger); /* Concrete - avoid allocating AtomicInteger */
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/server/LightEngineStorage.java b/src/main/java/net/minecraft/server/LightEngineStorage.java
index b2c960614f52616131e573c1b3b32b2aee6e2056..65111833d51748fbec4e4f00225d7d1ee0ef1b44 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorage.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorage.java
@@ -18,8 +18,8 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
     protected final LongSet b = new LongOpenHashSet();
     protected final LongSet c = new LongOpenHashSet();
     protected final LongSet d = new LongOpenHashSet();
-    protected volatile M e;
-    protected final M f;
+    protected volatile M e; /* Concrete - diff on change, should be "visible" */
+    protected final M f; /* Concrete - diff on change, should be "updating" */
     protected final LongSet g = new LongOpenHashSet();
     protected final LongSet h = new LongOpenHashSet();
     protected final Long2ObjectMap<NibbleArray> i = new Long2ObjectOpenHashMap();
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageArray.java b/src/main/java/net/minecraft/server/LightEngineStorageArray.java
index b978723a66d001f70325df0c7521025e079d7cfa..c1211a43d7672c067fd77cb67933e957e7481a0d 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageArray.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageArray.java
@@ -8,10 +8,17 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
     private final long[] b = new long[2];
     private final NibbleArray[] c = new NibbleArray[2];
     private boolean d;
-    protected final Long2ObjectOpenHashMap<NibbleArray> a;
+    protected final ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<NibbleArray> data; /* Concrete - avoid copying light data */
+    protected final boolean isVisible; /* Concrete - avoid copying light data */
 
-    protected LightEngineStorageArray(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap) {
-        this.a = long2objectopenhashmap;
+    /* Concrete start - avoid copying light data */
+    protected LightEngineStorageArray(ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<NibbleArray> data, boolean isVisible) {
+        if (isVisible) {
+            data.performUpdatesLockMap();
+        }
+        this.data = data;
+        this.isVisible = isVisible;
+        /* Concrete end - avoid copying light data */
         this.c();
         this.d = true;
     }
@@ -19,12 +26,13 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
     public abstract M b();
 
     public void a(long i) {
-        this.a.put(i, ((NibbleArray) this.a.get(i)).b());
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } /* Concrete - avoid copying light data */
+        this.data.queueUpdate(i, ((NibbleArray) this.data.getUpdating(i)).b()); /* Concrete - avoid copying light data */
         this.c();
     }
 
     public boolean b(long i) {
-        return this.a.containsKey(i);
+        return this.isVisible ? this.data.getVisibleAsync(i) != null : this.data.getUpdating(i) != null; /* Concrete - avoid copying light data */
     }
 
     @Nullable
@@ -37,7 +45,7 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
             }
         }
 
-        NibbleArray nibblearray = (NibbleArray) this.a.get(i);
+        NibbleArray nibblearray = (NibbleArray) (this.isVisible ? this.data.getVisibleAsync(i) : this.data.getUpdating(i)); /* Concrete - avoid copying light data */
 
         if (nibblearray == null) {
             return null;
@@ -58,11 +66,13 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
 
     @Nullable
     public NibbleArray d(long i) {
-        return (NibbleArray) this.a.remove(i);
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } /* Concrete - avoid copying light data */
+        return (NibbleArray) this.data.queueRemove(i); /* Concrete - avoid copying light data */
     }
 
     public void a(long i, NibbleArray nibblearray) {
-        this.a.put(i, nibblearray);
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } /* Concrete - avoid copying light data */
+        this.data.queueUpdate(i, nibblearray); /* Concrete - avoid copying light data */
     }
 
     public void c() {
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageBlock.java b/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
index 0f7f4744d9f9e5174fb38ccc72248397a4b064ea..6d07cfb6b885353be772da278dc3ea1e59c3f214 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
@@ -5,7 +5,7 @@ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 public class LightEngineStorageBlock extends LightEngineStorage<LightEngineStorageBlock.a> {
 
     protected LightEngineStorageBlock(ILightAccess ilightaccess) {
-        super(EnumSkyBlock.BLOCK, ilightaccess, new LightEngineStorageBlock.a(new Long2ObjectOpenHashMap()));
+        super(EnumSkyBlock.BLOCK, ilightaccess, new LightEngineStorageBlock.a(new ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<>(), false)); /* Concrete - avoid copying light data */
     }
 
     @Override
@@ -18,13 +18,13 @@ public class LightEngineStorageBlock extends LightEngineStorage<LightEngineStora
 
     public static final class a extends LightEngineStorageArray<LightEngineStorageBlock.a> {
 
-        public a(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap) {
-            super(long2objectopenhashmap);
+        public a(ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<NibbleArray> long2objectopenhashmap, boolean isVisible) { /* Concrete - avoid copying light data */
+            super(long2objectopenhashmap, isVisible); /* Concrete - avoid copying light data */
         }
 
         @Override
         public LightEngineStorageBlock.a b() {
-            return new LightEngineStorageBlock.a(this.a.clone());
+            return new a(this.data, true); /* Concrete - avoid copying light data */
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageSky.java b/src/main/java/net/minecraft/server/LightEngineStorageSky.java
index b240261bdc6c941ed4a480be7d23f2b9346da788..2cf336bcaeea4d366fb8724905029bc9eb7ed44d 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageSky.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageSky.java
@@ -17,7 +17,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     private volatile boolean p;
 
     protected LightEngineStorageSky(ILightAccess ilightaccess) {
-        super(EnumSkyBlock.SKY, ilightaccess, new LightEngineStorageSky.a(new Long2ObjectOpenHashMap(), new Long2IntOpenHashMap(), Integer.MAX_VALUE));
+        super(EnumSkyBlock.SKY, ilightaccess, new LightEngineStorageSky.a(new ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<>(), new ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Int(), Integer.MAX_VALUE)); /* Concrete - avoid copying light data */
     }
 
     @Override
@@ -25,7 +25,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
         long j = SectionPosition.e(i);
         int k = SectionPosition.c(j);
         LightEngineStorageSky.a lightenginestoragesky_a = (LightEngineStorageSky.a) this.e;
-        int l = lightenginestoragesky_a.c.get(SectionPosition.f(j));
+        int l = lightenginestoragesky_a.otherData.getVisibleAsync(SectionPosition.f(j)); /* Concrete - avoid copying light data */
 
         if (l != lightenginestoragesky_a.b && k < l) {
             NibbleArray nibblearray = this.a(lightenginestoragesky_a, j); /* Concrete - decompile fix */
@@ -54,14 +54,14 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
         if (((LightEngineStorageSky.a) this.f).b > j) {
             ((LightEngineStorageSky.a) this.f).b = j;
-            ((LightEngineStorageSky.a) this.f).c.defaultReturnValue(((LightEngineStorageSky.a) this.f).b);
+            ((LightEngineStorageSky.a) this.f).otherData.queueDefaultReturnValue(((LightEngineStorageSky.a) this.f).b); /* Concrete - avoid copying light data */
         }
 
         long k = SectionPosition.f(i);
-        int l = ((LightEngineStorageSky.a) this.f).c.get(k);
+        int l = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(k); /* Concrete - avoid copying light data */
 
         if (l < j + 1) {
-            ((LightEngineStorageSky.a) this.f).c.put(k, j + 1);
+            ((LightEngineStorageSky.a) this.f).otherData.queueUpdate(k, j + 1); /* Concrete - avoid copying light data */
             if (this.o.contains(k)) {
                 this.q(i);
                 if (l > ((LightEngineStorageSky.a) this.f).b) {
@@ -101,7 +101,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
         int k = SectionPosition.c(i);
 
-        if (((LightEngineStorageSky.a) this.f).c.get(j) == k + 1) {
+        if (((LightEngineStorageSky.a) this.f).otherData.getUpdating(j) == k + 1) { /* Concrete - avoid copying light data */
             long l;
 
             for (l = i; !this.g(l) && this.a(k); l = SectionPosition.a(l, EnumDirection.DOWN)) {
@@ -109,12 +109,12 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             }
 
             if (this.g(l)) {
-                ((LightEngineStorageSky.a) this.f).c.put(j, k + 1);
+                ((LightEngineStorageSky.a) this.f).otherData.queueUpdate(j, k + 1); /* Concrete - avoid copying light data */
                 if (flag) {
                     this.q(l);
                 }
             } else {
-                ((LightEngineStorageSky.a) this.f).c.remove(j);
+                ((LightEngineStorageSky.a) this.f).otherData.queueRemove(j); /* Concrete - avoid copying light data */
             }
         }
 
@@ -127,7 +127,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     @Override
     protected void b(long i, boolean flag) {
         if (flag && this.o.add(i)) {
-            int j = ((LightEngineStorageSky.a) this.f).c.get(i);
+            int j = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(i); /* Concrete - avoid copying light data */
 
             if (j != ((LightEngineStorageSky.a) this.f).b) {
                 long k = SectionPosition.b(SectionPosition.b(i), j - 1, SectionPosition.d(i));
@@ -154,7 +154,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             return nibblearray;
         } else {
             long j = SectionPosition.a(i, EnumDirection.UP);
-            int k = ((LightEngineStorageSky.a) this.f).c.get(SectionPosition.f(i));
+            int k = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(SectionPosition.f(i)); /* Concrete - avoid copying light data */
 
             if (k != ((LightEngineStorageSky.a) this.f).b && SectionPosition.c(j) < k) {
                 NibbleArray nibblearray1;
@@ -297,7 +297,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             if (!this.o.contains(l)) {
                 return false;
             } else {
-                int i1 = ((LightEngineStorageSky.a) this.f).c.get(l);
+                int i1 = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(l); /* Concrete - avoid copying light data */
 
                 return SectionPosition.c(i1) == j + 16;
             }
@@ -306,7 +306,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
     protected boolean n(long i) {
         long j = SectionPosition.f(i);
-        int k = ((LightEngineStorageSky.a) this.f).c.get(j);
+        int k = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(j); /* Concrete - avoid copying light data */
 
         return k == ((LightEngineStorageSky.a) this.f).b || SectionPosition.c(i) >= k;
     }
@@ -320,18 +320,20 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     public static final class a extends LightEngineStorageArray<LightEngineStorageSky.a> {
 
         private int b;
-        private final Long2IntOpenHashMap c;
+        private final ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Int otherData; /* Concrete - avoid copying light data */
 
-        public a(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap, Long2IntOpenHashMap long2intopenhashmap, int i) {
-            super(long2objectopenhashmap);
-            this.c = long2intopenhashmap;
-            long2intopenhashmap.defaultReturnValue(i);
+        /* Concrete start - avoid copying light data */
+        public a(ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<NibbleArray> data, ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Int otherData, int i) {
+            super(data, false);
+            this.otherData = otherData;
+            /* Concrete end - avoid copying light data */
             this.b = i;
         }
 
         @Override
         public LightEngineStorageSky.a b() {
-            return new LightEngineStorageSky.a(this.a.clone(), this.c.clone(), this.b);
+            this.otherData.performUpdatesLockMap(); /* Concrete - avoid copying light data */
+            return new LightEngineStorageSky.a(this.data, this.otherData, this.b); /* Concrete - avoid copying light data */
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 14f8b610422fcda13818e3a54ce538a6902746de..3bd80572a4b94ee5cfd32055d2fffb745061e521 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -432,9 +432,9 @@ public final class MCUtil {
 
             WorldServer world = ((org.bukkit.craftbukkit.CraftWorld)bukkitWorld).getHandle();
             PlayerChunkMap chunkMap = world.getChunkProvider().playerChunkMap;
-            Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks = chunkMap.visibleChunks;
+            /* Concrete - replace chunk map */
             ChunkMapDistance chunkMapDistance = chunkMap.getChunkMapDistanceManager();
-            List<PlayerChunk> allChunks = new ArrayList<>(visibleChunks.values());
+            List<PlayerChunk> allChunks = chunkMap.chunkMap.getUpdatingValuesCopy(); /* Concrete - replace chunk map */
             List<EntityPlayer> players = world.players;
 
             int fullLoadedChunks = 0;
@@ -457,7 +457,7 @@ public final class MCUtil {
             worldData.addProperty("view-distance", world.spigotConfig.viewDistance);
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig.keepLoadedRange);
-            worldData.addProperty("visible-chunk-count", visibleChunks.size());
+            worldData.addProperty("visible-chunk-count", allChunks.size()); /* Concrete - replace chunk map */
             worldData.addProperty("loaded-chunk-count", chunkMap.loadedChunks.size());
             worldData.addProperty("verified-fully-loaded-chunks", fullLoadedChunks);
 
@@ -535,4 +535,28 @@ public final class MCUtil {
         // TODO make sure the constant `33` is correct on future updates. See getChunkAt(int, int, ChunkStatus, boolean)
         return 33 + ChunkStatus.getTicketLevelOffset(status);
     }
+
+    public static <E> boolean hasCommonElement(Set<E> set0, Set<E> set1) {
+        java.util.Iterator<E> iterator;
+        Set<E> target;
+
+        // optimize by iterating over fewest entries possible
+        if (set0.size() <= set1.size()) {
+            target = set1;
+            iterator = set0.iterator();
+        } else {
+            target = set0;
+            iterator = set1.iterator();
+        }
+
+        while (iterator.hasNext()) {
+            E element = iterator.next();
+            if (target.contains(element)) {
+                return true;
+            }
+        }
+
+        return false;
+
+    }
 }
diff --git a/src/main/java/net/minecraft/server/PairedQueue.java b/src/main/java/net/minecraft/server/PairedQueue.java
index 85bb22e4b7376b676139048f2d55684e27a54055..506cd658cce3bb194846928c38e9d6cdeb4ab47b 100644
--- a/src/main/java/net/minecraft/server/PairedQueue.java
+++ b/src/main/java/net/minecraft/server/PairedQueue.java
@@ -20,32 +20,30 @@ public interface PairedQueue<T, F> {
 
     public static final class a implements PairedQueue<PairedQueue.b, Runnable> {
 
-        private final List<Queue<Runnable>> a;
+        private final List<Queue<Runnable>> a; private final List<Queue<Runnable>> getQueues() { return this.a; } /* Concrete - OBFHELPER */
 
         public a(int i) {
-            this.a = (List) IntStream.range(0, i).mapToObj((j) -> {
-                return Queues.newConcurrentLinkedQueue();
-            }).collect(Collectors.toList());
+            /* Concrete start - reduce streams */
+            this.a = new java.util.ArrayList<>(i); // queues
+            for (int j = 0; j < i; ++j) {
+                this.getQueues().add(new ca.spottedleaf.concurrentutil.queue.MultiThreadedQueue<>()); // use MT queue
+            }
+            /* Concrete end - reduce streams */
         }
 
         @Nullable
         @Override
         public Runnable a() {
-            Iterator iterator = this.a.iterator();
-
-            Runnable runnable;
-
-            do {
-                if (!iterator.hasNext()) {
-                    return null;
+            /* Concrete start - reduce iterator creation */
+            for (int i = 0, len = this.getQueues().size(); i < len; ++i) {
+                Queue<Runnable> queue = this.getQueues().get(i);
+                Runnable ret = queue.poll();
+                if (ret != null) {
+                    return ret;
                 }
-
-                Queue<Runnable> queue = (Queue) iterator.next();
-
-                runnable = (Runnable) queue.poll();
-            } while (runnable == null);
-
-            return runnable;
+            }
+            return null;
+            /* Concrete end - reduce iterator creation */
         }
 
         public boolean a(PairedQueue.b pairedqueue_b) {
@@ -57,7 +55,15 @@ public interface PairedQueue<T, F> {
 
         @Override
         public boolean b() {
-            return this.a.stream().allMatch(Collection::isEmpty);
+            /* Concrete start - reduce streams */
+            for (int i = 0, len = this.getQueues().size(); i < len; ++i) {
+                Queue<Runnable> queue = this.getQueues().get(i);
+                if (!queue.isEmpty()) {
+                    return false;
+                }
+            }
+            return true;
+            /* Concrete end - reduce streams */
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/PathfinderGoal.java b/src/main/java/net/minecraft/server/PathfinderGoal.java
index db6ed37863236eac7eafafb2636db656c9ba1265..0515692acb55cd5a15604819f8943519f566b07a 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoal.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoal.java
@@ -1,10 +1,11 @@
 package net.minecraft.server;
 
+import ca.spottedleaf.concrete.util.OptimizedSmallEnumSet; /* Concrete */
 import java.util.EnumSet;
 
 public abstract class PathfinderGoal {
 
-    private final EnumSet<PathfinderGoal.Type> a = EnumSet.noneOf(PathfinderGoal.Type.class);
+    private final OptimizedSmallEnumSet<Type> goalTypes = new OptimizedSmallEnumSet<>(PathfinderGoal.Type.class); /* Concrete - reduce garbage on heap */
 
     public PathfinderGoal() {}
 
@@ -25,12 +26,16 @@ public abstract class PathfinderGoal {
     public void e() {}
 
     public void a(EnumSet<PathfinderGoal.Type> enumset) {
-        this.a.clear();
-        this.a.addAll(enumset);
+        /* Concrete start - reduce garbage on heap */
+        this.goalTypes.clear();
+        this.goalTypes.addAllUnchecked(enumset);
+        /* Concrete end - reduce garbage on heap */
     }
 
-    public EnumSet<PathfinderGoal.Type> i() {
-        return this.a;
+    /* Concrete start - reduce garbage on heap */
+    public ca.spottedleaf.concrete.util.OptimizedSmallEnumSet<PathfinderGoal.Type> getGoalTypes() {
+        return this.goalTypes;
+        /* Concrete end - reduce garbage on heap */
     }
 
     public static enum Type {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
index 44bb18c5945b69f09b3a6e6272f2c3a5477780c7..6efac5babf33bcef682751e9ce1829089d4c6e06 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
@@ -1,8 +1,10 @@
 package net.minecraft.server;
 
+import ca.spottedleaf.concrete.util.OptimizedSmallEnumSet;
 import com.google.common.collect.Sets;
 import java.util.EnumMap;
 import java.util.EnumSet;
+import java.util.Iterator; /* Concrete */
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Stream;
@@ -26,7 +28,7 @@ public class PathfinderGoalSelector {
     private final Map<PathfinderGoal.Type, PathfinderGoalWrapped> c = new EnumMap(PathfinderGoal.Type.class);
     private final Set<PathfinderGoalWrapped> d = Sets.newLinkedHashSet();
     private final GameProfilerFiller e;
-    private final EnumSet<PathfinderGoal.Type> f = EnumSet.noneOf(PathfinderGoal.Type.class);
+    private final OptimizedSmallEnumSet<PathfinderGoal.Type> goalTypes = new OptimizedSmallEnumSet<>(PathfinderGoal.Type.class); /* Concrete - reduce garbage on heap */
     private int g = 3;
 
     public PathfinderGoalSelector(GameProfilerFiller gameprofilerfiller) {
@@ -38,33 +40,38 @@ public class PathfinderGoalSelector {
     }
 
     public void a(PathfinderGoal pathfindergoal) {
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        }).filter(PathfinderGoalWrapped::g).forEach(PathfinderGoalWrapped::d);
-        this.d.removeIf((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        });
+        /* Concrete start - remove streams */
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped goalWrapped = iterator.next();
+            if (goalWrapped.j() != pathfindergoal) {
+                continue;
+            }
+            if (goalWrapped.g()) {
+                goalWrapped.d();
+            }
+            iterator.remove();
+        }
+        /* Concrete end */
     }
 
+    private static final PathfinderGoal.Type[] PATHFINDER_GOAL_TYPES = PathfinderGoal.Type.values();
+
     public void doTick() {
         this.e.enter("goalCleanup");
-        this.c().filter((pathfindergoalwrapped) -> {
-            boolean flag;
-
-            if (pathfindergoalwrapped.g()) {
-                Stream stream = pathfindergoalwrapped.i().stream();
-                EnumSet enumset = this.f;
+        /* Concrete start - remove streams */
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (!wrappedGoal.g()) {
+                continue;
+            }
 
-                this.f.getClass();
-                if (!stream.anyMatch(enumset::contains) && pathfindergoalwrapped.b()) {
-                    flag = false;
-                    return flag;
-                }
+            if (!this.goalTypes.hasCommonElements(wrappedGoal.getGoalTypes()) && wrappedGoal.b()) {
+                continue;
             }
 
-            flag = true;
-            return flag;
-        }).forEach(PathfinderGoal::d);
+            wrappedGoal.d();
+        }
+        /* Concrete end */
         this.c.forEach((pathfindergoal_type, pathfindergoalwrapped) -> {
             if (!pathfindergoalwrapped.g()) {
                 this.c.remove(pathfindergoal_type);
@@ -73,30 +80,54 @@ public class PathfinderGoalSelector {
         });
         this.e.exit();
         this.e.enter("goalUpdate");
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return !pathfindergoalwrapped.g();
-        }).filter((pathfindergoalwrapped) -> {
-            Stream stream = pathfindergoalwrapped.i().stream();
-            EnumSet enumset = this.f;
-
-            this.f.getClass();
-            return stream.noneMatch(enumset::contains);
-        }).filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.i().stream().allMatch((pathfindergoal_type) -> {
-                return ((PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b)).a(pathfindergoalwrapped);
-            });
-        }).filter(PathfinderGoalWrapped::a).forEach((pathfindergoalwrapped) -> {
-            pathfindergoalwrapped.i().forEach((pathfindergoal_type) -> {
-                PathfinderGoalWrapped pathfindergoalwrapped1 = (PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b);
-
-                pathfindergoalwrapped1.d();
-                this.c.put(pathfindergoal_type, pathfindergoalwrapped);
-            });
-            pathfindergoalwrapped.c();
-        });
+        /* Concrete start - remove streams */
+        goal_update_loop: for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (wrappedGoal.g()) {
+                continue;
+            }
+
+            OptimizedSmallEnumSet<PathfinderGoal.Type> wrappedGoalSet = wrappedGoal.getGoalTypes();
+
+            if (this.goalTypes.hasCommonElements(wrappedGoalSet)) {
+                continue;
+            }
+
+            for (long iterator1 = wrappedGoalSet.getBackingSet(); iterator1 != 0;) {
+                PathfinderGoal.Type type = PATHFINDER_GOAL_TYPES[Long.numberOfTrailingZeros(iterator1)];
+                iterator1 ^= ca.spottedleaf.concurrentutil.util.IntegerUtil.getTrailingBit(iterator1);
+                PathfinderGoalWrapped wrapped = this.c.getOrDefault(type, PathfinderGoalSelector.b);
+                if (!wrapped.a(wrappedGoal)) {
+                    continue goal_update_loop;
+                }
+            }
+
+            if (!wrappedGoal.a()) {
+                continue;
+            }
+
+            for (long iterator1 = wrappedGoalSet.getBackingSet(); iterator1 != 0;) {
+                PathfinderGoal.Type type = PATHFINDER_GOAL_TYPES[Long.numberOfTrailingZeros(iterator1)];
+                iterator1 ^= ca.spottedleaf.concurrentutil.util.IntegerUtil.getTrailingBit(iterator1);
+                PathfinderGoalWrapped wrapped = this.c.getOrDefault(type, PathfinderGoalSelector.b);
+
+                wrapped.d();
+                this.c.put(type, wrappedGoal);
+            }
+
+            wrappedGoal.c();
+        }
+        /* Concrete end */
         this.e.exit();
         this.e.enter("goalTick");
-        this.c().forEach(PathfinderGoalWrapped::e);
+        /* Concrete start - remove streams */
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (wrappedGoal.g()) {
+                wrappedGoal.e();
+            }
+        }
+        /* Concrete end */
         this.e.exit();
     }
 
@@ -105,11 +136,11 @@ public class PathfinderGoalSelector {
     }
 
     public void a(PathfinderGoal.Type pathfindergoal_type) {
-        this.f.add(pathfindergoal_type);
+        this.goalTypes.addUnchecked(pathfindergoal_type); /* Concrete - reduce streams */
     }
 
     public void b(PathfinderGoal.Type pathfindergoal_type) {
-        this.f.remove(pathfindergoal_type);
+        this.goalTypes.removeUnchecked(pathfindergoal_type); /* Concrete - reduce streams */
     }
 
     public void a(PathfinderGoal.Type pathfindergoal_type, boolean flag) {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java b/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
index 182cd7e9110408fff9909ef362d368d055a2b167..cdeac6a5a265a5a695fcac1a99735c705a943438 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
@@ -60,8 +60,10 @@ public class PathfinderGoalWrapped extends PathfinderGoal {
     }
 
     @Override
-    public EnumSet<PathfinderGoal.Type> i() {
-        return this.a.i();
+    /* Concrete start - reduce garbage on heap */
+    public ca.spottedleaf.concrete.util.OptimizedSmallEnumSet<PathfinderGoal.Type> getGoalTypes() {
+        return this.a.getGoalTypes();
+        /* Concrete end - reduce garbage on heap */
     }
 
     public boolean g() {
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 45fd135034de668c1f4282fe538e8d352db49278..d871ac2ad1ae38a160f8cb4e3f158c2e46d75db5 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -421,8 +421,10 @@ public class PathfinderNormal extends PathfinderAbstract {
         return pathtype;
     }
 
+    private static final BlockPosition.MutableBlockPosition PATH_TYPE_BLOCKPOSITION = new BlockPosition.MutableBlockPosition(); /* Concrete - this shows to be a high allocator */
+
     protected PathType b(IBlockAccess iblockaccess, int i, int j, int k) {
-        BlockPosition blockposition = new BlockPosition(i, j, k);
+        final BlockPosition.MutableBlockPosition blockposition = PATH_TYPE_BLOCKPOSITION.setValues(i, j, k); /* Concrete - this shows to be a high allocator */
         IBlockData iblockdata = iblockaccess.getTypeIfLoaded(blockposition); // Paper
         if (iblockdata == null) return PathType.BLOCKED; // Paper
         Block block = iblockdata.getBlock();
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 7512660a5b94b04cd48a8ff824b50499120bd8fc..07256c6497a6479ce988a6800de7045215338481 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -54,8 +54,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     private static final Logger LOGGER = LogManager.getLogger();
     public static final int GOLDEN_TICKET = 33 + ChunkStatus.b();
-    public final Long2ObjectLinkedOpenHashMap<PlayerChunk> updatingChunks = new Long2ObjectLinkedOpenHashMap();
-    public volatile Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks;
+    //public final Long2ObjectLinkedOpenHashMap<PlayerChunk> updatingChunks = new Long2ObjectLinkedOpenHashMap(); /* Concrete - replace chunk map */
+    //public volatile Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks; /* Concrete - replace chunk map */
+    public final ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<PlayerChunk> chunkMap = new ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<>(8192, 0.7f); /* Concrete - replace chunk map */
     private final Long2ObjectLinkedOpenHashMap<PlayerChunk> pendingUnload;
     final LongSet loadedChunks; // Paper - private -> package
     public final WorldServer world;
@@ -136,7 +137,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     public PlayerChunkMap(WorldServer worldserver, File file, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, IAsyncTaskHandler<Runnable> iasynctaskhandler, ILightAccess ilightaccess, ChunkGenerator<?> chunkgenerator, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier, int i) {
         super(new File(worldserver.getWorldProvider().getDimensionManager().a(file), "region"), datafixer);
-        this.visibleChunks = this.updatingChunks.clone();
+        //this.visibleChunks = this.updatingChunks.clone(); /* Concrete - replace chunk map */
         this.pendingUnload = new Long2ObjectLinkedOpenHashMap();
         this.loadedChunks = new LongOpenHashSet();
         this.unloadQueue = new LongOpenHashSet();
@@ -227,8 +228,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     private static int a(ChunkCoordIntPair chunkcoordintpair, int i, int j) {
-        int k = chunkcoordintpair.x - i;
-        int l = chunkcoordintpair.z - j;
+        /* Concrete start - remove ChunkCoordIntPair allocation */
+        return getSquareRadiusDistance(chunkcoordintpair.x, chunkcoordintpair.z, i, j);
+    }
+    private static int getSquareRadiusDistance(int chunkX0, int chunkZ0, int i, int j) {
+        int k = chunkX0 - i;
+        int l = chunkZ0 - j;
+        /* Concrete end */
 
         return Math.max(Math.abs(k), Math.abs(l));
     }
@@ -239,12 +245,17 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     @Nullable
     protected PlayerChunk getUpdatingChunk(long i) {
-        return (PlayerChunk) this.updatingChunks.get(i);
+        return (PlayerChunk) this.chunkMap.getUpdating(i); /* Concrete - replace chunk map */
     }
 
     @Nullable
     public PlayerChunk getVisibleChunk(long i) { // Paper - protected -> public
-        return (PlayerChunk) this.visibleChunks.get(i);
+        /* Concrete start - replace chunk map */
+        if (MinecraftServer.getServer().isMainThread()) {
+            return this.chunkMap.getVisible(i);
+        }
+        return (PlayerChunk) this.chunkMap.getVisibleAsync(i);
+        /* Concrete end - replace chunk map */
     }
 
     protected IntSupplier c(long i) {
@@ -346,7 +357,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     playerchunk = new PlayerChunk(new ChunkCoordIntPair(i), j, this.lightEngine, this.q, this);
                 }
 
-                this.updatingChunks.put(i, playerchunk);
+                this.chunkMap.queueUpdate(i, playerchunk); /* Concrete - replace chunk map */
                 this.updatingChunksModified = true;
             }
 
@@ -365,7 +376,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Paper start - derived from below
     protected void saveIncrementally() {
         int savedThisTick = 0;
-        for (PlayerChunk playerchunk : visibleChunks.values()) {
+        for (PlayerChunk playerchunk : this.chunkMap.getVisibleValues()) { /* Concrete - replace chunk map */
             if (playerchunk.hasBeenLoaded()) {
 
                 IChunkAccess ichunkaccess = (IChunkAccess) playerchunk.getChunkSave().getNow(null); // CraftBukkit - decompile error
@@ -394,7 +405,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     protected void save(boolean flag) {
         if (flag) {
-            List<PlayerChunk> list = (List) this.visibleChunks.values().stream().filter(PlayerChunk::hasBeenLoaded).peek(PlayerChunk::m).collect(Collectors.toList());
+            List<PlayerChunk> list = (List) this.chunkMap.getVisibleValues().stream().filter(PlayerChunk::hasBeenLoaded).peek(PlayerChunk::m).collect(Collectors.toList()); /* Concrete - replace chunk map */
             MutableBoolean mutableboolean = new MutableBoolean();
 
             do {
@@ -421,7 +432,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             this.world.asyncChunkTaskManager.flush(); // Paper - flush to preserve behavior compat with pre-async behaviour
             PlayerChunkMap.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", this.x.getName());
         } else {
-            this.visibleChunks.values().stream().filter(PlayerChunk::hasBeenLoaded).forEach((playerchunk) -> {
+            this.chunkMap.getVisibleValues().stream().filter(PlayerChunk::hasBeenLoaded).forEach((playerchunk) -> { /* Concrete - replace chunk map */
                 IChunkAccess ichunkaccess = (IChunkAccess) playerchunk.getChunkSave().getNow(null); // CraftBukkit - decompile error
 
                 if (ichunkaccess instanceof ProtoChunkExtension || ichunkaccess instanceof Chunk) {
@@ -464,7 +475,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         while (longiterator.hasNext()) { // Spigot
             long j = longiterator.nextLong();
             longiterator.remove(); // Spigot
-            PlayerChunk playerchunk = (PlayerChunk) this.updatingChunks.remove(j);
+            PlayerChunk playerchunk = (PlayerChunk) this.chunkMap.queueRemove(j); /* Concrete - replace chunk map */
 
             if (playerchunk != null) {
                 this.pendingUnload.put(j, playerchunk);
@@ -592,7 +603,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         if (!this.updatingChunksModified) {
             return false;
         } else {
-            this.visibleChunks = this.updatingChunks.clone();
+            this.chunkMap.performUpdates(); /* Concrete - replace chunk map */
             this.updatingChunksModified = false;
             return true;
         }
@@ -1006,9 +1017,14 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        /* Concrete start - remove ChunkCoordIntPair allocation, use two ints instead of ChunkCoordIntPair */
+        this.sendChunk(entityplayer, chunkcoordintpair.x, chunkcoordintpair.z, apacket, flag, flag1);
+    }
+    protected void sendChunk(EntityPlayer entityplayer, int chunkX, int chunkZ, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        /* Concrete end */
         if (entityplayer.world == this.world) {
             if (flag1 && !flag) {
-                PlayerChunk playerchunk = this.getVisibleChunk(chunkcoordintpair.pair());
+                PlayerChunk playerchunk = this.getVisibleChunk(ChunkCoordIntPair.pair(chunkX, chunkZ)); /* Concrete - remove ChunkCoordIntPair allocation */
 
                 if (playerchunk != null) {
                     Chunk chunk = playerchunk.getChunk();
@@ -1017,19 +1033,19 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         this.a(entityplayer, apacket, chunk);
                     }
 
-                    PacketDebug.a(this.world, chunkcoordintpair);
+                    //PacketDebug.a(this.world, chunkcoordintpair); /* Concrete - remove ChunkCoordIntPair allocation (this function is a no-op) */
                 }
             }
 
             if (!flag1 && flag) {
-                entityplayer.a(chunkcoordintpair);
+                entityplayer.sendChunkUnload(chunkX, chunkZ); /* Concrete - remove ChunkCoordIntPair allocation */
             }
 
         }
     }
 
     public int d() {
-        return this.visibleChunks.size();
+        return this.chunkMap.getVisibleSizeAsync(); /* Concrete - replace chunk map */
     }
 
     protected PlayerChunkMap.a e() {
@@ -1037,12 +1053,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected Iterable<PlayerChunk> f() {
-        return Iterables.unmodifiableIterable(this.visibleChunks.values());
+        return Iterables.unmodifiableIterable(this.chunkMap.getUpdatingValuesCopy()); /* Concrete - replace chunk map */
     }
 
     void a(Writer writer) throws IOException {
         CSVWriter csvwriter = CSVWriter.a().a("x").a("z").a("level").a("in_memory").a("status").a("full_status").a("accessible_ready").a("ticking_ready").a("entity_ticking_ready").a("ticket").a("spawning").a("entity_count").a("block_entity_count").a(writer);
-        ObjectBidirectionalIterator objectbidirectionaliterator = this.visibleChunks.long2ObjectEntrySet().iterator();
+        ObjectBidirectionalIterator objectbidirectionaliterator = this.chunkMap.getVisibleMap().long2ObjectEntrySet().iterator(); /* Concrete - replace chunk map */
 
         while (objectbidirectionaliterator.hasNext()) {
             Entry<PlayerChunk> entry = (Entry) objectbidirectionaliterator.next();
@@ -1296,11 +1312,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
+        Packet[] cachedPackets = new Packet[2]; /* Concrete */
         for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
             for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
-
-                this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
+                /* Concrete start - remove excess object creation (ChunkCoordIntPair and Packet[]) */
+                this.sendChunk(entityplayer, k, l, cachedPackets, !flag, flag);
+                java.util.Arrays.fill(cachedPackets, null);
+                /* Concrete end */
             }
         }
 
@@ -1372,35 +1390,47 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             int i2 = Math.max(i, i1) + this.viewDistance;
             int j2 = Math.max(j, j1) + this.viewDistance;
 
+            Packet[] cachedPackets = new Packet[2]; /* Concrete */
+
             for (int k2 = k1; k2 <= i2; ++k2) {
                 for (int l2 = l1; l2 <= j2; ++l2) {
-                    ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
+                    /* Concrete start - remove ChunkCoordIntPair allocation */
+                    boolean flag3 = getSquareRadiusDistance(k2, l2, i1, j1) <= this.viewDistance;
+                    boolean flag4 = getSquareRadiusDistance(k2, l2, i, j) <= this.viewDistance;
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
+                    this.sendChunk(entityplayer, k2, l2, cachedPackets, flag3, flag4);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    /* Concrete end */
                 }
             }
         } else {
-            ChunkCoordIntPair chunkcoordintpair1;
+            //ChunkCoordIntPair chunkcoordintpair1; /* Concrete - we don't set, so compile fail on further uses */
             boolean flag5;
             boolean flag6;
 
+            Packet[] cachedPackets = new Packet[2]; /* Concrete */
+
             for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
                 for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
+                    /* Concrete - remove ChunkCoordIntPair allocation */
                     flag5 = true;
                     flag6 = false;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], true, false);
+                    /* Concrete start - remove ChunkCoordIntPair allocation */
+                    this.sendChunk(entityplayer, k1, l1, cachedPackets, true, false);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    /* Concrete end */
                 }
             }
 
             for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
                 for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
+                    /* Concrete - remove ChunkCoordIntPair allocation */
                     flag5 = false;
                     flag6 = true;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], false, true);
+                    /* Concrete start - remove ChunkCoordIntPair allocation */
+                    this.sendChunk(entityplayer, k1, l1, cachedPackets, false, true);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    /* Concrete end */
                 }
             }
         }
@@ -1661,9 +1691,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         public void updatePlayer(EntityPlayer entityplayer) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (entityplayer != this.tracker) {
-                Vec3D vec3d = (new Vec3D(entityplayer.locX, entityplayer.locY, entityplayer.locZ)).d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
+                /* Concrete start - remove allocation of Vec3d here */
+                double vec3d_dx = entityplayer.locX - this.tracker.locX;
+                double vec3d_dy = entityplayer.locY - this.tracker.locY;
+                double vec3d_dz = entityplayer.locZ - this.tracker.locZ;
+                /* Concrete end - remove allocation of Vec3d here */
                 int i = Math.min(this.trackingDistance, (PlayerChunkMap.this.viewDistance - 1) * 16);
-                boolean flag = vec3d.x >= (double) (-i) && vec3d.x <= (double) i && vec3d.z >= (double) (-i) && vec3d.z <= (double) i && this.tracker.a(entityplayer);
+                boolean flag = vec3d_dx >= (double) (-i) && vec3d_dx <= (double) i && vec3d_dz >= (double) (-i) && vec3d_dz <= (double) i && this.tracker.a(entityplayer); /* Concrete start - remove allocation of Vec3d here */
 
                 if (flag) {
                     boolean flag1 = this.tracker.attachedToPlayer;
diff --git a/src/main/java/net/minecraft/server/PlayerInventory.java b/src/main/java/net/minecraft/server/PlayerInventory.java
index 4aee712a6f189c1a053c08eb2f8ebff42f1fe804..32cead99e0ad59960c69c5471a73168c24114e4b 100644
--- a/src/main/java/net/minecraft/server/PlayerInventory.java
+++ b/src/main/java/net/minecraft/server/PlayerInventory.java
@@ -559,8 +559,10 @@ public class PlayerInventory implements IInventory, INamableTileEntity {
 
         NonNullList nonnulllist;
 
-        for (Iterator iterator = this.f.iterator(); iterator.hasNext(); i -= nonnulllist.size()) {
-            nonnulllist = (NonNullList) iterator.next();
+        /* Concrete start - reduce iterator creation */
+        for (int index = 0, len = this.f.size(); index < len; ++index, i -= nonnulllist.size()) {
+            nonnulllist = this.f.get(index);
+            /* Concrete end - reduce iterator creation */
             if (i < nonnulllist.size()) {
                 list = nonnulllist;
                 break;
diff --git a/src/main/java/net/minecraft/server/VoxelShapeArray.java b/src/main/java/net/minecraft/server/VoxelShapeArray.java
index 55d7df61a025954181377423aa5d6c1f4935ba85..51df252591cfc6063cba190cec22d5fd4c72ad70 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeArray.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeArray.java
@@ -11,7 +11,7 @@ public final class VoxelShapeArray extends VoxelShape {
     private final DoubleList d;
 
     protected VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, double[] adouble, double[] adouble1, double[] adouble2) {
-        this(voxelshapediscrete, (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble, voxelshapediscrete.b() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble1, voxelshapediscrete.c() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble2, voxelshapediscrete.d() + 1)));
+        this(voxelshapediscrete, ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList.getList(adouble, voxelshapediscrete.b() + 1), ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList.getList(adouble1, voxelshapediscrete.c() + 1), ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList.getList(adouble2, voxelshapediscrete.d() + 1)); /* Concrete - remove iterator allocation */
     }
 
     VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, DoubleList doublelist, DoubleList doublelist1, DoubleList doublelist2) {
diff --git a/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java b/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
index 9e09671dc24cfcd3bfe872cacdeb0a5d7e83c112..c46089463f8df75e00ff12c6dec4a92494ae262e 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
@@ -2,7 +2,7 @@ package net.minecraft.server;
 
 import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 
-public class VoxelShapeCubePoint extends AbstractDoubleList {
+public class VoxelShapeCubePoint extends ca.spottedleaf.concrete.util.fastutil.ExtendedAbstractDoubleList { /* Concrete - remove iterator allocation */
 
     private final int a;
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapeMergerList.java b/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
index 550620b5fe441d9b7438f334c5997a832f51878a..c316a4c23a31c5c1f470cbf856a1a3e8f445e05e 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
@@ -18,7 +18,7 @@ public final class VoxelShapeMergerList implements VoxelShapeMerger {
         int l = doublelist1.size();
         int i1 = k + l;
 
-        this.a = new DoubleArrayList(i1);
+        this.a = new ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList(i1); /* Concrete - remove iterator creation */
         this.b = new IntArrayList(i1);
         this.c = new IntArrayList(i1);
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index c8bd4b703464ab9d25b7de4b5f9851c717a65a22..811ff0331c6fc63264c4862bf16724c564cc6577 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -19,7 +19,7 @@ public final class VoxelShapes {
         return new VoxelShapeCube(voxelshapebitset);
     });
     public static final VoxelShape a = create(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
-    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}));
+    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D}), new ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D}), new ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D})); /* Concrete - remove iterator allocation */
 
     public static VoxelShape a() {
         return VoxelShapes.c;
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 09c7c697e92cb94a3532a12dd4076d6536b2ff49..a1ba1116fb0458bbd20241c1517b888bc1f0736d 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1648,10 +1648,19 @@ public abstract class World implements IIBlockAccess, GeneratorAccess, AutoClose
     public abstract TagRegistry t();
 
     public BlockPosition a(int i, int j, int k, int l) {
+        /* Concrete start - this function has a very high allocation rate */
+        BlockPosition.MutableBlockPosition ret = new BlockPosition.MutableBlockPosition();
+        this.getRandomBlockPosition(i, j, k, l, ret);
+        return ret.immutableCopy();
+    }
+
+    public BlockPosition.MutableBlockPosition getRandomBlockPosition(int i, int j, int k, int l, BlockPosition.MutableBlockPosition out) {
+        /* Concrete end */
         this.i = this.i * 3 + 1013904223;
         int i1 = this.i >> 2;
 
-        return new BlockPosition(i + (i1 & 15), j + (i1 >> 16 & l), k + (i1 >> 8 & 15));
+        out.setValues(i + (i1 & 15), j + (i1 >> 16 & l), k + (i1 >> 8 & 15)); /* Concrete - change to setValues call */
+        return out; /* Concrete */
     }
 
     public boolean isSavingDisabled() {
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 686e832808ab9ddd58c644a4d1467634f0226d8a..498b473023a283717eaca62964d10d8940481cc1 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -52,7 +52,7 @@ public class WorldServer extends World {
 
     private static final Logger LOGGER = LogManager.getLogger();
     private final List<Entity> globalEntityList = Lists.newArrayList();
-    public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
+    public final Int2ObjectLinkedOpenHashMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap(); /* Concrete - change type for fast iterator */
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
     private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
     public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
@@ -439,7 +439,7 @@ public class WorldServer extends World {
 
             gameprofilerfiller.exitEnter("regular");
             this.tickingEntities = true;
-            ObjectIterator objectiterator = this.entitiesById.int2ObjectEntrySet().iterator();
+            ObjectIterator objectiterator = this.entitiesById.int2ObjectEntrySet().fastIterator(); /* Concrete - use fast iterator to reduce entry creation */
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             timings.entityTick.startTiming(); // Spigot
@@ -501,6 +501,8 @@ public class WorldServer extends World {
         gameprofilerfiller.exit();
     }
 
+    private final BlockPosition.MutableBlockPosition chunkTickMutablePosition = new BlockPosition.MutableBlockPosition(); /* Concrete - use mutable to reduce allocation rate */
+
     public void a(Chunk chunk, int i) {
         ChunkCoordIntPair chunkcoordintpair = chunk.getPos();
         boolean flag = this.isRaining();
@@ -509,10 +511,10 @@ public class WorldServer extends World {
         GameProfilerFiller gameprofilerfiller = this.getMethodProfiler();
 
         gameprofilerfiller.enter("thunder");
-        BlockPosition blockposition;
+        final BlockPosition.MutableBlockPosition blockposition = this.chunkTickMutablePosition; /* Concrete - use mutable to reduce allocation rate, final to force compile fail on change */
 
         if (!this.paperConfig.disableThunder && flag && this.U() && this.random.nextInt(100000) == 0) { // Paper - Disable thunder
-            blockposition = this.a(this.a(j, 0, k, 15));
+            blockposition.setValues(this.a(this.getRandomBlockPosition(j, 0, k, 15, blockposition))); /* Concrete - use mutable to reduce allocation rate */
             if (this.isRainingAt(blockposition)) {
                 DifficultyDamageScaler difficultydamagescaler = this.getDamageScaler(blockposition);
                 boolean flag1 = this.getGameRules().getBoolean(GameRules.DO_MOB_SPAWNING) && this.random.nextDouble() < (double) difficultydamagescaler.b() * paperConfig.skeleHorseSpawnChance; // Paper
@@ -532,7 +534,7 @@ public class WorldServer extends World {
 
         gameprofilerfiller.exitEnter("iceandsnow");
         if (!this.paperConfig.disableIceAndSnow && this.random.nextInt(16) == 0) { // Paper - Disable ice and snow
-            blockposition = this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, this.a(j, 0, k, 15));
+            blockposition.setValues(this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, this.getRandomBlockPosition(j, 0, k, 15, blockposition))); /* Concrete - use mutable to reduce allocation rate */
             BlockPosition blockposition1 = blockposition.down();
             BiomeBase biomebase = this.getBiome(blockposition);
 
@@ -562,7 +564,7 @@ public class WorldServer extends World {
                     int j1 = chunksection.getYPosition();
 
                     for (int k1 = 0; k1 < i; ++k1) {
-                        BlockPosition blockposition2 = this.a(j, j1, k, 15);
+                        BlockPosition blockposition2 = this.getRandomBlockPosition(j, j1, k, 15, blockposition); /* Concrete - use mutable to reduce allocation rate */
 
                         gameprofilerfiller.enter("randomTick");
                         IBlockData iblockdata = chunksection.getType(blockposition2.getX() - j, blockposition2.getY() - j1, blockposition2.getZ() - k);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index f33d9c8b44294dfa2f94e7bdfd1dca599755928b..78ea65707432be1d78d2090be6997d486d2b9223 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -287,9 +287,9 @@ public class CraftWorld implements World {
     }
     public int getTileEntityCount() {
         // We don't use the full world tile entity list, so we must iterate chunks
-        Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
+        Iterable<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues(); /* Concrete - replace chunk map */
         int size = 0;
-        for (net.minecraft.server.PlayerChunk playerchunk : chunks.values()) {
+        for (net.minecraft.server.PlayerChunk playerchunk : chunks) { /* Concrete - replace chunk map */
             net.minecraft.server.Chunk chunk = playerchunk.getChunk();
             if (chunk == null) {
                 continue;
@@ -304,7 +304,7 @@ public class CraftWorld implements World {
     public int getChunkCount() {
         int ret = 0;
 
-        for (PlayerChunk chunkHolder : world.getChunkProvider().playerChunkMap.visibleChunks.values()) {
+        for (PlayerChunk chunkHolder : world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues()) { /* Concrete - replace chunk map */
             if (chunkHolder.getChunk() != null) {
                 ++ret;
             }
@@ -432,8 +432,8 @@ public class CraftWorld implements World {
 
     @Override
     public Chunk[] getLoadedChunks() {
-        Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
-        return chunks.values().stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new);
+        Collection<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues(); /* Concrete - replace chunk map */
+        return chunks.stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new); /* Concrete - replace chunk map */
     }
 
     @Override
-- 
2.22.1

