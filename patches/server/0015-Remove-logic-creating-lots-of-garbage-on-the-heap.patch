From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 27 Aug 2019 15:08:24 -0700
Subject: [PATCH] Remove logic creating lots of garbage on the heap

- PathfinderGoalSelector showed up at the top in memory profiling due
to streams
- ChunkMapDistance showed up at the top too due to bad iterator usage
- PlayerChunkMap#move and ChunkMap showed near the top when moving
around due to avoidable ChunkCoordIntPair allocations
- PathFinderNormal allocates a block position when checking the path
type of a block
- Either.Left/Right do not cache the optional returned for left()/right()
 (getChunk type calls all have to go through them...)
- ObjectAVLTreeSet does not override removeIf, so the default uses
an iterator. removeIf is invoked heavily in ChunkMapDistance (on every
tick). Replace with an impl that caches the iterator
- Some lighting stuff allocating AtomicInteger for passing a second
return value from a function. use int[] instead since the JIT does
not choke on that apparently (confirmed via memory profiling)
- Randomly ticking a block would allocate a BlockPosition, replace
with mutable pos

diff --git a/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedObjectAVLTreeSet.java b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedObjectAVLTreeSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..2206beca4d39d4c12c3c8d1fbd7d0549618e46cf
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedObjectAVLTreeSet.java
@@ -0,0 +1,90 @@
+package ca.spottedleaf.concrete.util.fastutil;
+
+import it.unimi.dsi.fastutil.objects.ObjectAVLTreeSet;
+import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
+
+import java.lang.reflect.Field;
+import java.util.function.Predicate;
+
+public class ExtendedObjectAVLTreeSet<K> extends ObjectAVLTreeSet<K> {
+
+    private static final Field PREV_FIELD;
+    private static final Field NEXT_FIELD;
+    private static final Field CURR_FIELD;
+    private static final Field INDEX_FIELD;
+
+    private static final Integer ZERO = Integer.valueOf(0);
+
+    static {
+        try {
+            final Class clazz = Class.forName(ObjectAVLTreeSet.class.getCanonicalName() + "$SetIterator");
+            PREV_FIELD = clazz.getDeclaredField("prev");
+            PREV_FIELD.setAccessible(true);
+
+            NEXT_FIELD = clazz.getDeclaredField("next");
+            NEXT_FIELD.setAccessible(true);
+
+            CURR_FIELD = clazz.getDeclaredField("curr");
+            CURR_FIELD.setAccessible(true);
+
+            INDEX_FIELD = clazz.getDeclaredField("index");
+            INDEX_FIELD.setAccessible(true);
+        } catch (final Throwable thr) {
+            throw new RuntimeException(thr);
+        }
+    }
+
+    private ObjectBidirectionalIterator<K> cachedIterator = this.iterator();
+
+    {
+        this.nullIterator(this.cachedIterator);
+    }
+
+    @Override
+    public boolean removeIf(Predicate<? super K> filter) {
+        if (this.isEmpty()) {
+            return false;
+        }
+
+        if (this.cachedIterator == null) {
+            return super.removeIf(filter); // recursive...?
+        }
+
+        final ObjectBidirectionalIterator<K> iterator = this.cachedIterator;
+        this.cachedIterator = null;
+        this.startIterator(iterator);
+
+        boolean ret = false;
+
+        while (iterator.hasNext()) {
+            if (filter.test(iterator.next())) {
+                ret = true;
+                iterator.remove();
+            }
+        }
+
+        this.nullIterator(iterator);
+        this.cachedIterator = iterator;
+        return ret;
+    }
+
+    private void startIterator(final ObjectBidirectionalIterator<K> iterator) {
+        // assume iterator is null'd
+        try {
+            NEXT_FIELD.set(iterator, this.firstEntry);
+        } catch (final IllegalAccessException ex) {
+            throw new RuntimeException(ex); // not going to occur
+        }
+    }
+
+    private void nullIterator(final ObjectBidirectionalIterator<K> iterator) {
+        try {
+            PREV_FIELD.set(iterator, null);
+            NEXT_FIELD.set(iterator, null);
+            CURR_FIELD.set(iterator, null);
+            INDEX_FIELD.set(iterator, ZERO);
+        } catch (final IllegalAccessException ex) {
+            throw new RuntimeException(ex); // not going to occur
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/util/pool/PooledBlockPositions.java b/src/main/java/ca/spottedleaf/concrete/util/pool/PooledBlockPositions.java
new file mode 100644
index 0000000000000000000000000000000000000000..2438dba81884f6fc5f5a83961fa27fecf72e3182
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/pool/PooledBlockPositions.java
@@ -0,0 +1,40 @@
+package ca.spottedleaf.concrete.util.pool;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.MinecraftServer;
+
+public class PooledBlockPositions {
+
+    private static final int BLOCK_POOL_SIZE = 8192;
+
+    private static final BlockPosition.MutableBlockPosition[] POOL = new BlockPosition.MutableBlockPosition[BLOCK_POOL_SIZE];
+    private static int used = 0; // exclusive index of used positions
+
+    static {
+        for (int i = 0; i < BLOCK_POOL_SIZE; ++i) {
+            POOL[i] = new BlockPosition.MutableBlockPosition();
+        }
+    }
+
+    public static BlockPosition.MutableBlockPosition get(final int x, final int y, final int z) {
+        final int currentUsed = used;
+        if (Thread.currentThread() != MinecraftServer.getServer().serverThread || currentUsed >= POOL.length) {
+            return new BlockPosition.MutableBlockPosition(x, y, z);
+        }
+        used = currentUsed + 1;
+
+        final BlockPosition.MutableBlockPosition ret = POOL[currentUsed];
+        POOL[currentUsed] = null;
+
+        return ret.setValues(x, y, z);
+    }
+
+    public static void ret(final BlockPosition.MutableBlockPosition position) {
+        final int currentUsed = used;
+        if (Thread.currentThread() != MinecraftServer.getServer().serverThread || currentUsed == 0) {
+            return;
+        }
+
+        POOL[used = currentUsed - 1] = position;
+    }
+}
diff --git a/src/main/java/com/mojang/datafixers/util/Either.java b/src/main/java/com/mojang/datafixers/util/Either.java
index a90adac7bd7ebd423f480e9ae0f44cb9d521fa4f..19763d89e5b2b09223b6a44fa11a7cfa179ec116 100644
--- a/src/main/java/com/mojang/datafixers/util/Either.java
+++ b/src/main/java/com/mojang/datafixers/util/Either.java
@@ -23,6 +23,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
     private static final class Left<L, R> extends Either<L, R> {
         private final L value;
+        private Optional<L> cachedLeft; /* Concrete - reduce allocation of these for chunks... */
 
         public Left(final L value) {
             this.value = value;
@@ -51,7 +52,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
         @Override
         public Optional<L> left() {
-            return Optional.of(value);
+            return this.cachedLeft == null ? this.cachedLeft = Optional.of(value) : this.cachedLeft; /* Concrete - cache optional */
         }
 
         @Override
@@ -84,6 +85,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
     private static final class Right<L, R> extends Either<L, R> {
         private final R value;
+        private Optional<R> cachedRight; /* Concrete - reduce allocation of these for chunks... */
 
         public Right(final R value) {
             this.value = value;
@@ -117,7 +119,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
         @Override
         public Optional<R> right() {
-            return Optional.of(value);
+            return this.cachedRight == null ? this.cachedRight = Optional.of(value) : this.cachedRight; /* Concrete - cache optional */
         }
 
         @Override
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index 16f0930404457772838e246d237e44c17e006764..e2bb63cc93fbda26f046592d02677fbd2b784ad4 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -449,6 +449,7 @@ public class BlockPosition extends BaseBlockPosition implements MinecraftSeriali
             return this.d(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
         }
 
+        public final BlockPosition.MutableBlockPosition setValues(final BaseBlockPosition baseblockposition) { return this.g(baseblockposition); } /* Concrete - OBFHELPER */
         public BlockPosition.MutableBlockPosition g(BaseBlockPosition baseblockposition) {
             return this.d(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
         }
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 55f9f4e6e7fddb2fcdbc1877d1bdfe8d3c9eff6f..50444a2f49f07e66ff9ea55dacc1819023ea6624 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -13,9 +13,10 @@ public abstract class ChunkMap extends LightEngineGraph {
 
     @Override
     protected void a(long i, int j, boolean flag) {
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int k = chunkcoordintpair.x;
-        int l = chunkcoordintpair.z;
+        /* Concrete start - remove allocation of ChunkCoordIntPair */
+        int k = ChunkCoordIntPair.getX(i);
+        int l = ChunkCoordIntPair.getZ(i);
+        /* Concrete end */
 
         for (int i1 = -1; i1 <= 1; ++i1) {
             for (int j1 = -1; j1 <= 1; ++j1) {
@@ -32,9 +33,10 @@ public abstract class ChunkMap extends LightEngineGraph {
     @Override
     protected int a(long i, long j, int k) {
         int l = k;
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int i1 = chunkcoordintpair.x;
-        int j1 = chunkcoordintpair.z;
+        /* Concrete start - remove allocation of ChunkCoordIntPair */
+        int i1 = ChunkCoordIntPair.getX(i);
+        int j1 = ChunkCoordIntPair.getZ(i);
+        /* Concrete end */
 
         for (int k1 = -1; k1 <= 1; ++k1) {
             for (int l1 = -1; l1 <= 1; ++l1) {
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 851bb2f01b1f59cf9d3fbd78c36d155b17efa1ab..7c5649de63d125e699bae4c3a91ac0ae82cf5d89 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -77,10 +77,14 @@ public abstract class ChunkMapDistance {
     }
 
     private int a(ObjectSortedSet<Ticket<?>> objectsortedset) {
-        ObjectBidirectionalIterator<Ticket<?>> objectbidirectionaliterator = objectsortedset.iterator();
+        return getLowestTicketLevel(objectsortedset); /* Concrete - this creates a lot of garbage so remove the iterator */
+    }
 
-        return objectbidirectionaliterator.hasNext() ? ((Ticket) objectbidirectionaliterator.next()).b() : PlayerChunkMap.GOLDEN_TICKET + 1;
+    /* Concrete start */
+    static int getLowestTicketLevel(ObjectSortedSet<Ticket<?>> set) {
+        return set.isEmpty() ? PlayerChunkMap.GOLDEN_TICKET + 1 : set.first().getTicketLevel();
     }
+    /* Concrete end */
 
     protected abstract boolean a(long i);
 
@@ -144,14 +148,9 @@ public abstract class ChunkMapDistance {
     private boolean addTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
         ca.spottedleaf.concrete.util.TickThread.softEnsureTickThread("Async ticket add"); /* Concrete */
         ObjectSortedSet<Ticket<?>> objectsortedset = this.e(i);
-        ObjectBidirectionalIterator<Ticket<?>> objectbidirectionaliterator = objectsortedset.iterator();
-        int j;
+        int j = getLowestTicketLevel(objectsortedset); /* Concrete - iterator creates a lot of garbage */
 
-        if (objectbidirectionaliterator.hasNext()) {
-            j = ((Ticket) objectbidirectionaliterator.next()).b();
-        } else {
-            j = PlayerChunkMap.GOLDEN_TICKET + 1;
-        }
+        /* Concrete - remove iterator usage */
 
         boolean ret = false; // CraftBukkit
         if (objectsortedset.add(ticket)) {
@@ -217,7 +216,7 @@ public abstract class ChunkMapDistance {
     private ObjectSortedSet<Ticket<?>> e(long i) {
         ca.spottedleaf.concrete.util.TickThread.softEnsureTickThread("Async tickets compute"); /* Concrete */
         return (ObjectSortedSet) this.tickets.computeIfAbsent(i, (j) -> {
-            return new ObjectAVLTreeSet();
+            return new ca.spottedleaf.concrete.util.fastutil.ExtendedObjectAVLTreeSet(); /* Concrete - Replace with optimized removeIf impl */
         });
     }
 
@@ -317,9 +316,7 @@ public abstract class ChunkMapDistance {
             if (objectsortedset == null) {
                 return Integer.MAX_VALUE;
             } else {
-                ObjectBidirectionalIterator<Ticket<?>> objectbidirectionaliterator = objectsortedset.iterator();
-
-                return !objectbidirectionaliterator.hasNext() ? Integer.MAX_VALUE : ((Ticket) objectbidirectionaliterator.next()).b();
+                return objectsortedset.isEmpty() ? Integer.MAX_VALUE : ((Ticket) objectsortedset.first()).b(); /* Concrete - iterator creates a lot of garbage */
             }
         }
 
@@ -372,7 +369,7 @@ public abstract class ChunkMapDistance {
         }
 
         public void a(int i) {
-            ObjectIterator objectiterator = this.a.long2ByteEntrySet().iterator();
+            ObjectIterator objectiterator = this.a.long2ByteEntrySet().fastIterator(); /* Concrete - use fast iterator (reduces entry creation) */
 
             while (objectiterator.hasNext()) {
                 it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
@@ -453,7 +450,7 @@ public abstract class ChunkMapDistance {
 
     class b extends ChunkMap {
 
-        protected final Long2ByteMap a = new Long2ByteOpenHashMap();
+        protected final Long2ByteOpenHashMap a = new Long2ByteOpenHashMap(); /* Concrete - change type for fast iterator */
         protected final int b;
 
         protected b(int i) {
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index a78fea826f781edd4442ec7335da59f443228bc4..ea0767b3361336a8af7791363621732fa194babd 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -1780,7 +1780,12 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void a(ChunkCoordIntPair chunkcoordintpair) {
-        this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(chunkcoordintpair.x, chunkcoordintpair.z));
+        /* Concrete start - remove ChunkCoordIntPair allocation */
+        this.sendChunkUnload(chunkcoordintpair.x, chunkcoordintpair.z);
+    }
+    public void sendChunkUnload(int chunkX, int chunkZ) {
+        this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(chunkX, chunkZ));
+        /* Concrete end */
     }
 
     public SectionPosition getPlayerMapSection() { return this.M(); } // Paper - OBFHELPER
diff --git a/src/main/java/net/minecraft/server/LightEngineBlock.java b/src/main/java/net/minecraft/server/LightEngineBlock.java
index 7b0e24888e9f4bfbc0e65c6c59ca6f1b39d29c36..2e4644d28075be0d910c1d7a7a4c85452dcc6f0b 100644
--- a/src/main/java/net/minecraft/server/LightEngineBlock.java
+++ b/src/main/java/net/minecraft/server/LightEngineBlock.java
@@ -37,17 +37,19 @@ public final class LightEngineBlock extends LightEngineLayer<LightEngineStorageB
             if (enumdirection == null) {
                 return 15;
             } else {
-                AtomicInteger atomicinteger = new AtomicInteger();
-                IBlockData iblockdata = this.a(j, atomicinteger);
+                /* Concrete start - apparently the JIT has a rough time stack allocating AtomicInteger... */
+                int[] atomicinteger = new int[1];
+                IBlockData iblockdata = this.getTypeAndLevelForType(j, atomicinteger);
+                /* Concrete end - apparently the JIT has a rough time stack allocating AtomicInteger... */
 
-                if (atomicinteger.get() >= 15) {
+                if (atomicinteger[0] >= 15) { /* Concrete - apparently the JIT has a rough time stack allocating AtomicInteger... */
                     return 15;
                 } else {
-                    IBlockData iblockdata1 = this.a(i, (AtomicInteger) null);
+                    IBlockData iblockdata1 = this.getTypeAndLevelForType(i, null); /* Concrete - apparently the JIT has a rough time stack allocating AtomicInteger... */
                     VoxelShape voxelshape = this.a(iblockdata1, i, enumdirection);
                     VoxelShape voxelshape1 = this.a(iblockdata, j, enumdirection.opposite());
 
-                    return VoxelShapes.b(voxelshape, voxelshape1) ? 15 : k + Math.max(1, atomicinteger.get());
+                    return VoxelShapes.b(voxelshape, voxelshape1) ? 15 : k + Math.max(1, atomicinteger[0]); /* Concrete - apparently the JIT has a rough time stack allocating AtomicInteger... */
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/server/LightEngineLayer.java b/src/main/java/net/minecraft/server/LightEngineLayer.java
index bc5743501fb6b9b9d2c33afa2c781ce42f178136..ae6235dedd615ce90f1ae09a5c2f9e6978fe493a 100644
--- a/src/main/java/net/minecraft/server/LightEngineLayer.java
+++ b/src/main/java/net/minecraft/server/LightEngineLayer.java
@@ -60,9 +60,19 @@ public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S e
     }
 
     protected IBlockData a(long i, @Nullable AtomicInteger atomicinteger) {
+        /* Concrete start - apparently the JIT has a rough time stack allocating AtomicInteger... */
+        int[] level = atomicinteger == null ? null : new int[1];
+        IBlockData ret = this.getTypeAndLevelForType(i, level);
+        if (atomicinteger != null) {
+            atomicinteger.lazySet(level[0]);
+        }
+        return ret;
+    }
+    protected IBlockData getTypeAndLevelForType(long i, @Nullable int[] atomicinteger) {
+        /* Concrete end */
         if (i == Long.MAX_VALUE) {
             if (atomicinteger != null) {
-                atomicinteger.set(0);
+                atomicinteger[0] = 0; /* Concrete - apparently the JIT has a rough time stack allocating AtomicInteger... */
             }
 
             return Blocks.AIR.getBlockData();
@@ -73,7 +83,7 @@ public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S e
 
             if (iblockaccess == null) {
                 if (atomicinteger != null) {
-                    atomicinteger.set(16);
+                    atomicinteger[0] = 16; /* Concrete - apparently the JIT has a rough time stack allocating AtomicInteger... */
                 }
 
                 return Blocks.BEDROCK.getBlockData();
@@ -83,7 +93,7 @@ public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S e
                 boolean flag = iblockdata.o() && iblockdata.g();
 
                 if (atomicinteger != null) {
-                    atomicinteger.set(iblockdata.b(this.a.getWorld(), (BlockPosition) this.d));
+                    atomicinteger[0] = (iblockdata.b(this.a.getWorld(), (BlockPosition) this.d)); /* Concrete - apparently the JIT has a rough time stack allocating AtomicInteger... */
                 }
 
                 return flag ? iblockdata : Blocks.AIR.getBlockData();
diff --git a/src/main/java/net/minecraft/server/LightEngineSky.java b/src/main/java/net/minecraft/server/LightEngineSky.java
index 04c70d517c47edae497ec48bbff7a9d5d5f4e8a8..fec171b378415efbb8210d457b77c4995f8839dc 100644
--- a/src/main/java/net/minecraft/server/LightEngineSky.java
+++ b/src/main/java/net/minecraft/server/LightEngineSky.java
@@ -27,10 +27,12 @@ public final class LightEngineSky extends LightEngineLayer<LightEngineStorageSky
             if (k >= 15) {
                 return k;
             } else {
-                AtomicInteger atomicinteger = new AtomicInteger();
-                IBlockData iblockdata = this.a(j, atomicinteger);
+                /* Concrete start - apparently the JIT has a rough time stack allocating AtomicInteger... */
+                int[] atomicinteger = new int[1];
+                IBlockData iblockdata = this.getTypeAndLevelForType(j, atomicinteger);
+                /* Concrete end - apparently the JIT has a rough time stack allocating AtomicInteger... */
 
-                if (atomicinteger.get() >= 15) {
+                if (atomicinteger[0] >= 15) { /* Concrete - apparently the JIT has a rough time stack allocating AtomicInteger... */
                     return 15;
                 } else {
                     int l = BlockPosition.b(i);
@@ -51,7 +53,7 @@ public final class LightEngineSky extends LightEngineLayer<LightEngineStorageSky
                         enumdirection = EnumDirection.a(j2, k2, l2);
                     }
 
-                    IBlockData iblockdata1 = this.a(i, (AtomicInteger) null);
+                    IBlockData iblockdata1 = this.getTypeAndLevelForType(i, null); /* Concrete - apparently the JIT has a rough time stack allocating AtomicInteger... */
                     VoxelShape voxelshape;
 
                     if (enumdirection != null) {
@@ -83,7 +85,7 @@ public final class LightEngineSky extends LightEngineLayer<LightEngineStorageSky
 
                     boolean flag1 = i == Long.MAX_VALUE || flag && i1 > l1;
 
-                    return flag1 && k == 0 && atomicinteger.get() == 0 ? 0 : k + Math.max(1, atomicinteger.get());
+                    return flag1 && k == 0 && atomicinteger[0] == 0 ? 0 : k + Math.max(1, atomicinteger[0]); /* Concrete - apparently the JIT has a rough time stack allocating AtomicInteger... */
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 14f8b610422fcda13818e3a54ce538a6902746de..1872a62e04aff372120df2e5cc969970d52c19cc 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -535,4 +535,28 @@ public final class MCUtil {
         // TODO make sure the constant `33` is correct on future updates. See getChunkAt(int, int, ChunkStatus, boolean)
         return 33 + ChunkStatus.getTicketLevelOffset(status);
     }
+
+    public static <E> boolean hasCommonElement(Set<E> set0, Set<E> set1) {
+        java.util.Iterator<E> iterator;
+        Set<E> target;
+
+        // optimize by iterating over fewest entries possible
+        if (set0.size() <= set1.size()) {
+            target = set1;
+            iterator = set0.iterator();
+        } else {
+            target = set0;
+            iterator = set1.iterator();
+        }
+
+        while (iterator.hasNext()) {
+            E element = iterator.next();
+            if (target.contains(element)) {
+                return true;
+            }
+        }
+
+        return false;
+
+    }
 }
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
index 44bb18c5945b69f09b3a6e6272f2c3a5477780c7..bd4ff3589e8cc108cbee77e08dc9aab28250470f 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
@@ -3,6 +3,7 @@ package net.minecraft.server;
 import com.google.common.collect.Sets;
 import java.util.EnumMap;
 import java.util.EnumSet;
+import java.util.Iterator; /* Concrete */
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Stream;
@@ -38,33 +39,36 @@ public class PathfinderGoalSelector {
     }
 
     public void a(PathfinderGoal pathfindergoal) {
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        }).filter(PathfinderGoalWrapped::g).forEach(PathfinderGoalWrapped::d);
-        this.d.removeIf((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        });
+        /* Concrete start - remove streams */
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped goalWrapped = iterator.next();
+            if (goalWrapped.j() != pathfindergoal) {
+                continue;
+            }
+            if (goalWrapped.g()) {
+                goalWrapped.d();
+            }
+            iterator.remove();
+        }
+        /* Concrete end */
     }
 
     public void doTick() {
         this.e.enter("goalCleanup");
-        this.c().filter((pathfindergoalwrapped) -> {
-            boolean flag;
-
-            if (pathfindergoalwrapped.g()) {
-                Stream stream = pathfindergoalwrapped.i().stream();
-                EnumSet enumset = this.f;
+        /* Concrete start - remove streams */
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (!wrappedGoal.g()) {
+                continue;
+            }
 
-                this.f.getClass();
-                if (!stream.anyMatch(enumset::contains) && pathfindergoalwrapped.b()) {
-                    flag = false;
-                    return flag;
-                }
+            if (!MCUtil.hasCommonElement(wrappedGoal.i(), this.f) && wrappedGoal.b()) {
+                continue;
             }
 
-            flag = true;
-            return flag;
-        }).forEach(PathfinderGoal::d);
+            wrappedGoal.d();
+        }
+        /* Concrete end */
         this.c.forEach((pathfindergoal_type, pathfindergoalwrapped) -> {
             if (!pathfindergoalwrapped.g()) {
                 this.c.remove(pathfindergoal_type);
@@ -73,30 +77,53 @@ public class PathfinderGoalSelector {
         });
         this.e.exit();
         this.e.enter("goalUpdate");
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return !pathfindergoalwrapped.g();
-        }).filter((pathfindergoalwrapped) -> {
-            Stream stream = pathfindergoalwrapped.i().stream();
-            EnumSet enumset = this.f;
-
-            this.f.getClass();
-            return stream.noneMatch(enumset::contains);
-        }).filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.i().stream().allMatch((pathfindergoal_type) -> {
-                return ((PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b)).a(pathfindergoalwrapped);
-            });
-        }).filter(PathfinderGoalWrapped::a).forEach((pathfindergoalwrapped) -> {
-            pathfindergoalwrapped.i().forEach((pathfindergoal_type) -> {
-                PathfinderGoalWrapped pathfindergoalwrapped1 = (PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b);
-
-                pathfindergoalwrapped1.d();
-                this.c.put(pathfindergoal_type, pathfindergoalwrapped);
-            });
-            pathfindergoalwrapped.c();
-        });
+        /* Concrete start - remove streams */
+        goal_update_loop: for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (wrappedGoal.g()) {
+                continue;
+            }
+
+            EnumSet<PathfinderGoal.Type> set = this.f;
+            EnumSet<PathfinderGoal.Type> wrappedGoalSet = wrappedGoal.i();
+
+            if (MCUtil.hasCommonElement(set, wrappedGoalSet)) {
+                continue;
+            }
+
+            for (Iterator<PathfinderGoal.Type> iterator1 = wrappedGoalSet.iterator(); iterator1.hasNext();) {
+                PathfinderGoal.Type type = iterator1.next();
+                PathfinderGoalWrapped wrapped = this.c.getOrDefault(type, PathfinderGoalSelector.b);
+                if (!wrapped.a(wrappedGoal)) {
+                    continue goal_update_loop;
+                }
+            }
+
+            if (!wrappedGoal.a()) {
+                continue;
+            }
+
+            for (Iterator<PathfinderGoal.Type> iterator1 = wrappedGoalSet.iterator(); iterator1.hasNext();) {
+                PathfinderGoal.Type type = iterator1.next();
+                PathfinderGoalWrapped wrapped = this.c.getOrDefault(type, PathfinderGoalSelector.b);
+
+                wrapped.d();
+                this.c.put(type, wrappedGoal);
+            }
+
+            wrappedGoal.c();
+        }
+        /* Concrete end */
         this.e.exit();
         this.e.enter("goalTick");
-        this.c().forEach(PathfinderGoalWrapped::e);
+        /* Concrete start - remove streams */
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (wrappedGoal.g()) {
+                wrappedGoal.e();
+            }
+        }
+        /* Concrete end */
         this.e.exit();
     }
 
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 45fd135034de668c1f4282fe538e8d352db49278..d871ac2ad1ae38a160f8cb4e3f158c2e46d75db5 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -421,8 +421,10 @@ public class PathfinderNormal extends PathfinderAbstract {
         return pathtype;
     }
 
+    private static final BlockPosition.MutableBlockPosition PATH_TYPE_BLOCKPOSITION = new BlockPosition.MutableBlockPosition(); /* Concrete - this shows to be a high allocator */
+
     protected PathType b(IBlockAccess iblockaccess, int i, int j, int k) {
-        BlockPosition blockposition = new BlockPosition(i, j, k);
+        final BlockPosition.MutableBlockPosition blockposition = PATH_TYPE_BLOCKPOSITION.setValues(i, j, k); /* Concrete - this shows to be a high allocator */
         IBlockData iblockdata = iblockaccess.getTypeIfLoaded(blockposition); // Paper
         if (iblockdata == null) return PathType.BLOCKED; // Paper
         Block block = iblockdata.getBlock();
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index b4307f2a30ccd48e367580408d7172e2c7edc4fe..c1b97f3e6a410bc8af8bea315e46c255b521a23f 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -221,8 +221,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     private static int a(ChunkCoordIntPair chunkcoordintpair, int i, int j) {
-        int k = chunkcoordintpair.x - i;
-        int l = chunkcoordintpair.z - j;
+        /* Concrete start - remove ChunkCoordIntPair allocation */
+        return getSquareRadiusDistance(chunkcoordintpair.x, chunkcoordintpair.z, i, j);
+    }
+    private static int getSquareRadiusDistance(int chunkX0, int chunkZ0, int i, int j) {
+        int k = chunkX0 - i;
+        int l = chunkZ0 - j;
+        /* Concrete end */
 
         return Math.max(Math.abs(k), Math.abs(l));
     }
@@ -1000,9 +1005,14 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        /* Concrete start - remove ChunkCoordIntPair allocation, use two ints instead of ChunkCoordIntPair */
+        this.sendChunk(entityplayer, chunkcoordintpair.x, chunkcoordintpair.z, apacket, flag, flag1);
+    }
+    protected void sendChunk(EntityPlayer entityplayer, int chunkX, int chunkZ, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        /* Concrete end */
         if (entityplayer.world == this.world) {
             if (flag1 && !flag) {
-                PlayerChunk playerchunk = this.getVisibleChunk(chunkcoordintpair.pair());
+                PlayerChunk playerchunk = this.getVisibleChunk(ChunkCoordIntPair.pair(chunkX, chunkZ)); /* Concrete - remove ChunkCoordIntPair allocation */
 
                 if (playerchunk != null) {
                     Chunk chunk = playerchunk.getChunk();
@@ -1011,12 +1021,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         this.a(entityplayer, apacket, chunk);
                     }
 
-                    PacketDebug.a(this.world, chunkcoordintpair);
+                    //PacketDebug.a(this.world, chunkcoordintpair); /* Concrete - remove ChunkCoordIntPair allocation (this function is a no-op) */
                 }
             }
 
             if (!flag1 && flag) {
-                entityplayer.a(chunkcoordintpair);
+                entityplayer.sendChunkUnload(chunkX, chunkZ); /* Concrete - remove ChunkCoordIntPair allocation */
             }
 
         }
@@ -1290,11 +1300,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
+        Packet[] cachedPackets = new Packet[2]; /* Concrete */
         for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
             for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
-
-                this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
+                /* Concrete start - remove excess object creation (ChunkCoordIntPair and Packet[]) */
+                this.sendChunk(entityplayer, k, l, cachedPackets, !flag, flag);
+                java.util.Arrays.fill(cachedPackets, null);
+                /* Concrete end */
             }
         }
 
@@ -1366,35 +1378,47 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             int i2 = Math.max(i, i1) + this.viewDistance;
             int j2 = Math.max(j, j1) + this.viewDistance;
 
+            Packet[] cachedPackets = new Packet[2]; /* Concrete */
+
             for (int k2 = k1; k2 <= i2; ++k2) {
                 for (int l2 = l1; l2 <= j2; ++l2) {
-                    ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
+                    /* Concrete start - remove ChunkCoordIntPair allocation */
+                    boolean flag3 = getSquareRadiusDistance(k2, l2, i1, j1) <= this.viewDistance;
+                    boolean flag4 = getSquareRadiusDistance(k2, l2, i, j) <= this.viewDistance;
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
+                    this.sendChunk(entityplayer, k2, l2, cachedPackets, flag3, flag4);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    /* Concrete end */
                 }
             }
         } else {
-            ChunkCoordIntPair chunkcoordintpair1;
+            //ChunkCoordIntPair chunkcoordintpair1; /* Concrete - we don't set, so compile fail on further uses */
             boolean flag5;
             boolean flag6;
 
+            Packet[] cachedPackets = new Packet[2]; /* Concrete */
+
             for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
                 for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
+                    /* Concrete - remove ChunkCoordIntPair allocation */
                     flag5 = true;
                     flag6 = false;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], true, false);
+                    /* Concrete start - remove ChunkCoordIntPair allocation */
+                    this.sendChunk(entityplayer, k1, l1, cachedPackets, true, false);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    /* Concrete end */
                 }
             }
 
             for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
                 for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
+                    /* Concrete - remove ChunkCoordIntPair allocation */
                     flag5 = false;
                     flag6 = true;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], false, true);
+                    /* Concrete start - remove ChunkCoordIntPair allocation */
+                    this.sendChunk(entityplayer, k1, l1, cachedPackets, false, true);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    /* Concrete end */
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 924598eccd6dc95884e7a002e47e0a87783968b5..1a8cc4662620e8d5ff445b3b43d35f285b5fceed 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1634,10 +1634,19 @@ public abstract class World implements IIBlockAccess, GeneratorAccess, AutoClose
     public abstract TagRegistry t();
 
     public BlockPosition a(int i, int j, int k, int l) {
+        /* Concrete start - this function has a very high allocation rate */
+        BlockPosition.MutableBlockPosition ret = new BlockPosition.MutableBlockPosition();
+        this.getRandomBlockPosition(i, j, k, l, ret);
+        return ret.immutableCopy();
+    }
+
+    public BlockPosition.MutableBlockPosition getRandomBlockPosition(int i, int j, int k, int l, BlockPosition.MutableBlockPosition out) {
+        /* Concrete end */
         this.i = this.i * 3 + 1013904223;
         int i1 = this.i >> 2;
 
-        return new BlockPosition(i + (i1 & 15), j + (i1 >> 16 & l), k + (i1 >> 8 & 15));
+        out.setValues(i + (i1 & 15), j + (i1 >> 16 & l), k + (i1 >> 8 & 15)); /* Concrete - change to setValues call */
+        return out; /* Concrete */
     }
 
     public boolean isSavingDisabled() {
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index a6a9844009da9f9daacc6685a5174582c6cd8fb1..1ad6c62d9c5c97e14b726aced9956c31cc1c9ec6 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -466,6 +466,8 @@ public class WorldServer extends World {
         gameprofilerfiller.exit();
     }
 
+    private final BlockPosition.MutableBlockPosition chunkTickMutablePosition = new BlockPosition.MutableBlockPosition(); /* Concrete - use mutable to reduce allocation rate */
+
     public void a(Chunk chunk, int i) {
         ChunkCoordIntPair chunkcoordintpair = chunk.getPos();
         boolean flag = this.isRaining();
@@ -474,10 +476,10 @@ public class WorldServer extends World {
         GameProfilerFiller gameprofilerfiller = this.getMethodProfiler();
 
         gameprofilerfiller.enter("thunder");
-        BlockPosition blockposition;
+        final BlockPosition.MutableBlockPosition blockposition = this.chunkTickMutablePosition; /* Concrete - use mutable to reduce allocation rate, final to force compile fail on change */
 
         if (!this.paperConfig.disableThunder && flag && this.U() && this.random.nextInt(100000) == 0) { // Paper - Disable thunder
-            blockposition = this.a(this.a(j, 0, k, 15));
+            blockposition.setValues(this.a(this.getRandomBlockPosition(j, 0, k, 15, blockposition))); /* Concrete - use mutable to reduce allocation rate */
             if (this.isRainingAt(blockposition)) {
                 DifficultyDamageScaler difficultydamagescaler = this.getDamageScaler(blockposition);
                 boolean flag1 = this.getGameRules().getBoolean(GameRules.DO_MOB_SPAWNING) && this.random.nextDouble() < (double) difficultydamagescaler.b() * paperConfig.skeleHorseSpawnChance; // Paper
@@ -497,7 +499,7 @@ public class WorldServer extends World {
 
         gameprofilerfiller.exitEnter("iceandsnow");
         if (!this.paperConfig.disableIceAndSnow && this.random.nextInt(16) == 0) { // Paper - Disable ice and snow
-            blockposition = this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, this.a(j, 0, k, 15));
+            blockposition.setValues(this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, this.getRandomBlockPosition(j, 0, k, 15, blockposition))); /* Concrete - use mutable to reduce allocation rate */
             BlockPosition blockposition1 = blockposition.down();
             BiomeBase biomebase = this.getBiome(blockposition);
 
@@ -527,7 +529,7 @@ public class WorldServer extends World {
                     int j1 = chunksection.getYPosition();
 
                     for (int k1 = 0; k1 < i; ++k1) {
-                        BlockPosition blockposition2 = this.a(j, j1, k, 15);
+                        BlockPosition blockposition2 = this.getRandomBlockPosition(j, j1, k, 15, blockposition); /* Concrete - use mutable to reduce allocation rate */
 
                         gameprofilerfiller.enter("randomTick");
                         IBlockData iblockdata = chunksection.getType(blockposition2.getX() - j, blockposition2.getY() - j1, blockposition2.getZ() - k);
